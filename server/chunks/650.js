exports.id = 650;
exports.ids = [650];
exports.modules = {

/***/ 9160:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unitlessKeys)
/* harmony export */ });
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};




/***/ }),

/***/ 3022:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "addBasePath", ({
    enumerable: true,
    get: function() {
        return addBasePath;
    }
}));
const _addpathprefix = __webpack_require__(1751);
const _normalizetrailingslash = __webpack_require__(8115);
const basePath =  false || "";
function addBasePath(path, required) {
    if (false) {}
    return (0, _normalizetrailingslash.normalizePathTrailingSlash)((0, _addpathprefix.addPathPrefix)(path, basePath));
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=add-base-path.js.map


/***/ }),

/***/ 6942:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "callServer", ({
    enumerable: true,
    get: function() {
        return callServer;
    }
}));
const _approuter = __webpack_require__(9222);
async function callServer(actionId, actionArgs) {
    const actionDispatcher = (0, _approuter.getServerActionDispatcher)();
    if (!actionDispatcher) {
        throw new Error("Invariant: missing action dispatcher.");
    }
    return new Promise((resolve, reject)=>{
        actionDispatcher({
            actionId,
            actionArgs,
            resolve,
            reject
        });
    });
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-call-server.js.map


/***/ }),

/***/ 5087:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "AppRouterAnnouncer", ({
    enumerable: true,
    get: function() {
        return AppRouterAnnouncer;
    }
}));
const _react = __webpack_require__(8038);
const _reactdom = __webpack_require__(8704);
const ANNOUNCER_TYPE = "next-route-announcer";
const ANNOUNCER_ID = "__next-route-announcer__";
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = "position:absolute";
        const announcer = document.createElement("div");
        announcer.setAttribute("aria-live", "assertive");
        announcer.setAttribute("id", ANNOUNCER_ID);
        announcer.setAttribute("role", "alert");
        announcer.style.cssText = "position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal";
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: "open"
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
function AppRouterAnnouncer(param) {
    let { tree  } = param;
    const [portalNode, setPortalNode] = (0, _react.useState)(null);
    (0, _react.useEffect)(()=>{
        const announcer = getAnnouncerNode();
        setPortalNode(announcer);
        return ()=>{
            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];
            if (container == null ? void 0 : container.isConnected) {
                document.body.removeChild(container);
            }
        };
    }, []);
    const [routeAnnouncement, setRouteAnnouncement] = (0, _react.useState)("");
    const previousTitle = (0, _react.useRef)();
    (0, _react.useEffect)(()=>{
        let currentTitle = "";
        if (document.title) {
            currentTitle = document.title;
        } else {
            const pageHeader = document.querySelector("h1");
            if (pageHeader) {
                currentTitle = pageHeader.innerText || pageHeader.textContent || "";
            }
        }
        // Only announce the title change, but not for the first load because screen
        // readers do that automatically.
        if (typeof previousTitle.current !== "undefined") {
            setRouteAnnouncement(currentTitle);
        }
        previousTitle.current = currentTitle;
    }, [
        tree
    ]);
    return portalNode ? /*#__PURE__*/ (0, _reactdom.createPortal)(routeAnnouncement, portalNode) : null;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-announcer.js.map


/***/ }),

/***/ 2982:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RSC: function() {
        return RSC;
    },
    ACTION: function() {
        return ACTION;
    },
    NEXT_ROUTER_STATE_TREE: function() {
        return NEXT_ROUTER_STATE_TREE;
    },
    NEXT_ROUTER_PREFETCH: function() {
        return NEXT_ROUTER_PREFETCH;
    },
    NEXT_URL: function() {
        return NEXT_URL;
    },
    FETCH_CACHE_HEADER: function() {
        return FETCH_CACHE_HEADER;
    },
    RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
    },
    RSC_VARY_HEADER: function() {
        return RSC_VARY_HEADER;
    },
    FLIGHT_PARAMETERS: function() {
        return FLIGHT_PARAMETERS;
    }
});
const RSC = "RSC";
const ACTION = "Next-Action";
const NEXT_ROUTER_STATE_TREE = "Next-Router-State-Tree";
const NEXT_ROUTER_PREFETCH = "Next-Router-Prefetch";
const NEXT_URL = "Next-Url";
const FETCH_CACHE_HEADER = "x-vercel-sc-headers";
const RSC_CONTENT_TYPE_HEADER = "text/x-component";
const RSC_VARY_HEADER = RSC + ", " + NEXT_ROUTER_STATE_TREE + ", " + NEXT_ROUTER_PREFETCH;
const FLIGHT_PARAMETERS = [
    [
        RSC
    ],
    [
        NEXT_ROUTER_STATE_TREE
    ],
    [
        NEXT_ROUTER_PREFETCH
    ]
];
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-headers.js.map


/***/ }),

/***/ 9222:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getServerActionDispatcher: function() {
        return getServerActionDispatcher;
    },
    urlToUrlWithoutFlightMarker: function() {
        return urlToUrlWithoutFlightMarker;
    },
    default: function() {
        return AppRouter;
    }
});
const _interop_require_wildcard = __webpack_require__(1113);
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(8038));
const _approutercontext = __webpack_require__(3280);
const _routerreducer = __webpack_require__(542);
const _routerreducertypes = __webpack_require__(664);
const _createhreffromurl = __webpack_require__(9897);
const _hooksclientcontext = __webpack_require__(9274);
const _usereducerwithdevtools = __webpack_require__(6958);
const _errorboundary = __webpack_require__(4765);
const _createinitialrouterstate = __webpack_require__(9188);
const _isbot = __webpack_require__(1897);
const _addbasepath = __webpack_require__(3022);
const _approuterannouncer = __webpack_require__(5087);
const _redirectboundary = __webpack_require__(3167);
const _notfoundboundary = __webpack_require__(6753);
const _findheadincache = __webpack_require__(1058);
const _infinitepromise = __webpack_require__(6906);
const isServer = "undefined" === "undefined";
// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.
let initialParallelRoutes = isServer ? null : new Map();
let globalServerActionDispatcher = null;
function getServerActionDispatcher() {
    return globalServerActionDispatcher;
}
function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    // TODO-APP: handle .rsc for static export case
    return urlWithoutFlightParameters;
}
const HotReloader =  true ? null : 0;
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function HistoryUpdater(param) {
    let { tree , pushRef , canonicalUrl , sync  } = param;
    // @ts-ignore TODO-APP: useInsertionEffect is available
    _react.default.useInsertionEffect(()=>{
        // Identifier is shortened intentionally.
        // __NA is used to identify if the history entry can be handled by the app-router.
        // __N is used to identify if the history entry can be handled by the old router.
        const historyState = {
            __NA: true,
            tree
        };
        if (pushRef.pendingPush && (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, "", canonicalUrl);
        } else {
            window.history.replaceState(historyState, "", canonicalUrl);
        }
        sync();
    }, [
        tree,
        pushRef,
        canonicalUrl,
        sync
    ]);
    return null;
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { initialHead , initialTree , initialCanonicalUrl , children , assetPrefix , notFound , notFoundStyles , asNotFound  } = param;
    const initialState = (0, _react.useMemo)(()=>(0, _createinitialrouterstate.createInitialRouterState)({
            children,
            initialCanonicalUrl,
            initialTree,
            initialParallelRoutes,
            isServer,
            location: !isServer ? window.location : null,
            initialHead
        }), [
        children,
        initialCanonicalUrl,
        initialTree,
        initialHead
    ]);
    const [{ tree , cache , prefetchCache , pushRef , focusAndScrollRef , canonicalUrl , nextUrl  }, dispatch, sync] = (0, _usereducerwithdevtools.useReducerWithReduxDevtools)(_routerreducer.reducer, initialState);
    (0, _react.useEffect)(()=>{
        // Ensure initialParallelRoutes is cleaned up from memory once it's used.
        initialParallelRoutes = null;
    }, []);
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams , pathname  } = (0, _react.useMemo)(()=>{
        const url = new URL(canonicalUrl,  true ? "http://n" : 0);
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: url.pathname
        };
    }, [
        canonicalUrl
    ]);
    /**
   * Server response that only patches the cache and tree.
   */ const changeByServerResponse = (0, _react.useCallback)((previousTree, flightData, overrideCanonicalUrl)=>{
        _react.default.startTransition(()=>{
            dispatch({
                type: _routerreducertypes.ACTION_SERVER_PATCH,
                flightData,
                previousTree,
                overrideCanonicalUrl,
                cache: {
                    status: _approutercontext.CacheStates.LAZY_INITIALIZED,
                    data: null,
                    subTreeData: null,
                    parallelRoutes: new Map()
                },
                mutable: {}
            });
        });
    }, [
        dispatch
    ]);
    const navigate = (0, _react.useCallback)((href, navigateType, forceOptimisticNavigation)=>{
        const url = new URL((0, _addbasepath.addBasePath)(href), location.origin);
        return dispatch({
            type: _routerreducertypes.ACTION_NAVIGATE,
            url,
            isExternalUrl: isExternalURL(url),
            locationSearch: location.search,
            forceOptimisticNavigation,
            navigateType,
            cache: {
                status: _approutercontext.CacheStates.LAZY_INITIALIZED,
                data: null,
                subTreeData: null,
                parallelRoutes: new Map()
            },
            mutable: {}
        });
    }, [
        dispatch
    ]);
    const serverActionDispatcher = (0, _react.useCallback)((actionPayload)=>{
        _react.default.startTransition(()=>{
            dispatch({
                ...actionPayload,
                type: _routerreducertypes.ACTION_SERVER_ACTION,
                mutable: {},
                navigate,
                changeByServerResponse
            });
        });
    }, [
        changeByServerResponse,
        dispatch,
        navigate
    ]);
    globalServerActionDispatcher = serverActionDispatcher;
    /**
   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.
   */ const appRouter = (0, _react.useMemo)(()=>{
        const routerInstance = {
            back: ()=>window.history.back(),
            forward: ()=>window.history.forward(),
            prefetch: (href, options)=>{
                // If prefetch has already been triggered, don't trigger it again.
                if ((0, _isbot.isBot)(window.navigator.userAgent)) {
                    return;
                }
                const url = new URL((0, _addbasepath.addBasePath)(href), location.origin);
                // External urls can't be prefetched in the same way.
                if (isExternalURL(url)) {
                    return;
                }
                // @ts-ignore startTransition exists
                _react.default.startTransition(()=>{
                    var _options_kind;
                    dispatch({
                        type: _routerreducertypes.ACTION_PREFETCH,
                        url,
                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL
                    });
                });
            },
            replace: (href, options)=>{
                if (options === void 0) options = {};
                // @ts-ignore startTransition exists
                _react.default.startTransition(()=>{
                    navigate(href, "replace", Boolean(options.forceOptimisticNavigation));
                });
            },
            push: (href, options)=>{
                if (options === void 0) options = {};
                // @ts-ignore startTransition exists
                _react.default.startTransition(()=>{
                    navigate(href, "push", Boolean(options.forceOptimisticNavigation));
                });
            },
            refresh: ()=>{
                // @ts-ignore startTransition exists
                _react.default.startTransition(()=>{
                    dispatch({
                        type: _routerreducertypes.ACTION_REFRESH,
                        cache: {
                            status: _approutercontext.CacheStates.LAZY_INITIALIZED,
                            data: null,
                            subTreeData: null,
                            parallelRoutes: new Map()
                        },
                        mutable: {},
                        origin: window.location.origin
                    });
                });
            },
            // @ts-ignore we don't want to expose this method at all
            fastRefresh: ()=>{
                if (true) {
                    throw new Error("fastRefresh can only be used in development mode. Please use refresh instead.");
                } else {}
            }
        };
        return routerInstance;
    }, [
        dispatch,
        navigate
    ]);
    // Add `window.nd` for debugging purposes.
    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.
    if (false) {}
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    if (pushRef.mpaNavigation) {
        const location1 = window.location;
        if (pushRef.pendingPush) {
            location1.assign(canonicalUrl);
        } else {
            location1.replace(canonicalUrl);
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());
    }
    /**
   * Handle popstate event, this is used to handle back/forward in the browser.
   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.
   * That case can happen when the old router injected the history entry.
   */ const onPopState = (0, _react.useCallback)((param)=>{
        let { state  } = param;
        if (!state) {
            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.
            return;
        }
        // This case happens when the history entry was pushed by the `pages` router.
        if (!state.__NA) {
            window.location.reload();
            return;
        }
        // @ts-ignore useTransition exists
        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously
        // Without startTransition works if the cache is there for this path
        _react.default.startTransition(()=>{
            dispatch({
                type: _routerreducertypes.ACTION_RESTORE,
                url: new URL(window.location.href),
                tree: state.tree
            });
        });
    }, [
        dispatch
    ]);
    // Register popstate event to call onPopstate.
    (0, _react.useEffect)(()=>{
        window.addEventListener("popstate", onPopState);
        return ()=>{
            window.removeEventListener("popstate", onPopState);
        };
    }, [
        onPopState
    ]);
    const head = (0, _react.useMemo)(()=>{
        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    const content = /*#__PURE__*/ _react.default.createElement(_notfoundboundary.NotFoundBoundary, {
        notFound: notFound,
        notFoundStyles: notFoundStyles,
        asNotFound: asNotFound
    }, /*#__PURE__*/ _react.default.createElement(_redirectboundary.RedirectBoundary, null, head, cache.subTreeData, /*#__PURE__*/ _react.default.createElement(_approuterannouncer.AppRouterAnnouncer, {
        tree: tree
    })));
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(HistoryUpdater, {
        tree: tree,
        pushRef: pushRef,
        canonicalUrl: canonicalUrl,
        sync: sync
    }), /*#__PURE__*/ _react.default.createElement(_hooksclientcontext.PathnameContext.Provider, {
        value: pathname
    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontext.SearchParamsContext.Provider, {
        value: searchParams
    }, /*#__PURE__*/ _react.default.createElement(_approutercontext.GlobalLayoutRouterContext.Provider, {
        value: {
            changeByServerResponse,
            tree,
            focusAndScrollRef,
            nextUrl
        }
    }, /*#__PURE__*/ _react.default.createElement(_approutercontext.AppRouterContext.Provider, {
        value: appRouter
    }, /*#__PURE__*/ _react.default.createElement(_approutercontext.LayoutRouterContext.Provider, {
        value: {
            childNodes: cache.parallelRoutes,
            tree: tree,
            // Root node always has `url`
            // Provided in AppTreeContext to ensure it can be overwritten in layout-router
            url: canonicalUrl
        }
    }, HotReloader ? /*#__PURE__*/ _react.default.createElement(HotReloader, {
        assetPrefix: assetPrefix
    }, content) : content))))));
}
function AppRouter(props) {
    const { globalErrorComponent , ...rest } = props;
    return /*#__PURE__*/ _react.default.createElement(_errorboundary.ErrorBoundary, {
        errorComponent: globalErrorComponent
    }, /*#__PURE__*/ _react.default.createElement(Router, rest));
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router.js.map


/***/ }),

/***/ 6650:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "bailoutToClientRendering", ({
    enumerable: true,
    get: function() {
        return bailoutToClientRendering;
    }
}));
const _dynamicnossr = __webpack_require__(2144);
const _staticgenerationasyncstorage = __webpack_require__(1839);
function bailoutToClientRendering() {
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        (0, _dynamicnossr.suspense)();
    }
    return false;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bailout-to-client-rendering.js.map


/***/ }),

/***/ 6378:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "clientHookInServerComponentError", ({
    enumerable: true,
    get: function() {
        return clientHookInServerComponentError;
    }
}));
const _interop_require_default = __webpack_require__(5967);
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8038));
function clientHookInServerComponentError(hookName) {
    if (false) {}
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-hook-in-server-component-error.js.map


/***/ }),

/***/ 4765:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ErrorBoundaryHandler: function() {
        return ErrorBoundaryHandler;
    },
    default: function() {
        return GlobalError;
    },
    ErrorBoundary: function() {
        return ErrorBoundary;
    }
});
const _interop_require_default = __webpack_require__(5967);
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8038));
const _navigation = __webpack_require__(4592);
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    desc: {
        textAlign: "left"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "3em",
        margin: 0
    }
};
class ErrorBoundaryHandler extends _react.default.Component {
    static getDerivedStateFromError(error) {
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, this.props.errorStyles, /*#__PURE__*/ _react.default.createElement(this.props.errorComponent, {
                error: this.state.error,
                reset: this.reset
            }));
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function GlobalError(param) {
    let { error  } = param;
    return /*#__PURE__*/ _react.default.createElement("html", null, /*#__PURE__*/ _react.default.createElement("head", null), /*#__PURE__*/ _react.default.createElement("body", null, /*#__PURE__*/ _react.default.createElement("div", {
        style: styles.error
    }, /*#__PURE__*/ _react.default.createElement("div", {
        style: styles.desc
    }, /*#__PURE__*/ _react.default.createElement("h2", {
        style: styles.text
    }, "Application error: a client-side exception has occurred (see the browser console for more information)."), (error == null ? void 0 : error.digest) && /*#__PURE__*/ _react.default.createElement("p", {
        style: styles.text
    }, "Digest: " + error.digest)))));
}
function ErrorBoundary(param) {
    let { errorComponent , errorStyles , children  } = param;
    const pathname = (0, _navigation.usePathname)();
    if (errorComponent) {
        return /*#__PURE__*/ _react.default.createElement(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles
        }, children);
    }
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=error-boundary.js.map


/***/ }),

/***/ 5404:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_ERROR_CODE: function() {
        return DYNAMIC_ERROR_CODE;
    },
    DynamicServerError: function() {
        return DynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(type){
        super("Dynamic server usage: " + type);
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map


/***/ }),

/***/ 6906:
/***/ ((module, exports) => {

"use strict";
/**
 * Used to cache in createInfinitePromise
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createInfinitePromise", ({
    enumerable: true,
    get: function() {
        return createInfinitePromise;
    }
}));
let infinitePromise;
function createInfinitePromise() {
    if (!infinitePromise) {
        // Only create the Promise once
        infinitePromise = new Promise(()=>{
        // This is used to debug when the rendering is never updated.
        // setTimeout(() => {
        //   infinitePromise = new Error('Infinite promise')
        //   resolve()
        // }, 5000)
        });
    }
    return infinitePromise;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=infinite-promise.js.map


/***/ }),

/***/ 8301:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return OuterLayoutRouter;
    }
}));
const _interop_require_default = __webpack_require__(5967);
const _interop_require_wildcard = __webpack_require__(1113);
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(8038));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8704));
const _approutercontext = __webpack_require__(3280);
const _fetchserverresponse = __webpack_require__(4599);
const _infinitepromise = __webpack_require__(6906);
const _errorboundary = __webpack_require__(4765);
const _matchsegments = __webpack_require__(8226);
const _handlesmoothscroll = __webpack_require__(1668);
const _redirectboundary = __webpack_require__(3167);
const _notfoundboundary = __webpack_require__(6753);
const _getsegmentvalue = __webpack_require__(8672);
const _createroutercachekey = __webpack_require__(8627);
/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                "refetch"
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if (true) return null;
    // Only apply strict mode warning when not in production
    if (false) {}
    return _reactdom.default.findDOMNode(instance);
}
const rectProperties = [
    "bottom",
    "height",
    "left",
    "right",
    "top",
    "width",
    "x",
    "y"
];
/**
 * Check if a HTMLElement is hidden.
 */ function elementCanScroll(element) {
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === "top") {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends _react.default.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef , segmentPath  } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // TODO-APP: Handle the case where we couldn't select any DOM node, even higher up in the layout-router above the current segmentPath.
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if it's visible on screen (e.g. not display: none).
                // If the element is not a HTMLElement or not visible we try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || elementCanScroll(domNode)){
                    // TODO-APP: Handle the case where we couldn't select any DOM node, even higher up in the layout-router above the current segmentPath.
                    // No siblings found that are visible so we handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{
                    // In case of hash scroll we need to scroll to the top of the element
                    if (hashFragment) {
                        window.scrollTo(0, domNode.offsetTop);
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true
                });
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath , children  } = param;
    const context = (0, _react.useContext)(_approutercontext.GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    return /*#__PURE__*/ _react.default.createElement(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef
    }, children);
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,
    cacheKey  } = param;
    const context = (0, _react.useContext)(_approutercontext.GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    const { changeByServerResponse , tree: fullTree  } = context;
    // Read segment path from the parallel router cache node.
    let childNode = childNodes.get(cacheKey);
    // If childProp is available this means it's the Flight / SSR case.
    if (childProp && // TODO-APP: verify if this can be null based on user code
    childProp.current !== null) {
        if (!childNode) {
            // Add the segment's subTreeData to the cache.
            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
            childNodes.set(cacheKey, {
                status: _approutercontext.CacheStates.READY,
                data: null,
                subTreeData: childProp.current,
                parallelRoutes: new Map()
            });
            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.
            childNode = childNodes.get(cacheKey);
        } else {
            if (childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED) {
                // @ts-expect-error we're changing it's type!
                childNode.status = _approutercontext.CacheStates.READY;
                // @ts-expect-error
                childNode.subTreeData = childProp.current;
            }
        }
    }
    // When childNode is not available during rendering client-side we need to fetch it from the server.
    if (!childNode || childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED) {
        /**
     * Router state with refetch marker added
     */ // TODO-APP: remove ''
        const refetchTree = walkAddRefetch([
            "",
            ...segmentPath
        ], fullTree);
        /**
     * Flight data fetch kicked off during render and put into the cache.
     */ childNodes.set(cacheKey, {
            status: _approutercontext.CacheStates.DATA_FETCH,
            data: (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), refetchTree, context.nextUrl),
            subTreeData: null,
            head: childNode && childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,
            parallelRoutes: childNode && childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()
        });
        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.
        childNode = childNodes.get(cacheKey);
    }
    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.
    if (!childNode) {
        throw new Error("Child node should always exist");
    }
    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.
    if (childNode.subTreeData && childNode.data) {
        throw new Error("Child node should not have both subTreeData and data");
    }
    // If cache node has a data request we have to unwrap response by `use` and update the cache.
    if (childNode.data) {
        /**
     * Flight response data
     */ // When the data has not resolved yet `use` will suspend here.
        const [flightData, overrideCanonicalUrl] = (0, _react.use)(childNode.data);
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            window.location.href = url;
            return null;
        }
        // segmentPath from the server does not match the layout's segmentPath
        childNode.data = null;
        // setTimeout is used to start a new transition during render, this is an intentional hack around React.
        setTimeout(()=>{
            // @ts-ignore startTransition exists
            _react.default.startTransition(()=>{
                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);
            });
        });
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());
    }
    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.
    // TODO-APP: double check users can't return null in a component that will kick in here.
    if (!childNode.subTreeData) {
        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());
    }
    const subtree = /*#__PURE__*/ _react.default.createElement(_approutercontext.LayoutRouterContext.Provider, {
        value: {
            tree: tree[1][parallelRouterKey],
            childNodes: childNode.parallelRoutes,
            // TODO-APP: overriding of url for parallel routes
            url: url
        }
    }, childNode.subTreeData);
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { children , loading , loadingStyles , hasLoading  } = param;
    if (hasLoading) {
        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {
            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)
        }, children);
    }
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);
}
function OuterLayoutRouter(param) {
    let { parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles , asNotFound , styles  } = param;
    const context = (0, _react.useContext)(_approutercontext.LayoutRouterContext);
    if (!context) {
        throw new Error("invariant expected layout router to be mounted");
    }
    const { childNodes , tree , url  } = context;
    // Get the current parallelRouter cache node
    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!childNodesForParallelRouter) {
        childNodes.set(parallelRouterKey, new Map());
        childNodesForParallelRouter = childNodes.get(parallelRouterKey);
    }
    // Get the active segment in the tree
    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.
    const treeSegment = tree[1][parallelRouterKey][0];
    const childPropSegment = childProp.segment;
    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.
    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);
    /**
   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.
   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.
    const preservedSegments = [
        treeSegment
    ];
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, styles, preservedSegments.map((preservedSegment)=>{
        const isChildPropSegment = (0, _matchsegments.matchSegment)(preservedSegment, childPropSegment);
        const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);
        return(/*
            - Error boundary
              - Only renders error boundary if error component is provided.
              - Rendered for each segment to ensure they have their own error state.
            - Loading boundary
              - Only renders suspense boundary if loading components is provided.
              - Rendered for each segment to ensure they have their own loading state.
              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
          */ /*#__PURE__*/ _react.default.createElement(_approutercontext.TemplateContext.Provider, {
            key: (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true),
            value: /*#__PURE__*/ _react.default.createElement(ScrollAndFocusHandler, {
                segmentPath: segmentPath
            }, /*#__PURE__*/ _react.default.createElement(_errorboundary.ErrorBoundary, {
                errorComponent: error,
                errorStyles: errorStyles
            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {
                hasLoading: hasLoading,
                loading: loading,
                loadingStyles: loadingStyles
            }, /*#__PURE__*/ _react.default.createElement(_notfoundboundary.NotFoundBoundary, {
                notFound: notFound,
                notFoundStyles: notFoundStyles,
                asNotFound: asNotFound
            }, /*#__PURE__*/ _react.default.createElement(_redirectboundary.RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {
                parallelRouterKey: parallelRouterKey,
                url: url,
                tree: tree,
                childNodes: childNodesForParallelRouter,
                childProp: isChildPropSegment ? childProp : null,
                segmentPath: segmentPath,
                cacheKey: cacheKey,
                isActive: currentChildSegmentValue === preservedSegmentValue
            }))))))
        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));
    }));
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=layout-router.js.map


/***/ }),

/***/ 8226:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    matchSegment: function() {
        return matchSegment;
    },
    canSegmentBeOverridden: function() {
        return canSegmentBeOverridden;
    }
});
const _getsegmentparam = __webpack_require__(1090);
const matchSegment = (existingSegment, segment)=>{
    // Common case: segment is just a string
    if (typeof existingSegment === "string" && typeof segment === "string") {
        return existingSegment === segment;
    }
    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.
    if (Array.isArray(existingSegment) && Array.isArray(segment)) {
        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];
    }
    return false;
};
const canSegmentBeOverridden = (existingSegment, segment)=>{
    var _getSegmentParam;
    if (Array.isArray(existingSegment) || !Array.isArray(segment)) {
        return false;
    }
    return ((_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(existingSegment)) == null ? void 0 : _getSegmentParam.param) === segment[0];
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=match-segments.js.map


/***/ }),

/***/ 4592:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
// useLayoutSegments() // Only the segments for the current place. ['children', 'dashboard', 'children', 'integrations'] -> /dashboard/integrations (/dashboard/layout.js would get ['children', 'dashboard', 'children', 'integrations'])

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return ReadonlyURLSearchParams;
    },
    useSearchParams: function() {
        return useSearchParams;
    },
    usePathname: function() {
        return usePathname;
    },
    ServerInsertedHTMLContext: function() {
        return _serverinsertedhtml.ServerInsertedHTMLContext;
    },
    useServerInsertedHTML: function() {
        return _serverinsertedhtml.useServerInsertedHTML;
    },
    useRouter: function() {
        return useRouter;
    },
    useParams: function() {
        return useParams;
    },
    useSelectedLayoutSegments: function() {
        return useSelectedLayoutSegments;
    },
    useSelectedLayoutSegment: function() {
        return useSelectedLayoutSegment;
    },
    redirect: function() {
        return _redirect.redirect;
    },
    notFound: function() {
        return _notfound.notFound;
    }
});
const _react = __webpack_require__(8038);
const _approutercontext = __webpack_require__(3280);
const _hooksclientcontext = __webpack_require__(9274);
const _clienthookinservercomponenterror = __webpack_require__(6378);
const _getsegmentvalue = __webpack_require__(8672);
const _serverinsertedhtml = __webpack_require__(3349);
const _redirect = __webpack_require__(8305);
const _notfound = __webpack_require__(5771);
const INTERNAL_URLSEARCHPARAMS_INSTANCE = Symbol("internal for urlsearchparams readonly");
function readonlyURLSearchParamsError() {
    return new Error("ReadonlyURLSearchParams cannot be modified");
}
class ReadonlyURLSearchParams {
    [Symbol.iterator]() {
        return this[INTERNAL_URLSEARCHPARAMS_INSTANCE][Symbol.iterator]();
    }
    append() {
        throw readonlyURLSearchParamsError();
    }
    delete() {
        throw readonlyURLSearchParamsError();
    }
    set() {
        throw readonlyURLSearchParamsError();
    }
    sort() {
        throw readonlyURLSearchParamsError();
    }
    constructor(urlSearchParams){
        this[INTERNAL_URLSEARCHPARAMS_INSTANCE] = urlSearchParams;
        this.entries = urlSearchParams.entries.bind(urlSearchParams);
        this.forEach = urlSearchParams.forEach.bind(urlSearchParams);
        this.get = urlSearchParams.get.bind(urlSearchParams);
        this.getAll = urlSearchParams.getAll.bind(urlSearchParams);
        this.has = urlSearchParams.has.bind(urlSearchParams);
        this.keys = urlSearchParams.keys.bind(urlSearchParams);
        this.values = urlSearchParams.values.bind(urlSearchParams);
        this.toString = urlSearchParams.toString.bind(urlSearchParams);
    }
}
function useSearchParams() {
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("useSearchParams");
    const searchParams = (0, _react.useContext)(_hooksclientcontext.SearchParamsContext);
    // In the case where this is `null`, the compat types added in
    // `next-env.d.ts` will add a new overload that changes the return type to
    // include `null`.
    const readonlySearchParams = (0, _react.useMemo)(()=>{
        if (!searchParams) {
            // When the router is not ready in pages, we won't have the search params
            // available.
            return null;
        }
        return new ReadonlyURLSearchParams(searchParams);
    }, [
        searchParams
    ]);
    if (true) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { bailoutToClientRendering  } = __webpack_require__(6650);
        if (bailoutToClientRendering()) {
            // TODO-APP: handle dynamic = 'force-static' here and on the client
            return readonlySearchParams;
        }
    }
    return readonlySearchParams;
}
function usePathname() {
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("usePathname");
    // In the case where this is `null`, the compat types added in `next-env.d.ts`
    // will add a new overload that changes the return type to include `null`.
    return (0, _react.useContext)(_hooksclientcontext.PathnameContext);
}
function useRouter() {
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("useRouter");
    const router = (0, _react.useContext)(_approutercontext.AppRouterContext);
    if (router === null) {
        throw new Error("invariant expected app router to be mounted");
    }
    return router;
}
// this function performs a depth-first search of the tree to find the selected
// params
function getSelectedParams(tree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = tree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith("__PAGE__")) continue;
        if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
function useParams() {
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("useParams");
    const globalLayoutRouterContext = (0, _react.useContext)(_approutercontext.GlobalLayoutRouterContext);
    if (!globalLayoutRouterContext) {
        // This only happens in `pages`. Type is overwritten in navigation.d.ts
        return null;
    }
    return getSelectedParams(globalLayoutRouterContext.tree);
}
// TODO-APP: handle parallel routes
/**
 * Get the canonical parameters from the current level to the leaf node.
 */ function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
    if (first === void 0) first = true;
    if (segmentPath === void 0) segmentPath = [];
    let node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    const segment = node[0];
    const segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
    if (!segmentValue || segmentValue.startsWith("__PAGE__")) return segmentPath;
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
function useSelectedLayoutSegments(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = "children";
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("useSelectedLayoutSegments");
    const { tree  } = (0, _react.useContext)(_approutercontext.LayoutRouterContext);
    return getSelectedLayoutSegmentPath(tree, parallelRouteKey);
}
function useSelectedLayoutSegment(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = "children";
    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)("useSelectedLayoutSegment");
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (selectedLayoutSegments.length === 0) {
        return null;
    }
    return selectedLayoutSegments[0];
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.js.map


/***/ }),

/***/ 6753:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NotFoundBoundary", ({
    enumerable: true,
    get: function() {
        return NotFoundBoundary;
    }
}));
const _interop_require_default = __webpack_require__(5967);
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8038));
const _navigation = __webpack_require__(4592);
class NotFoundErrorBoundary extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((error == null ? void 0 : error.digest) === "NEXT_NOT_FOUND") {
            return {
                notFoundTriggered: true
            };
        }
        // Re-throw if error is not for 404
        throw error;
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.notFoundTriggered) {
            return {
                notFoundTriggered: false,
                previousPathname: props.pathname
            };
        }
        return {
            notFoundTriggered: state.notFoundTriggered,
            previousPathname: props.pathname
        };
    }
    render() {
        if (this.state.notFoundTriggered) {
            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("meta", {
                name: "robots",
                content: "noindex"
            }), this.props.notFoundStyles, this.props.notFound);
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            notFoundTriggered: !!props.asNotFound,
            previousPathname: props.pathname
        };
    }
}
function NotFoundBoundary(param) {
    let { notFound , notFoundStyles , asNotFound , children  } = param;
    const pathname = (0, _navigation.usePathname)();
    return notFound ? /*#__PURE__*/ _react.default.createElement(NotFoundErrorBoundary, {
        pathname: pathname,
        notFound: notFound,
        notFoundStyles: notFoundStyles,
        asNotFound: asNotFound
    }, children) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found-boundary.js.map


/***/ }),

/***/ 5771:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    notFound: function() {
        return notFound;
    },
    isNotFoundError: function() {
        return isNotFoundError;
    }
});
const NOT_FOUND_ERROR_CODE = "NEXT_NOT_FOUND";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = new Error(NOT_FOUND_ERROR_CODE);
    error.digest = NOT_FOUND_ERROR_CODE;
    throw error;
}
function isNotFoundError(error) {
    return (error == null ? void 0 : error.digest) === NOT_FOUND_ERROR_CODE;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map


/***/ }),

/***/ 3167:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RedirectErrorBoundary: function() {
        return RedirectErrorBoundary;
    },
    RedirectBoundary: function() {
        return RedirectBoundary;
    }
});
const _interop_require_wildcard = __webpack_require__(1113);
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(8038));
const _navigation = __webpack_require__(4592);
const _redirect = __webpack_require__(8305);
function HandleRedirect(param) {
    let { redirect , reset , redirectType  } = param;
    const router = (0, _navigation.useRouter)();
    (0, _react.useEffect)(()=>{
        // @ts-ignore startTransition exists
        _react.default.startTransition(()=>{
            if (redirectType === _redirect.RedirectType.push) {
                router.push(redirect, {});
            } else {
                router.replace(redirect, {});
            }
            reset();
        });
    }, [
        redirect,
        redirectType,
        reset,
        router
    ]);
    return null;
}
class RedirectErrorBoundary extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((0, _redirect.isRedirectError)(error)) {
            const url = (0, _redirect.getURLFromRedirectError)(error);
            const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
            return {
                redirect: url,
                redirectType
            };
        }
        // Re-throw if error is not for redirect
        throw error;
    }
    render() {
        const { redirect , redirectType  } = this.state;
        if (redirect !== null && redirectType !== null) {
            return /*#__PURE__*/ _react.default.createElement(HandleRedirect, {
                redirect: redirect,
                redirectType: redirectType,
                reset: ()=>this.setState({
                        redirect: null
                    })
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            redirect: null,
            redirectType: null
        };
    }
}
function RedirectBoundary(param) {
    let { children  } = param;
    const router = (0, _navigation.useRouter)();
    return /*#__PURE__*/ _react.default.createElement(RedirectErrorBoundary, {
        router: router
    }, children);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-boundary.js.map


/***/ }),

/***/ 8305:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RedirectType: function() {
        return RedirectType;
    },
    getRedirectError: function() {
        return getRedirectError;
    },
    redirect: function() {
        return redirect;
    },
    isRedirectError: function() {
        return isRedirectError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    },
    getRedirectTypeFromError: function() {
        return getRedirectTypeFromError;
    }
});
const _requestasyncstorage = __webpack_require__(8214);
const REDIRECT_ERROR_CODE = "NEXT_REDIRECT";
var RedirectType;
(function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
})(RedirectType || (RedirectType = {}));
function getRedirectError(url, type) {
    const error = new Error(REDIRECT_ERROR_CODE);
    error.digest = REDIRECT_ERROR_CODE + ";" + type + ";" + url;
    const requestStore = _requestasyncstorage.requestAsyncStorage.getStore();
    if (requestStore) {
        error.mutableCookies = requestStore.mutableCookies;
    }
    return error;
}
function redirect(url, type) {
    if (type === void 0) type = "replace";
    throw getRedirectError(url, type);
}
function isRedirectError(error) {
    if (typeof (error == null ? void 0 : error.digest) !== "string") return false;
    const [errorCode, type, destination] = error.digest.split(";", 3);
    return errorCode === REDIRECT_ERROR_CODE && (type === "replace" || type === "push") && typeof destination === "string";
}
function getURLFromRedirectError(error) {
    if (!isRedirectError(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.split(";", 3)[2];
}
function getRedirectTypeFromError(error) {
    if (!isRedirectError(error)) {
        throw new Error("Not a redirect error");
    }
    return error.digest.split(";", 3)[1];
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map


/***/ }),

/***/ 3751:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return RenderFromTemplateContext;
    }
}));
const _interop_require_wildcard = __webpack_require__(1113);
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(8038));
const _approutercontext = __webpack_require__(3280);
function RenderFromTemplateContext() {
    const children = (0, _react.useContext)(_approutercontext.TemplateContext);
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=render-from-template-context.js.map


/***/ }),

/***/ 4403:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "applyFlightData", ({
    enumerable: true,
    get: function() {
        return applyFlightData;
    }
}));
const _approutercontext = __webpack_require__(3280);
const _filllazyitemstillleafwithhead = __webpack_require__(2494);
const _fillcachewithnewsubtreedata = __webpack_require__(5940);
function applyFlightData(existingCache, cache, flightDataPath, wasPrefetched) {
    if (wasPrefetched === void 0) wasPrefetched = false;
    // The one before last item is the router state tree patch
    const [treePatch, subTreeData, head] = flightDataPath.slice(-3);
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (subTreeData === null) {
        return false;
    }
    if (flightDataPath.length === 3) {
        cache.status = _approutercontext.CacheStates.READY;
        cache.subTreeData = subTreeData;
        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, existingCache, treePatch, head, wasPrefetched);
    } else {
        // Copy subTreeData for the root node of the cache.
        cache.status = _approutercontext.CacheStates.READY;
        cache.subTreeData = existingCache.subTreeData;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        // Create a copy of the existing cache with the subTreeData applied.
        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(cache, existingCache, flightDataPath, wasPrefetched);
    }
    return true;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-flight-data.js.map


/***/ }),

/***/ 8018:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "applyRouterStatePatchToTree", ({
    enumerable: true,
    get: function() {
        return applyRouterStatePatchToTree;
    }
}));
const _matchsegments = __webpack_require__(8226);
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then we can ignore it and return the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === "__DEFAULT__" && initialSegment !== "__DEFAULT__") {
        return initialTree;
    }
    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {
    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        }
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    return tree;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map


/***/ }),

/***/ 947:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    extractPathFromFlightRouterState: function() {
        return extractPathFromFlightRouterState;
    },
    computeChangedPath: function() {
        return computeChangedPath;
    }
});
const _interceptionroutes = __webpack_require__(8652);
const _matchsegments = __webpack_require__(8226);
const segmentToPathname = (segment)=>{
    if (typeof segment === "string") {
        return segment;
    }
    return segment[1];
};
function normalizePathname(pathname) {
    return pathname.split("/").reduce((acc, segment)=>{
        if (segment === "" || segment.startsWith("(") && segment.endsWith(")")) {
            return acc;
        }
        return acc + "/" + segment;
    }, "") || "/";
}
function extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === "__DEFAULT__" || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith("__PAGE__")) return "";
    const path = [
        segment
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        path.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === "children") continue;
            const childPath = extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                path.push(childPath);
            }
        }
    }
    // TODO-APP: optimise this, it's not ideal to join and split
    return normalizePathname(path.join("/"));
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return "";
    }
    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : "";
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === "/") {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizePathname(changedPath);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=compute-changed-path.js.map


/***/ }),

/***/ 9897:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createHrefFromUrl", ({
    enumerable: true,
    get: function() {
        return createHrefFromUrl;
    }
}));
function createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : "");
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-href-from-url.js.map


/***/ }),

/***/ 9188:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createInitialRouterState", ({
    enumerable: true,
    get: function() {
        return createInitialRouterState;
    }
}));
const _approutercontext = __webpack_require__(3280);
const _createhreffromurl = __webpack_require__(9897);
const _filllazyitemstillleafwithhead = __webpack_require__(2494);
const _computechangedpath = __webpack_require__(947);
function createInitialRouterState(param) {
    let { initialTree , children , initialCanonicalUrl , initialParallelRoutes , isServer , location , initialHead  } = param;
    const cache = {
        status: _approutercontext.CacheStates.READY,
        data: null,
        subTreeData: children,
        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.
        parallelRoutes: isServer ? new Map() : initialParallelRoutes
    };
    // When the cache hasn't been seeded yet we fill the cache with the head.
    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {
        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, initialTree, initialHead);
    }
    var _ref;
    return {
        tree: initialTree,
        cache,
        prefetchCache: new Map(),
        pushRef: {
            pendingPush: false,
            mpaNavigation: false
        },
        focusAndScrollRef: {
            apply: false,
            hashFragment: null,
            segmentPaths: []
        },
        canonicalUrl: // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.
        location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl,
        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null
    };
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-initial-router-state.js.map


/***/ }),

/***/ 7120:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createOptimisticTree", ({
    enumerable: true,
    get: function() {
        return createOptimisticTree;
    }
}));
const _matchsegments = __webpack_require__(8226);
function createOptimisticTree(segments, flightRouterState, parentRefetch) {
    const [existingSegment, existingParallelRoutes, url, refresh, isRootLayout] = flightRouterState || [
        null,
        {}
    ];
    const segment = segments[0];
    const isLastSegment = segments.length === 1;
    const segmentMatches = existingSegment !== null && (0, _matchsegments.matchSegment)(existingSegment, segment);
    // if there are multiple parallel routes at this level, we need to refetch here
    // to ensure we get the correct tree. This is because we don't know which
    // parallel route will match the next segment.
    const hasMultipleParallelRoutes = Object.keys(existingParallelRoutes).length > 1;
    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches || hasMultipleParallelRoutes;
    let parallelRoutes = {};
    if (existingSegment !== null && segmentMatches) {
        parallelRoutes = existingParallelRoutes;
    }
    let childTree;
    // if there's multiple parallel routes at this level, we shouldn't create an
    // optimistic tree for the next level because we don't know which one will
    // match the next segment.
    if (!isLastSegment && !hasMultipleParallelRoutes) {
        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, parentRefetch || shouldRefetchThisLevel);
        childTree = childItem;
    }
    const result = [
        segment,
        {
            ...parallelRoutes,
            ...childTree ? {
                children: childTree
            } : {}
        }
    ];
    if (url) {
        result[2] = url;
    }
    if (!parentRefetch && shouldRefetchThisLevel) {
        result[3] = "refetch";
    } else if (segmentMatches && refresh) {
        result[3] = refresh;
    }
    if (segmentMatches && isRootLayout) {
        result[4] = isRootLayout;
    }
    return result;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-optimistic-tree.js.map


/***/ }),

/***/ 9669:
/***/ ((module, exports) => {

"use strict";
/**
 * Create data fetching record for Promise.
 */ // TODO-APP: change `any` to type inference.

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createRecordFromThenable", ({
    enumerable: true,
    get: function() {
        return createRecordFromThenable;
    }
}));
function createRecordFromThenable(thenable) {
    thenable.status = "pending";
    thenable.then((value)=>{
        if (thenable.status === "pending") {
            thenable.status = "fulfilled";
            thenable.value = value;
        }
    }, (err)=>{
        if (thenable.status === "pending") {
            thenable.status = "rejected";
            thenable.value = err;
        }
    });
    return thenable;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-record-from-thenable.js.map


/***/ }),

/***/ 8627:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createRouterCacheKey", ({
    enumerable: true,
    get: function() {
        return createRouterCacheKey;
    }
}));
function createRouterCacheKey(segment, withoutSearchParameters) {
    if (withoutSearchParameters === void 0) withoutSearchParameters = false;
    return Array.isArray(segment) ? segment[0] + "|" + segment[1] + "|" + segment[2] : withoutSearchParameters && segment.startsWith("__PAGE__") ? "__PAGE__" : segment;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-router-cache-key.js.map


/***/ }),

/***/ 4599:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "fetchServerResponse", ({
    enumerable: true,
    get: function() {
        return fetchServerResponse;
    }
}));
const _client = __webpack_require__(7897);
const _approuterheaders = __webpack_require__(2982);
const _approuter = __webpack_require__(9222);
const _appcallserver = __webpack_require__(6942);
const _routerreducertypes = __webpack_require__(664);
async function fetchServerResponse(url, flightRouterState, nextUrl, prefetchKind) {
    const headers = {
        // Enable flight response
        [_approuterheaders.RSC]: "1",
        // Provide the current router state
        [_approuterheaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(flightRouterState)
    };
    /**
   * Three cases:
   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully
   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above
   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully
   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {
        headers[_approuterheaders.NEXT_ROUTER_PREFETCH] = "1";
    }
    if (nextUrl) {
        headers[_approuterheaders.NEXT_URL] = nextUrl;
    }
    try {
        let fetchUrl = url;
        if (true) {
            if (false) {}
        }
        const res = await fetch(fetchUrl, {
            // Backwards compat for older browsers. `same-origin` is the default in modern browsers.
            credentials: "same-origin",
            headers
        });
        const canonicalUrl = res.redirected ? (0, _approuter.urlToUrlWithoutFlightMarker)(res.url) : undefined;
        const contentType = res.headers.get("content-type") || "";
        let isFlightResponse = contentType === _approuterheaders.RSC_CONTENT_TYPE_HEADER;
        if (true) {
            if (false) {}
        }
        // If fetch returns something different than flight response handle it like a mpa navigation
        if (!isFlightResponse) {
            return [
                res.url,
                undefined
            ];
        }
        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.
        const flightData = await (0, _client.createFromFetch)(Promise.resolve(res), {
            callServer: _appcallserver.callServer
        });
        return [
            flightData,
            canonicalUrl
        ];
    } catch (err) {
        console.error("Failed to fetch RSC payload. Falling back to browser navigation.", err);
        // If fetch fails handle it like a mpa navigation
        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.
        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.
        return [
            url.toString(),
            undefined
        ];
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fetch-server-response.js.map


/***/ }),

/***/ 3514:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "fillCacheWithDataProperty", ({
    enumerable: true,
    get: function() {
        return fillCacheWithDataProperty;
    }
}));
const _approutercontext = __webpack_require__(3280);
const _createroutercachekey = __webpack_require__(8627);
function fillCacheWithDataProperty(newCache, existingCache, flightSegmentPath, fetchResponse, bailOnParallelRoutes) {
    if (bailOnParallelRoutes === void 0) bailOnParallelRoutes = false;
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap || bailOnParallelRoutes && existingCache.parallelRoutes.size > 1) {
        // Bailout because the existing cache does not have the path to the leaf node
        // or the existing cache has multiple parallel routes
        // Will trigger lazy fetch in layout-router because of missing segment
        return {
            bailOptimistic: true
        };
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    // In case of last segment start off the fetch at this level and don't copy further down.
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {
            childSegmentMap.set(cacheKey, {
                status: _approutercontext.CacheStates.DATA_FETCH,
                data: fetchResponse(),
                subTreeData: null,
                parallelRoutes: new Map()
            });
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Start fetch in the place where the existing cache doesn't have the data yet.
        if (!childCacheNode) {
            childSegmentMap.set(cacheKey, {
                status: _approutercontext.CacheStates.DATA_FETCH,
                data: fetchResponse(),
                subTreeData: null,
                parallelRoutes: new Map()
            });
        }
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            status: childCacheNode.status,
            data: childCacheNode.data,
            subTreeData: childCacheNode.subTreeData,
            parallelRoutes: new Map(childCacheNode.parallelRoutes)
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2), fetchResponse);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-cache-with-data-property.js.map


/***/ }),

/***/ 5940:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "fillCacheWithNewSubTreeData", ({
    enumerable: true,
    get: function() {
        return fillCacheWithNewSubTreeData;
    }
}));
const _approutercontext = __webpack_require__(3280);
const _invalidatecachebyrouterstate = __webpack_require__(1408);
const _filllazyitemstillleafwithhead = __webpack_require__(2494);
const _createroutercachekey = __webpack_require__(8627);
function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, wasPrefetched) {
    const isLastEntry = flightDataPath.length <= 5;
    const [parallelRouteKey, segment] = flightDataPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {
            childCacheNode = {
                status: _approutercontext.CacheStates.READY,
                data: null,
                subTreeData: flightDataPath[3],
                // Ensure segments other than the one we got data for are preserved.
                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()
            };
            if (existingChildCacheNode) {
                (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, flightDataPath[2]);
            }
            (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4], wasPrefetched);
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            status: childCacheNode.status,
            data: childCacheNode.data,
            subTreeData: childCacheNode.subTreeData,
            parallelRoutes: new Map(childCacheNode.parallelRoutes)
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), wasPrefetched);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map


/***/ }),

/***/ 2494:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "fillLazyItemsTillLeafWithHead", ({
    enumerable: true,
    get: function() {
        return fillLazyItemsTillLeafWithHead;
    }
}));
const _approutercontext = __webpack_require__(3280);
const _createroutercachekey = __webpack_require__(8627);
function fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head, wasPrefetched) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                const newCacheNode = wasPrefetched && existingCacheNode ? {
                    status: existingCacheNode.status,
                    data: existingCacheNode.data,
                    subTreeData: existingCacheNode.subTreeData,
                    parallelRoutes: new Map(existingCacheNode.parallelRoutes)
                } : {
                    status: _approutercontext.CacheStates.LAZY_INITIALIZED,
                    data: null,
                    subTreeData: null,
                    parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes)
                };
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, head, wasPrefetched);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        const newCacheNode = {
            status: _approutercontext.CacheStates.LAZY_INITIALIZED,
            data: null,
            subTreeData: null,
            parallelRoutes: new Map()
        };
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head, wasPrefetched);
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map


/***/ }),

/***/ 1447:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PrefetchCacheEntryStatus: function() {
        return PrefetchCacheEntryStatus;
    },
    getPrefetchEntryCacheStatus: function() {
        return getPrefetchEntryCacheStatus;
    }
});
const FIVE_MINUTES = 5 * 60 * 1000;
const THIRTY_SECONDS = 30 * 1000;
var PrefetchCacheEntryStatus;
(function(PrefetchCacheEntryStatus) {
    PrefetchCacheEntryStatus["fresh"] = "fresh";
    PrefetchCacheEntryStatus["reusable"] = "reusable";
    PrefetchCacheEntryStatus["expired"] = "expired";
    PrefetchCacheEntryStatus["stale"] = "stale";
})(PrefetchCacheEntryStatus || (PrefetchCacheEntryStatus = {}));
function getPrefetchEntryCacheStatus(param) {
    let { kind , prefetchTime , lastUsedTime  } = param;
    // if the cache entry was prefetched or read less than 30s ago, then we want to re-use it
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + THIRTY_SECONDS) {
        return lastUsedTime ? "reusable" : "fresh";
    }
    // if the cache entry was prefetched less than 5 mins ago, then we want to re-use only the loading state
    if (kind === "auto") {
        if (Date.now() < prefetchTime + FIVE_MINUTES) {
            return "stale";
        }
    }
    // if the cache entry was prefetched less than 5 mins ago and was a "full" prefetch, then we want to re-use it "full
    if (kind === "full") {
        if (Date.now() < prefetchTime + FIVE_MINUTES) {
            return "reusable";
        }
    }
    return "expired";
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-prefetch-cache-entry-status.js.map


/***/ }),

/***/ 8207:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "handleMutable", ({
    enumerable: true,
    get: function() {
        return handleMutable;
    }
}));
const _computechangedpath = __webpack_require__(947);
function handleMutable(state, mutable) {
    var _mutable_scrollableSegments, _computeChangedPath;
    return {
        // Set href.
        canonicalUrl: typeof mutable.canonicalUrl !== "undefined" ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,
        pushRef: {
            pendingPush: typeof mutable.pendingPush !== "undefined" ? mutable.pendingPush : state.pushRef.pendingPush,
            mpaNavigation: typeof mutable.mpaNavigation !== "undefined" ? mutable.mpaNavigation : state.pushRef.mpaNavigation
        },
        // All navigation requires scroll and focus management to trigger.
        focusAndScrollRef: {
            apply: (mutable == null ? void 0 : mutable.scrollableSegments) !== undefined ? true : state.focusAndScrollRef.apply,
            hashFragment: // #top is handled in layout-router.
            mutable.hashFragment && mutable.hashFragment !== "" ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment,
            segmentPaths: (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths
        },
        // Apply cache.
        cache: mutable.cache ? mutable.cache : state.cache,
        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,
        // Apply patched router state.
        tree: typeof mutable.patchedTree !== "undefined" ? mutable.patchedTree : state.tree,
        nextUrl: typeof mutable.patchedTree !== "undefined" ? (_computeChangedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree)) != null ? _computeChangedPath : state.canonicalUrl : state.nextUrl
    };
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-mutable.js.map


/***/ }),

/***/ 9337:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "invalidateCacheBelowFlightSegmentPath", ({
    enumerable: true,
    get: function() {
        return invalidateCacheBelowFlightSegmentPath;
    }
}));
const _createroutercachekey = __webpack_require__(8627);
function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    // In case of last entry don't copy further down.
    if (isLastEntry) {
        childSegmentMap.delete(cacheKey);
        return;
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            status: childCacheNode.status,
            data: childCacheNode.data,
            subTreeData: childCacheNode.subTreeData,
            parallelRoutes: new Map(childCacheNode.parallelRoutes)
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map


/***/ }),

/***/ 1408:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "invalidateCacheByRouterState", ({
    enumerable: true,
    get: function() {
        return invalidateCacheByRouterState;
    }
}));
const _createroutercachekey = __webpack_require__(8627);
function invalidateCacheByRouterState(newCache, existingCache, routerState) {
    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.
    for(const key in routerState[1]){
        const segmentForParallelRoute = routerState[1][key][0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
        if (existingParallelRoutesCacheNode) {
            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
            parallelRouteCacheNode.delete(cacheKey);
            newCache.parallelRoutes.set(key, parallelRouteCacheNode);
        }
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-by-router-state.js.map


/***/ }),

/***/ 5991:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isNavigatingToNewRootLayout", ({
    enumerable: true,
    get: function() {
        return isNavigatingToNewRootLayout;
    }
}));
function isNavigatingToNewRootLayout(currentTree, nextTree) {
    // Compare segments
    const currentTreeSegment = currentTree[0];
    const nextTreeSegment = nextTree[0];
    // If any segment is different before we find the root layout, the root layout has changed.
    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js
    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.
    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {
        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout
        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js
        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {
            return true;
        }
    } else if (currentTreeSegment !== nextTreeSegment) {
        return true;
    }
    // Current tree root layout found
    if (currentTree[4]) {
        // If the next tree doesn't have the root layout flag, it must have changed.
        return !nextTree[4];
    }
    // Current tree  didn't have its root layout here, must have changed.
    if (nextTree[4]) {
        return true;
    }
    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`
    // But it's not possible to be more than one parallelRoutes before the root layout is found
    // TODO-APP: change to traverse all parallel routes
    const currentTreeChild = Object.values(currentTree[1])[0];
    const nextTreeChild = Object.values(nextTree[1])[0];
    if (!currentTreeChild || !nextTreeChild) return true;
    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map


/***/ }),

/***/ 108:
/***/ ((module, exports) => {

"use strict";
/**
 * Read record value or throw Promise if it's not resolved yet.
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "readRecordValue", ({
    enumerable: true,
    get: function() {
        return readRecordValue;
    }
}));
function readRecordValue(thenable) {
    // @ts-expect-error TODO: fix type
    if (thenable.status === "fulfilled") {
        // @ts-expect-error TODO: fix type
        return thenable.value;
    } else {
        throw thenable;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=read-record-value.js.map


/***/ }),

/***/ 4614:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "fastRefreshReducer", ({
    enumerable: true,
    get: function() {
        return fastRefreshReducer;
    }
}));
const _fetchserverresponse = __webpack_require__(4599);
const _createrecordfromthenable = __webpack_require__(9669);
const _readrecordvalue = __webpack_require__(108);
const _createhreffromurl = __webpack_require__(9897);
const _applyrouterstatepatchtotree = __webpack_require__(8018);
const _isnavigatingtonewrootlayout = __webpack_require__(5991);
const _navigatereducer = __webpack_require__(7252);
const _handlemutable = __webpack_require__(8207);
const _applyflightdata = __webpack_require__(4403);
// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function fastRefreshReducerImpl(state, action) {
    const { cache , mutable , origin  } = action;
    const href = state.canonicalUrl;
    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);
    if (isForCurrentTree) {
        return (0, _handlemutable.handleMutable)(state, mutable);
    }
    if (!cache.data) {
        // TODO-APP: verify that `href` is not an external url.
        // Fetch data from the root of the tree.
        cache.data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [
            state.tree[0],
            state.tree[1],
            state.tree[2],
            "refetch"
        ], state.nextUrl));
    }
    const [flightData, canonicalUrlOverride] = (0, _readrecordvalue.readRecordValue)(cache.data);
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
    }
    // Remove cache.data as it has been resolved at this point.
    cache.data = null;
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const flightDataPath of flightData){
        // FlightDataPath with more than two items means unexpected Flight data was returned
        if (flightDataPath.length !== 3) {
            // TODO-APP: handle this case better
            console.log("REFRESH FAILED");
            return state;
        }
        // Given the path can only have two items the items are only the router state and subTreeData for the root.
        const [treePatch] = flightDataPath;
        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            ""
        ], currentTree, treePatch);
        if (newTree === null) {
            throw new Error("SEGMENT MISMATCH");
        }
        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
        if (canonicalUrlOverride) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);
        if (applied) {
            mutable.cache = cache;
            currentCache = cache;
        }
        mutable.previousTree = currentTree;
        mutable.patchedTree = newTree;
        mutable.canonicalUrl = href;
        currentTree = newTree;
    }
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function fastRefreshReducerNoop(state, _action) {
    return state;
}
const fastRefreshReducer =  true ? fastRefreshReducerNoop : 0;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fast-refresh-reducer.js.map


/***/ }),

/***/ 1058:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "findHeadInCache", ({
    enumerable: true,
    get: function() {
        return findHeadInCache;
    }
}));
const _createroutercachekey = __webpack_require__(8627);
function findHeadInCache(cache, parallelRoutes) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        return cache.head;
    }
    for(const key in parallelRoutes){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCache(cacheNode, childParallelRoutes);
        if (item) {
            return item;
        }
    }
    return undefined;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=find-head-in-cache.js.map


/***/ }),

/***/ 8672:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getSegmentValue", ({
    enumerable: true,
    get: function() {
        return getSegmentValue;
    }
}));
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-segment-value.js.map


/***/ }),

/***/ 7252:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleExternalUrl: function() {
        return handleExternalUrl;
    },
    navigateReducer: function() {
        return navigateReducer;
    }
});
const _approutercontext = __webpack_require__(3280);
const _fetchserverresponse = __webpack_require__(4599);
const _createrecordfromthenable = __webpack_require__(9669);
const _readrecordvalue = __webpack_require__(108);
const _createhreffromurl = __webpack_require__(9897);
const _invalidatecachebelowflightsegmentpath = __webpack_require__(9337);
const _fillcachewithdataproperty = __webpack_require__(3514);
const _createoptimistictree = __webpack_require__(7120);
const _applyrouterstatepatchtotree = __webpack_require__(8018);
const _shouldhardnavigate = __webpack_require__(190);
const _isnavigatingtonewrootlayout = __webpack_require__(5991);
const _routerreducertypes = __webpack_require__(664);
const _handlemutable = __webpack_require__(8207);
const _applyflightdata = __webpack_require__(4403);
const _getprefetchcacheentrystatus = __webpack_require__(1447);
const _pruneprefetchcache = __webpack_require__(6014);
function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.previousTree = state.tree;
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === "") {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function addRefetchToLeafSegments(newCache, currentCache, flightSegmentPath, treePatch, data) {
    let appliedPatch = false;
    newCache.status = _approutercontext.CacheStates.READY;
    newCache.subTreeData = currentCache.subTreeData;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        const res = (0, _fillcachewithdataproperty.fillCacheWithDataProperty)(newCache, currentCache, segmentPaths, data);
        if (!(res == null ? void 0 : res.bailOptimistic)) {
            appliedPatch = true;
        }
    }
    return appliedPatch;
}
function navigateReducer(state, action) {
    const { url , isExternalUrl , navigateType , cache , mutable , forceOptimisticNavigation  } = action;
    const { pathname , hash  } = url;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    (0, _pruneprefetchcache.prunePrefetchCache)(state.prefetchCache);
    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);
    if (isForCurrentTree) {
        return (0, _handlemutable.handleMutable)(state, mutable);
    }
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    let prefetchValues = state.prefetchCache.get((0, _createhreffromurl.createHrefFromUrl)(url, false));
    if (forceOptimisticNavigation && (prefetchValues == null ? void 0 : prefetchValues.kind) !== _routerreducertypes.PrefetchKind.TEMPORARY) {
        const segments = pathname.split("/");
        // TODO-APP: figure out something better for index pages
        segments.push("__PAGE__");
        // Optimistic tree case.
        // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch
        const optimisticTree = (0, _createoptimistictree.createOptimisticTree)(segments, state.tree, false);
        // we need a copy of the cache in case we need to revert to it
        const temporaryCacheNode = {
            ...cache
        };
        // Copy subTreeData for the root node of the cache.
        // Note: didn't do it above because typescript doesn't like it.
        temporaryCacheNode.status = _approutercontext.CacheStates.READY;
        temporaryCacheNode.subTreeData = state.cache.subTreeData;
        temporaryCacheNode.parallelRoutes = new Map(state.cache.parallelRoutes);
        const data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(url, optimisticTree, state.nextUrl));
        // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.
        // TODO-APP: re-evaluate if we need to strip the last segment
        const optimisticFlightSegmentPath = segments.slice(1).map((segment)=>[
                "children",
                segment
            ]).flat();
        // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.
        // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.
        const res = (0, _fillcachewithdataproperty.fillCacheWithDataProperty)(temporaryCacheNode, state.cache, optimisticFlightSegmentPath, ()=>data, true);
        // If optimistic fetch couldn't happen it falls back to the non-optimistic case.
        if (!(res == null ? void 0 : res.bailOptimistic)) {
            mutable.previousTree = state.tree;
            mutable.patchedTree = optimisticTree;
            mutable.pendingPush = pendingPush;
            mutable.hashFragment = hash;
            mutable.scrollableSegments = [];
            mutable.cache = temporaryCacheNode;
            mutable.canonicalUrl = href;
            state.prefetchCache.set((0, _createhreffromurl.createHrefFromUrl)(url, false), {
                data: Promise.resolve(data),
                // this will make sure that the entry will be discarded after 30s
                kind: _routerreducertypes.PrefetchKind.TEMPORARY,
                prefetchTime: Date.now(),
                treeAtTimeOfPrefetch: state.tree,
                lastUsedTime: Date.now()
            });
            return (0, _handlemutable.handleMutable)(state, mutable);
        }
    }
    // If we don't have a prefetch value, we need to create one
    if (!prefetchValues) {
        const data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(url, state.tree, state.nextUrl));
        const newPrefetchValue = {
            data: Promise.resolve(data),
            // this will make sure that the entry will be discarded after 30s
            kind: _routerreducertypes.PrefetchKind.TEMPORARY,
            prefetchTime: Date.now(),
            treeAtTimeOfPrefetch: state.tree,
            lastUsedTime: null
        };
        state.prefetchCache.set((0, _createhreffromurl.createHrefFromUrl)(url, false), newPrefetchValue);
        prefetchValues = newPrefetchValue;
    }
    const prefetchEntryCacheStatus = (0, _getprefetchcacheentrystatus.getPrefetchEntryCacheStatus)(prefetchValues);
    // The one before last item is the router state tree patch
    const { treeAtTimeOfPrefetch , data  } = prefetchValues;
    // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.
    const [flightData, canonicalUrlOverride] = (0, _readrecordvalue.readRecordValue)(data);
    // important: we should only mark the cache node as dirty after we unsuspend from the call above
    prefetchValues.lastUsedTime = Date.now();
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return handleExternalUrl(state, mutable, flightData, pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    let scrollableSegments = [];
    for (const flightDataPath of flightData){
        const flightSegmentPath = flightDataPath.slice(0, -4);
        // The one before last item is the router state tree patch
        const [treePatch] = flightDataPath.slice(-3);
        // Create new tree based on the flightSegmentPath and router state patch
        let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            "",
            ...flightSegmentPath
        ], currentTree, treePatch);
        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
        if (newTree === null) {
            newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                "",
                ...flightSegmentPath
            ], treeAtTimeOfPrefetch, treePatch);
        }
        if (newTree !== null) {
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, pendingPush);
            }
            let applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath, prefetchValues.kind === "auto" && prefetchEntryCacheStatus === _getprefetchcacheentrystatus.PrefetchCacheEntryStatus.reusable);
            if (!applied && prefetchEntryCacheStatus === _getprefetchcacheentrystatus.PrefetchCacheEntryStatus.stale) {
                applied = addRefetchToLeafSegments(cache, currentCache, flightSegmentPath, treePatch, ()=>(0, _fetchserverresponse.fetchServerResponse)(url, currentTree, state.nextUrl));
            }
            const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)([
                "",
                ...flightSegmentPath
            ], currentTree);
            if (hardNavigate) {
                cache.status = _approutercontext.CacheStates.READY;
                // Copy subTreeData for the root node of the cache.
                cache.subTreeData = currentCache.subTreeData;
                (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);
                // Ensure the existing cache value is used when the cache was not invalidated.
                mutable.cache = cache;
            } else if (applied) {
                mutable.cache = cache;
            }
            currentCache = cache;
            currentTree = newTree;
            for (const subSegment of generateSegmentsFromPatch(treePatch)){
                const scrollableSegmentPath = [
                    ...flightSegmentPath,
                    ...subSegment
                ];
                // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== "__DEFAULT__") {
                    scrollableSegments.push(scrollableSegmentPath);
                }
            }
        }
    }
    mutable.previousTree = state.tree;
    mutable.patchedTree = currentTree;
    mutable.scrollableSegments = scrollableSegments;
    mutable.canonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;
    mutable.pendingPush = pendingPush;
    mutable.hashFragment = hash;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigate-reducer.js.map


/***/ }),

/***/ 5274:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "prefetchReducer", ({
    enumerable: true,
    get: function() {
        return prefetchReducer;
    }
}));
const _createhreffromurl = __webpack_require__(9897);
const _fetchserverresponse = __webpack_require__(4599);
const _routerreducertypes = __webpack_require__(664);
const _createrecordfromthenable = __webpack_require__(9669);
const _pruneprefetchcache = __webpack_require__(6014);
function prefetchReducer(state, action) {
    // let's prune the prefetch cache before we do anything else
    (0, _pruneprefetchcache.prunePrefetchCache)(state.prefetchCache);
    const { url  } = action;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url, false);
    const cacheEntry = state.prefetchCache.get(href);
    if (cacheEntry) {
        /**
     * If the cache entry present was marked as temporary, it means that we prefetched it from the navigate reducer,
     * where we didn't have the prefetch intent. We want to update it to the new, more accurate, kind here.
     */ if (cacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {
            state.prefetchCache.set(href, {
                ...cacheEntry,
                kind: action.kind
            });
        }
        /**
     * if the prefetch action was a full prefetch and that the current cache entry wasn't one, we want to re-prefetch,
     * otherwise we can re-use the current cache entry
     **/ if (!(cacheEntry.kind === _routerreducertypes.PrefetchKind.AUTO && action.kind === _routerreducertypes.PrefetchKind.FULL)) {
            return state;
        }
    }
    // fetchServerResponse is intentionally not awaited so that it can be unwrapped in the navigate-reducer
    const serverResponse = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(url, state.tree, state.nextUrl, action.kind));
    // Create new tree based on the flightSegmentPath and router state patch
    state.prefetchCache.set(href, {
        // Create new tree based on the flightSegmentPath and router state patch
        treeAtTimeOfPrefetch: state.tree,
        data: serverResponse,
        kind: action.kind,
        prefetchTime: Date.now(),
        lastUsedTime: null
    });
    return state;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prefetch-reducer.js.map


/***/ }),

/***/ 6014:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "prunePrefetchCache", ({
    enumerable: true,
    get: function() {
        return prunePrefetchCache;
    }
}));
const _getprefetchcacheentrystatus = __webpack_require__(1447);
function prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if ((0, _getprefetchcacheentrystatus.getPrefetchEntryCacheStatus)(prefetchCacheEntry) === _getprefetchcacheentrystatus.PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prune-prefetch-cache.js.map


/***/ }),

/***/ 2432:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "refreshReducer", ({
    enumerable: true,
    get: function() {
        return refreshReducer;
    }
}));
const _fetchserverresponse = __webpack_require__(4599);
const _createrecordfromthenable = __webpack_require__(9669);
const _readrecordvalue = __webpack_require__(108);
const _createhreffromurl = __webpack_require__(9897);
const _applyrouterstatepatchtotree = __webpack_require__(8018);
const _isnavigatingtonewrootlayout = __webpack_require__(5991);
const _navigatereducer = __webpack_require__(7252);
const _handlemutable = __webpack_require__(8207);
const _approutercontext = __webpack_require__(3280);
const _filllazyitemstillleafwithhead = __webpack_require__(2494);
function refreshReducer(state, action) {
    const { cache , mutable , origin  } = action;
    const href = state.canonicalUrl;
    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);
    if (isForCurrentTree) {
        return (0, _handlemutable.handleMutable)(state, mutable);
    }
    if (!cache.data) {
        // TODO-APP: verify that `href` is not an external url.
        // Fetch data from the root of the tree.
        cache.data = (0, _createrecordfromthenable.createRecordFromThenable)((0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), [
            state.tree[0],
            state.tree[1],
            state.tree[2],
            "refetch"
        ], state.nextUrl));
    }
    const [flightData, canonicalUrlOverride] = (0, _readrecordvalue.readRecordValue)(cache.data);
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
    }
    // Remove cache.data as it has been resolved at this point.
    cache.data = null;
    let currentTree = state.tree;
    for (const flightDataPath of flightData){
        // FlightDataPath with more than two items means unexpected Flight data was returned
        if (flightDataPath.length !== 3) {
            // TODO-APP: handle this case better
            console.log("REFRESH FAILED");
            return state;
        }
        // Given the path can only have two items the items are only the router state and subTreeData for the root.
        const [treePatch] = flightDataPath;
        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            ""
        ], currentTree, treePatch);
        if (newTree === null) {
            throw new Error("SEGMENT MISMATCH");
        }
        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
        if (canonicalUrlOverride) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        // The one before last item is the router state tree patch
        const [subTreeData, head] = flightDataPath.slice(-2);
        // Handles case where prefetch only returns the router tree patch without rendered components.
        if (subTreeData !== null) {
            cache.status = _approutercontext.CacheStates.READY;
            cache.subTreeData = subTreeData;
            (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, head);
            mutable.cache = cache;
            mutable.prefetchCache = new Map();
        }
        mutable.previousTree = currentTree;
        mutable.patchedTree = newTree;
        mutable.canonicalUrl = href;
        currentTree = newTree;
    }
    return (0, _handlemutable.handleMutable)(state, mutable);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=refresh-reducer.js.map


/***/ }),

/***/ 5452:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "restoreReducer", ({
    enumerable: true,
    get: function() {
        return restoreReducer;
    }
}));
const _createhreffromurl = __webpack_require__(9897);
function restoreReducer(state, action) {
    const { url , tree  } = action;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    return {
        // Set canonical url
        canonicalUrl: href,
        pushRef: state.pushRef,
        focusAndScrollRef: state.focusAndScrollRef,
        cache: state.cache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: tree,
        nextUrl: url.pathname
    };
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=restore-reducer.js.map


/***/ }),

/***/ 2110:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "serverActionReducer", ({
    enumerable: true,
    get: function() {
        return serverActionReducer;
    }
}));
const _appcallserver = __webpack_require__(6942);
const _approuterheaders = __webpack_require__(2982);
const _createrecordfromthenable = __webpack_require__(9669);
const _readrecordvalue = __webpack_require__(108);
const _client = __webpack_require__(7897);
const _routerreducertypes = __webpack_require__(664);
const _addbasepath = __webpack_require__(3022);
const _createhreffromurl = __webpack_require__(9897);
const _redirect = __webpack_require__(8305);
async function fetchServerAction(state, param) {
    let { actionId , actionArgs  } = param;
    const body = await (0, _client.encodeReply)(actionArgs);
    const res = await fetch("", {
        method: "POST",
        headers: {
            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,
            "Next-Action": actionId,
            [_approuterheaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(state.tree),
            ...state.nextUrl ? {
                [_approuterheaders.NEXT_URL]: state.nextUrl
            } : {}
        },
        body
    });
    const location = res.headers.get("x-action-redirect");
    const redirectLocation = location ? new URL((0, _addbasepath.addBasePath)(location), window.location.origin) : undefined;
    let isFlightResponse = res.headers.get("content-type") === _approuterheaders.RSC_CONTENT_TYPE_HEADER;
    if (isFlightResponse) {
        const result = await (0, _client.createFromFetch)(Promise.resolve(res), {
            callServer: _appcallserver.callServer
        });
        // if it was a redirection, then result is just a regular RSC payload
        if (location) {
            return {
                actionFlightData: result,
                redirectLocation
            };
        // otherwise it's a tuple of [actionResult, actionFlightData]
        } else {
            const [actionResult, actionFlightData] = result != null ? result : [];
            return {
                actionResult,
                actionFlightData,
                redirectLocation
            };
        }
    }
    return {
        redirectLocation
    };
}
function serverActionReducer(state, action) {
    // the action could be called twice so we need to check if we already have applied it
    if (action.mutable.serverActionApplied) {
        return state;
    }
    if (!action.mutable.inFlightServerAction) {
        action.mutable.previousTree = state.tree;
        action.mutable.previousUrl = state.canonicalUrl;
        action.mutable.inFlightServerAction = (0, _createrecordfromthenable.createRecordFromThenable)(fetchServerAction(state, action));
    }
    try {
        // suspends until the server action is resolved.
        const { actionResult , actionFlightData , redirectLocation  } = (0, _readrecordvalue.readRecordValue)(action.mutable.inFlightServerAction);
        if (redirectLocation) {
            // the redirection might have a flight data associated with it, so we'll populate the cache with it
            if (actionFlightData) {
                const href = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);
                const previousCacheEntry = state.prefetchCache.get(href);
                var _previousCacheEntry_kind;
                state.prefetchCache.set(href, {
                    data: (0, _createrecordfromthenable.createRecordFromThenable)(Promise.resolve([
                        actionFlightData,
                        // TODO-APP: verify the logic around canonical URL overrides
                        undefined
                    ])),
                    kind: (_previousCacheEntry_kind = previousCacheEntry == null ? void 0 : previousCacheEntry.kind) != null ? _previousCacheEntry_kind : _routerreducertypes.PrefetchKind.TEMPORARY,
                    prefetchTime: Date.now(),
                    treeAtTimeOfPrefetch: action.mutable.previousTree,
                    lastUsedTime: null
                });
            }
            // we throw the redirection in the action handler so that it is caught during render
            action.reject((0, _redirect.getRedirectError)(redirectLocation.toString(), _redirect.RedirectType.push));
        } else {
            if (actionFlightData) {
                const href = (0, _createhreffromurl.createHrefFromUrl)(new URL(action.mutable.previousUrl, window.location.origin), false);
                const previousCacheEntry = state.prefetchCache.get(href);
                var _previousCacheEntry_kind1;
                state.prefetchCache.set((0, _createhreffromurl.createHrefFromUrl)(new URL(action.mutable.previousUrl, window.location.origin), false), {
                    data: (0, _createrecordfromthenable.createRecordFromThenable)(Promise.resolve([
                        actionFlightData,
                        // TODO-APP: verify the logic around canonical URL overrides
                        undefined
                    ])),
                    kind: (_previousCacheEntry_kind1 = previousCacheEntry == null ? void 0 : previousCacheEntry.kind) != null ? _previousCacheEntry_kind1 : _routerreducertypes.PrefetchKind.TEMPORARY,
                    prefetchTime: Date.now(),
                    treeAtTimeOfPrefetch: action.mutable.previousTree,
                    lastUsedTime: null
                });
                // this is an intentional hack around React: we want to update the tree in a new render
                setTimeout(()=>{
                    action.changeByServerResponse(action.mutable.previousTree, actionFlightData, undefined);
                });
            }
            action.resolve(actionResult);
        }
    } catch (e) {
        if (e.status === "rejected") {
            action.reject(e.value);
        } else {
            throw e;
        }
    }
    action.mutable.serverActionApplied = true;
    return state;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-action-reducer.js.map


/***/ }),

/***/ 5686:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "serverPatchReducer", ({
    enumerable: true,
    get: function() {
        return serverPatchReducer;
    }
}));
const _createhreffromurl = __webpack_require__(9897);
const _applyrouterstatepatchtotree = __webpack_require__(8018);
const _isnavigatingtonewrootlayout = __webpack_require__(5991);
const _navigatereducer = __webpack_require__(7252);
const _applyflightdata = __webpack_require__(4403);
const _handlemutable = __webpack_require__(8207);
function serverPatchReducer(state, action) {
    const { flightData , previousTree , overrideCanonicalUrl , cache , mutable  } = action;
    const isForCurrentTree = JSON.stringify(previousTree) === JSON.stringify(state.tree);
    // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.
    // In that case opt-out of applying the patch given that the data could be stale.
    if (!isForCurrentTree) {
        // TODO-APP: Handle tree mismatch
        console.log("TREE MISMATCH");
        // Keep everything as-is.
        return state;
    }
    if (mutable.previousTree) {
        return (0, _handlemutable.handleMutable)(state, mutable);
    }
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const flightDataPath of flightData){
        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet
        const flightSegmentPath = flightDataPath.slice(0, -4);
        const [treePatch] = flightDataPath.slice(-3, -2);
        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            "",
            ...flightSegmentPath
        ], currentTree, treePatch);
        if (newTree === null) {
            throw new Error("SEGMENT MISMATCH");
        }
        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createhreffromurl.createHrefFromUrl)(overrideCanonicalUrl) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        (0, _applyflightdata.applyFlightData)(currentCache, cache, flightDataPath);
        mutable.previousTree = currentTree;
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return (0, _handlemutable.handleMutable)(state, mutable);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-patch-reducer.js.map


/***/ }),

/***/ 664:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PrefetchKind: function() {
        return PrefetchKind;
    },
    ACTION_REFRESH: function() {
        return ACTION_REFRESH;
    },
    ACTION_NAVIGATE: function() {
        return ACTION_NAVIGATE;
    },
    ACTION_RESTORE: function() {
        return ACTION_RESTORE;
    },
    ACTION_SERVER_PATCH: function() {
        return ACTION_SERVER_PATCH;
    },
    ACTION_PREFETCH: function() {
        return ACTION_PREFETCH;
    },
    ACTION_FAST_REFRESH: function() {
        return ACTION_FAST_REFRESH;
    },
    ACTION_SERVER_ACTION: function() {
        return ACTION_SERVER_ACTION;
    }
});
const ACTION_REFRESH = "refresh";
const ACTION_NAVIGATE = "navigate";
const ACTION_RESTORE = "restore";
const ACTION_SERVER_PATCH = "server-patch";
const ACTION_PREFETCH = "prefetch";
const ACTION_FAST_REFRESH = "fast-refresh";
const ACTION_SERVER_ACTION = "server-action";
var PrefetchKind;
(function(PrefetchKind) {
    PrefetchKind["AUTO"] = "auto";
    PrefetchKind["FULL"] = "full";
    PrefetchKind["TEMPORARY"] = "temporary";
})(PrefetchKind || (PrefetchKind = {}));
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer-types.js.map


/***/ }),

/***/ 542:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "reducer", ({
    enumerable: true,
    get: function() {
        return reducer;
    }
}));
const _routerreducertypes = __webpack_require__(664);
const _navigatereducer = __webpack_require__(7252);
const _serverpatchreducer = __webpack_require__(5686);
const _restorereducer = __webpack_require__(5452);
const _refreshreducer = __webpack_require__(2432);
const _prefetchreducer = __webpack_require__(5274);
const _fastrefreshreducer = __webpack_require__(4614);
const _serveractionreducer = __webpack_require__(2110);
/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case _routerreducertypes.ACTION_NAVIGATE:
            {
                return (0, _navigatereducer.navigateReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_PATCH:
            {
                return (0, _serverpatchreducer.serverPatchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_RESTORE:
            {
                return (0, _restorereducer.restoreReducer)(state, action);
            }
        case _routerreducertypes.ACTION_REFRESH:
            {
                return (0, _refreshreducer.refreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_FAST_REFRESH:
            {
                return (0, _fastrefreshreducer.fastRefreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_PREFETCH:
            {
                return (0, _prefetchreducer.prefetchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_ACTION:
            {
                return (0, _serveractionreducer.serverActionReducer)(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw new Error("Unknown action");
    }
}
function serverReducer(state, _action) {
    return state;
}
const reducer =  true ? serverReducer : 0;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer.js.map


/***/ }),

/***/ 190:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "shouldHardNavigate", ({
    enumerable: true,
    get: function() {
        return shouldHardNavigate;
    }
}));
const _matchsegments = __webpack_require__(8226);
function shouldHardNavigate(flightSegmentPath, flightRouterState) {
    const [segment, parallelRoutes] = flightRouterState;
    // TODO-APP: Check if `as` can be replaced.
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Check if current segment matches the existing segment.
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.
        if (Array.isArray(currentSegment)) {
            return true;
        }
        // If the existing segment did not match soft navigation is triggered.
        return false;
    }
    const lastSegment = flightSegmentPath.length <= 2;
    if (lastSegment) {
        return false;
    }
    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=should-hard-navigate.js.map


/***/ }),

/***/ 1194:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createSearchParamsBailoutProxy", ({
    enumerable: true,
    get: function() {
        return createSearchParamsBailoutProxy;
    }
}));
const _staticgenerationbailout = __webpack_require__(7866);
function createSearchParamsBailoutProxy() {
    return new Proxy({}, {
        get (_target, prop) {
            // React adds some properties on the object when serializing for client components
            if (typeof prop === "string") {
                (0, _staticgenerationbailout.staticGenerationBailout)("searchParams." + prop);
            }
        }
    });
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=searchparams-bailout-proxy.js.map


/***/ }),

/***/ 7866:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "staticGenerationBailout", ({
    enumerable: true,
    get: function() {
        return staticGenerationBailout;
    }
}));
const _hooksservercontext = __webpack_require__(5404);
const _staticgenerationasyncstorage = __webpack_require__(1839);
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args);
        this.code = "NEXT_STATIC_GEN_BAILOUT";
    }
}
const staticGenerationBailout = (reason, opts)=>{
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {
        const { dynamic ="error" , link  } = opts || {};
        const suffix = link ? " See more info here: " + link : "";
        throw new StaticGenBailoutError('Page with `dynamic = "' + dynamic + "\"` couldn't be rendered statically because it used `" + reason + "`." + suffix);
    }
    if (staticGenerationStore) {
        staticGenerationStore.revalidate = 0;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(reason);
        staticGenerationStore.dynamicUsageDescription = reason;
        staticGenerationStore.dynamicUsageStack = err.stack;
        throw err;
    }
    return false;
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map


/***/ }),

/***/ 5192:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return StaticGenerationSearchParamsBailoutProvider;
    }
}));
const _interop_require_default = __webpack_require__(5967);
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8038));
const _searchparamsbailoutproxy = __webpack_require__(1194);
function StaticGenerationSearchParamsBailoutProvider(param) {
    let { Component , propsForComponent  } = param;
    const searchParams = (0, _searchparamsbailoutproxy.createSearchParamsBailoutProxy)();
    return /*#__PURE__*/ _react.default.createElement(Component, {
        searchParams: searchParams,
        ...propsForComponent
    });
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-searchparams-bailout-provider.js.map


/***/ }),

/***/ 6958:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useReducerWithReduxDevtools", ({
    enumerable: true,
    get: function() {
        return useReducerWithReduxDevtools;
    }
}));
const _react = __webpack_require__(8038);
function normalizeRouterState(val) {
    if (val instanceof Map) {
        const obj = {};
        for (const [key, value] of val.entries()){
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value._bundlerConfig) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (typeof val === "object" && val !== null) {
        const obj = {};
        for(const key in val){
            const value = val[key];
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value.hasOwnProperty("_bundlerConfig")) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (Array.isArray(val)) {
        return val.map(normalizeRouterState);
    }
    return val;
}
function devToolReducer(fn, ref) {
    return (state, action)=>{
        const res = fn(state, action);
        if (ref.current) {
            ref.current.send(action, normalizeRouterState(res));
        }
        return res;
    };
}
function useReducerWithReduxDevtoolsNoop(fn, initialState) {
    const [state, dispatch] = (0, _react.useReducer)(fn, initialState);
    return [
        state,
        dispatch,
        ()=>{}
    ];
}
function useReducerWithReduxDevtoolsImpl(fn, initialState) {
    const devtoolsConnectionRef = (0, _react.useRef)();
    const enabledRef = (0, _react.useRef)();
    (0, _react.useEffect)(()=>{
        if (devtoolsConnectionRef.current || enabledRef.current === false) {
            return;
        }
        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === "undefined") {
            enabledRef.current = false;
            return;
        }
        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({
            instanceId: 8000,
            name: "next-router"
        });
        if (devtoolsConnectionRef.current) {
            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));
        }
        return ()=>{
            devtoolsConnectionRef.current = undefined;
        };
    }, [
        initialState
    ]);
    const [state, dispatch] = (0, _react.useReducer)(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState);
    const sync = (0, _react.useCallback)(()=>{
        if (devtoolsConnectionRef.current) {
            devtoolsConnectionRef.current.send({
                type: "RENDER_SYNC"
            }, normalizeRouterState(state));
        }
    }, [
        state
    ]);
    return [
        state,
        dispatch,
        sync
    ];
}
const useReducerWithReduxDevtools =  false ? 0 : useReducerWithReduxDevtoolsNoop;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-reducer-with-devtools.js.map


/***/ }),

/***/ 8115:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "normalizePathTrailingSlash", ({
    enumerable: true,
    get: function() {
        return normalizePathTrailingSlash;
    }
}));
const _removetrailingslash = __webpack_require__(3297);
const _parsepath = __webpack_require__(8854);
const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith("/") || undefined) {
        return path;
    }
    const { pathname , query , hash  } = (0, _parsepath.parsePath)(path);
    if (false) {}
    return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=normalize-trailing-slash.js.map


/***/ }),

/***/ 2144:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    suspense: function() {
        return suspense;
    },
    NoSSR: function() {
        return NoSSR;
    }
});
const _interop_require_default = __webpack_require__(5967);
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(8038));
const _nossrerror = __webpack_require__(561);
function suspense() {
    const error = new Error(_nossrerror.NEXT_DYNAMIC_NO_SSR_CODE);
    error.digest = _nossrerror.NEXT_DYNAMIC_NO_SSR_CODE;
    throw error;
}
function NoSSR(param) {
    let { children  } = param;
    if (true) {
        suspense();
    }
    return children;
} //# sourceMappingURL=dynamic-no-ssr.js.map


/***/ }),

/***/ 561:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// This has to be a shared module which is shared between client component error boundary and dynamic component

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NEXT_DYNAMIC_NO_SSR_CODE", ({
    enumerable: true,
    get: function() {
        return NEXT_DYNAMIC_NO_SSR_CODE;
    }
}));
const NEXT_DYNAMIC_NO_SSR_CODE = "DYNAMIC_SERVER_USAGE"; //# sourceMappingURL=no-ssr-error.js.map


/***/ }),

/***/ 7747:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
    };
}
function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [
                ai,
                bi
            ];
        }
        begs = [];
        left = str.length;
        while(i >= 0 && !result){
            if (i == ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
                result = [
                    begs.pop(),
                    bi
                ];
            } else {
                beg = begs.pop();
                if (beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
            result = [
                left,
                right
            ];
        }
    }
    return result;
}


/***/ }),

/***/ 1076:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var balanced = __webpack_require__(7747);
module.exports = expandTop;
var escSlash = "\x00SLASH" + Math.random() + "\x00";
var escOpen = "\x00OPEN" + Math.random() + "\x00";
var escClose = "\x00CLOSE" + Math.random() + "\x00";
var escComma = "\x00COMMA" + Math.random() + "\x00";
var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
    if (!str) return [
        ""
    ];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m) return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expandTop(str) {
    if (!str) return [];
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return "{" + str + "}";
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m) return [
        str
    ];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [
        ""
    ];
    if (/\$$/.test(m.pre)) {
        for(var k = 0; k < post.length; k++){
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
        }
    } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,.*\}/)) {
                str = m.pre + "{" + m.body + escClose + m.post;
                return expand(str);
            }
            return [
                str
            ];
        }
        var n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand(n[0], false).map(embrace);
                if (n.length === 1) {
                    return post.map(function(p) {
                        return m.pre + n[0] + p;
                    });
                }
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        var N;
        if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for(var i = x; test(i, y); i += incr){
                var c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === "\\") c = "";
                } else {
                    c = String(i);
                    if (pad) {
                        var need = width - c.length;
                        if (need > 0) {
                            var z = new Array(need + 1).join("0");
                            if (i < 0) c = "-" + z + c.slice(1);
                            else c = z + c;
                        }
                    }
                }
                N.push(c);
            }
        } else {
            N = [];
            for(var j = 0; j < n.length; j++){
                N.push.apply(N, expand(n[j], false));
            }
        }
        for(var j = 0; j < N.length; j++){
            for(var k = 0; k < post.length; k++){
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
        }
    }
    return expansions;
}


/***/ }),

/***/ 3041:
/***/ ((module) => {

"use strict";

!function(t, e) {
     true ? module.exports = e() : 0;
}(void 0, function() {
    "use strict";
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(t) {
            var e = [
                "th",
                "st",
                "nd",
                "rd"
            ], n = t % 100;
            return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
        }
    }, m = function(t, e, n) {
        var r = String(t);
        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
    }, v = {
        s: m,
        z: function(t) {
            var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
        },
        m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, f), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), f);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
        },
        a: function(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
        },
        p: function(t) {
            return ({
                M: f,
                y: c,
                w: o,
                d: a,
                D: d,
                h: u,
                m: s,
                s: i,
                ms: r,
                Q: h
            })[t] || String(t || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t) {
            return void 0 === t;
        }
    }, g = "en", D = {};
    D[g] = M;
    var p = function(t) {
        return t instanceof _;
    }, S = function t(e, n, r) {
        var i;
        if (!e) return g;
        if ("string" == typeof e) {
            var s = e.toLowerCase();
            D[s] && (i = s), n && (D[s] = n, i = s);
            var u = e.split("-");
            if (!i && u.length > 1) return t(u[0]);
        } else {
            var a = e.name;
            D[a] = e, i = a;
        }
        return !r && i && (g = i), i || !r && g;
    }, w = function(t, e) {
        if (p(t)) return t.clone();
        var n = "object" == typeof e ? e : {};
        return n.date = t, n.args = arguments, new _(n);
    }, O = v;
    O.l = S, O.i = p, O.w = function(t, e) {
        return w(t, {
            locale: e.$L,
            utc: e.$u,
            x: e.$x,
            $offset: e.$offset
        });
    };
    var _ = function() {
        function M(t) {
            this.$L = S(t.locale, null, !0), this.parse(t);
        }
        var m = M.prototype;
        return m.parse = function(t) {
            this.$d = function(t) {
                var e = t.date, n = t.utc;
                if (null === e) return new Date(NaN);
                if (O.u(e)) return new Date;
                if (e instanceof Date) return new Date(e);
                if ("string" == typeof e && !/Z$/i.test(e)) {
                    var r = e.match($);
                    if (r) {
                        var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                    }
                }
                return new Date(e);
            }(t), this.$x = t.x || {}, this.init();
        }, m.init = function() {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
        }, m.$utils = function() {
            return O;
        }, m.isValid = function() {
            return !(this.$d.toString() === l);
        }, m.isSame = function(t, e) {
            var n = w(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
        }, m.isAfter = function(t, e) {
            return w(t) < this.startOf(e);
        }, m.isBefore = function(t, e) {
            return this.endOf(e) < w(t);
        }, m.$g = function(t, e, n) {
            return O.u(t) ? this[e] : this.set(n, t);
        }, m.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
        }, m.valueOf = function() {
            return this.$d.getTime();
        }, m.startOf = function(t, e) {
            var n = this, r = !!O.u(e) || e, h = O.p(t), l = function(t, e) {
                var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a);
            }, $ = function(t, e) {
                return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    23,
                    59,
                    59,
                    999
                ]).slice(e)), n);
            }, y = this.$W, M = this.$M, m = this.$D, v = "set" + (this.$u ? "UTC" : "");
            switch(h){
                case c:
                    return r ? l(1, 0) : l(31, 11);
                case f:
                    return r ? l(1, M) : l(0, M + 1);
                case o:
                    var g = this.$locale().weekStart || 0, D = (y < g ? y + 7 : y) - g;
                    return l(r ? m - D : m + (6 - D), M);
                case a:
                case d:
                    return $(v + "Hours", 0);
                case u:
                    return $(v + "Minutes", 1);
                case s:
                    return $(v + "Seconds", 2);
                case i:
                    return $(v + "Milliseconds", 3);
                default:
                    return this.clone();
            }
        }, m.endOf = function(t) {
            return this.startOf(t, !1);
        }, m.$set = function(t, e) {
            var n, o = O.p(t), h = "set" + (this.$u ? "UTC" : ""), l = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o], $ = o === a ? this.$D + (e - this.$W) : e;
            if (o === f || o === c) {
                var y = this.clone().set(d, 1);
                y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
            } else l && this.$d[l]($);
            return this.init(), this;
        }, m.set = function(t, e) {
            return this.clone().$set(t, e);
        }, m.get = function(t) {
            return this[O.p(t)]();
        }, m.add = function(r, h) {
            var d, l = this;
            r = Number(r);
            var $ = O.p(h), y = function(t) {
                var e = w(l);
                return O.w(e.date(e.date() + Math.round(t * r)), l);
            };
            if ($ === f) return this.set(f, this.$M + r);
            if ($ === c) return this.set(c, this.$y + r);
            if ($ === a) return y(1);
            if ($ === o) return y(7);
            var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1, m = this.$d.getTime() + r * M;
            return O.w(m, this);
        }, m.subtract = function(t, e) {
            return this.add(-1 * t, e);
        }, m.format = function(t) {
            var e = this, n = this.$locale();
            if (!this.isValid()) return n.invalidDate || l;
            var r = t || "YYYY-MM-DDTHH:mm:ssZ", i = O.z(this), s = this.$H, u = this.$m, a = this.$M, o = n.weekdays, f = n.months, h = function(t, n, i, s) {
                return t && (t[n] || t(e, r)) || i[n].slice(0, s);
            }, c = function(t) {
                return O.s(s % 12 || 12, t, "0");
            }, d = n.meridiem || function(t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
            }, $ = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: a + 1,
                MM: O.s(a + 1, 2, "0"),
                MMM: h(n.monthsShort, a, f, 3),
                MMMM: h(f, a),
                D: this.$D,
                DD: O.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: h(n.weekdaysMin, this.$W, o, 2),
                ddd: h(n.weekdaysShort, this.$W, o, 3),
                dddd: o[this.$W],
                H: String(s),
                HH: O.s(s, 2, "0"),
                h: c(1),
                hh: c(2),
                a: d(s, u, !0),
                A: d(s, u, !1),
                m: String(u),
                mm: O.s(u, 2, "0"),
                s: String(this.$s),
                ss: O.s(this.$s, 2, "0"),
                SSS: O.s(this.$ms, 3, "0"),
                Z: i
            };
            return r.replace(y, function(t, e) {
                return e || $[t] || i.replace(":", "");
            });
        }, m.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m.diff = function(r, d, l) {
            var $, y = O.p(d), M = w(r), m = (M.utcOffset() - this.utcOffset()) * e, v = this - M, g = O.m(this, M);
            return g = ($ = {}, $[c] = g / 12, $[f] = g, $[h] = g / 3, $[o] = (v - m) / 6048e5, $[a] = (v - m) / 864e5, $[u] = v / n, $[s] = v / e, $[i] = v / t, $)[y] || v, l ? g : O.a(g);
        }, m.daysInMonth = function() {
            return this.endOf(f).$D;
        }, m.$locale = function() {
            return D[this.$L];
        }, m.locale = function(t, e) {
            if (!t) return this.$L;
            var n = this.clone(), r = S(t, e, !0);
            return r && (n.$L = r), n;
        }, m.clone = function() {
            return O.w(this.$d, this);
        }, m.toDate = function() {
            return new Date(this.valueOf());
        }, m.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
        }, m.toISOString = function() {
            return this.$d.toISOString();
        }, m.toString = function() {
            return this.$d.toUTCString();
        }, M;
    }(), T = _.prototype;
    return w.prototype = T, [
        [
            "$ms",
            r
        ],
        [
            "$s",
            i
        ],
        [
            "$m",
            s
        ],
        [
            "$H",
            u
        ],
        [
            "$W",
            a
        ],
        [
            "$M",
            f
        ],
        [
            "$y",
            c
        ],
        [
            "$D",
            d
        ]
    ].forEach(function(t) {
        T[t[1]] = function(e) {
            return this.$g(e, t[0], t[1]);
        };
    }), w.extend = function(t, e) {
        return t.$i || (t(e, _, w), t.$i = !0), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t) {
        return w(1e3 * t);
    }, w.en = D[g], w.Ls = D, w.p = {}, w;
});


/***/ }),

/***/ 654:
/***/ ((module) => {

"use strict";

(function webpackUniversalModuleDefinition(root, factory) {
    /* istanbul ignore next */ if (true) module.exports = factory();
    else {}
})(void 0, function() {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ // The require function
        /******/ function __nested_webpack_require_589__(moduleId) {
            /******/ // Check if module is in cache
            /* istanbul ignore if */ /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ exports: {},
                /******/ id: moduleId,
                /******/ loaded: false
            };
            /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_589__);
            /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ // expose the modules object (__webpack_modules__)
        /******/ __nested_webpack_require_589__.m = modules;
        /******/ // expose the module cache
        /******/ __nested_webpack_require_589__.c = installedModules;
        /******/ // __webpack_public_path__
        /******/ __nested_webpack_require_589__.p = "";
        /******/ // Load entry module and return exports
        /******/ return __nested_webpack_require_589__(0);
    /******/ }([
        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_1939__) {
            "use strict";
            /*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/ Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var comment_handler_1 = __nested_webpack_require_1939__(1);
            var jsx_parser_1 = __nested_webpack_require_1939__(3);
            var parser_1 = __nested_webpack_require_1939__(8);
            var tokenizer_1 = __nested_webpack_require_1939__(15);
            function parse(code, options, delegate) {
                var commentHandler = null;
                var proxyDelegate = function(node, metadata) {
                    if (delegate) {
                        delegate(node, metadata);
                    }
                    if (commentHandler) {
                        commentHandler.visit(node, metadata);
                    }
                };
                var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
                var collectComment = false;
                if (options) {
                    collectComment = typeof options.comment === "boolean" && options.comment;
                    var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
                    if (collectComment || attachComment) {
                        commentHandler = new comment_handler_1.CommentHandler();
                        commentHandler.attach = attachComment;
                        options.comment = true;
                        parserDelegate = proxyDelegate;
                    }
                }
                var isModule = false;
                if (options && typeof options.sourceType === "string") {
                    isModule = options.sourceType === "module";
                }
                var parser;
                if (options && typeof options.jsx === "boolean" && options.jsx) {
                    parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
                } else {
                    parser = new parser_1.Parser(code, options, parserDelegate);
                }
                var program = isModule ? parser.parseModule() : parser.parseScript();
                var ast = program;
                if (collectComment && commentHandler) {
                    ast.comments = commentHandler.comments;
                }
                if (parser.config.tokens) {
                    ast.tokens = parser.tokens;
                }
                if (parser.config.tolerant) {
                    ast.errors = parser.errorHandler.errors;
                }
                return ast;
            }
            exports1.parse = parse;
            function parseModule(code, options, delegate) {
                var parsingOptions = options || {};
                parsingOptions.sourceType = "module";
                return parse(code, parsingOptions, delegate);
            }
            exports1.parseModule = parseModule;
            function parseScript(code, options, delegate) {
                var parsingOptions = options || {};
                parsingOptions.sourceType = "script";
                return parse(code, parsingOptions, delegate);
            }
            exports1.parseScript = parseScript;
            function tokenize(code, options, delegate) {
                var tokenizer = new tokenizer_1.Tokenizer(code, options);
                var tokens;
                tokens = [];
                try {
                    while(true){
                        var token = tokenizer.getNextToken();
                        if (!token) {
                            break;
                        }
                        if (delegate) {
                            token = delegate(token);
                        }
                        tokens.push(token);
                    }
                } catch (e) {
                    tokenizer.errorHandler.tolerate(e);
                }
                if (tokenizer.errorHandler.tolerant) {
                    tokens.errors = tokenizer.errors();
                }
                return tokens;
            }
            exports1.tokenize = tokenize;
            var syntax_1 = __nested_webpack_require_1939__(2);
            exports1.Syntax = syntax_1.Syntax;
            // Sync with *.json manifests.
            exports1.version = "4.0.1";
        /***/ },
        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_7627__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var syntax_1 = __nested_webpack_require_7627__(2);
            var CommentHandler = function() {
                function CommentHandler() {
                    this.attach = false;
                    this.comments = [];
                    this.stack = [];
                    this.leading = [];
                    this.trailing = [];
                }
                CommentHandler.prototype.insertInnerComments = function(node, metadata) {
                    //  innnerComments for properties empty block
                    //  `function a() {/** comments **\/}`
                    if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                        var innerComments = [];
                        for(var i = this.leading.length - 1; i >= 0; --i){
                            var entry = this.leading[i];
                            if (metadata.end.offset >= entry.start) {
                                innerComments.unshift(entry.comment);
                                this.leading.splice(i, 1);
                                this.trailing.splice(i, 1);
                            }
                        }
                        if (innerComments.length) {
                            node.innerComments = innerComments;
                        }
                    }
                };
                CommentHandler.prototype.findTrailingComments = function(metadata) {
                    var trailingComments = [];
                    if (this.trailing.length > 0) {
                        for(var i = this.trailing.length - 1; i >= 0; --i){
                            var entry_1 = this.trailing[i];
                            if (entry_1.start >= metadata.end.offset) {
                                trailingComments.unshift(entry_1.comment);
                            }
                        }
                        this.trailing.length = 0;
                        return trailingComments;
                    }
                    var entry = this.stack[this.stack.length - 1];
                    if (entry && entry.node.trailingComments) {
                        var firstComment = entry.node.trailingComments[0];
                        if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                            trailingComments = entry.node.trailingComments;
                            delete entry.node.trailingComments;
                        }
                    }
                    return trailingComments;
                };
                CommentHandler.prototype.findLeadingComments = function(metadata) {
                    var leadingComments = [];
                    var target;
                    while(this.stack.length > 0){
                        var entry = this.stack[this.stack.length - 1];
                        if (entry && entry.start >= metadata.start.offset) {
                            target = entry.node;
                            this.stack.pop();
                        } else {
                            break;
                        }
                    }
                    if (target) {
                        var count = target.leadingComments ? target.leadingComments.length : 0;
                        for(var i = count - 1; i >= 0; --i){
                            var comment = target.leadingComments[i];
                            if (comment.range[1] <= metadata.start.offset) {
                                leadingComments.unshift(comment);
                                target.leadingComments.splice(i, 1);
                            }
                        }
                        if (target.leadingComments && target.leadingComments.length === 0) {
                            delete target.leadingComments;
                        }
                        return leadingComments;
                    }
                    for(var i = this.leading.length - 1; i >= 0; --i){
                        var entry = this.leading[i];
                        if (entry.start <= metadata.start.offset) {
                            leadingComments.unshift(entry.comment);
                            this.leading.splice(i, 1);
                        }
                    }
                    return leadingComments;
                };
                CommentHandler.prototype.visitNode = function(node, metadata) {
                    if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                        return;
                    }
                    this.insertInnerComments(node, metadata);
                    var trailingComments = this.findTrailingComments(metadata);
                    var leadingComments = this.findLeadingComments(metadata);
                    if (leadingComments.length > 0) {
                        node.leadingComments = leadingComments;
                    }
                    if (trailingComments.length > 0) {
                        node.trailingComments = trailingComments;
                    }
                    this.stack.push({
                        node: node,
                        start: metadata.start.offset
                    });
                };
                CommentHandler.prototype.visitComment = function(node, metadata) {
                    var type = node.type[0] === "L" ? "Line" : "Block";
                    var comment = {
                        type: type,
                        value: node.value
                    };
                    if (node.range) {
                        comment.range = node.range;
                    }
                    if (node.loc) {
                        comment.loc = node.loc;
                    }
                    this.comments.push(comment);
                    if (this.attach) {
                        var entry = {
                            comment: {
                                type: type,
                                value: node.value,
                                range: [
                                    metadata.start.offset,
                                    metadata.end.offset
                                ]
                            },
                            start: metadata.start.offset
                        };
                        if (node.loc) {
                            entry.comment.loc = node.loc;
                        }
                        node.type = type;
                        this.leading.push(entry);
                        this.trailing.push(entry);
                    }
                };
                CommentHandler.prototype.visit = function(node, metadata) {
                    if (node.type === "LineComment") {
                        this.visitComment(node, metadata);
                    } else if (node.type === "BlockComment") {
                        this.visitComment(node, metadata);
                    } else if (this.attach) {
                        this.visitNode(node, metadata);
                    }
                };
                return CommentHandler;
            }();
            exports1.CommentHandler = CommentHandler;
        /***/ },
        /* 2 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.Syntax = {
                AssignmentExpression: "AssignmentExpression",
                AssignmentPattern: "AssignmentPattern",
                ArrayExpression: "ArrayExpression",
                ArrayPattern: "ArrayPattern",
                ArrowFunctionExpression: "ArrowFunctionExpression",
                AwaitExpression: "AwaitExpression",
                BlockStatement: "BlockStatement",
                BinaryExpression: "BinaryExpression",
                BreakStatement: "BreakStatement",
                CallExpression: "CallExpression",
                CatchClause: "CatchClause",
                ClassBody: "ClassBody",
                ClassDeclaration: "ClassDeclaration",
                ClassExpression: "ClassExpression",
                ConditionalExpression: "ConditionalExpression",
                ContinueStatement: "ContinueStatement",
                DoWhileStatement: "DoWhileStatement",
                DebuggerStatement: "DebuggerStatement",
                EmptyStatement: "EmptyStatement",
                ExportAllDeclaration: "ExportAllDeclaration",
                ExportDefaultDeclaration: "ExportDefaultDeclaration",
                ExportNamedDeclaration: "ExportNamedDeclaration",
                ExportSpecifier: "ExportSpecifier",
                ExpressionStatement: "ExpressionStatement",
                ForStatement: "ForStatement",
                ForOfStatement: "ForOfStatement",
                ForInStatement: "ForInStatement",
                FunctionDeclaration: "FunctionDeclaration",
                FunctionExpression: "FunctionExpression",
                Identifier: "Identifier",
                IfStatement: "IfStatement",
                ImportDeclaration: "ImportDeclaration",
                ImportDefaultSpecifier: "ImportDefaultSpecifier",
                ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                ImportSpecifier: "ImportSpecifier",
                Literal: "Literal",
                LabeledStatement: "LabeledStatement",
                LogicalExpression: "LogicalExpression",
                MemberExpression: "MemberExpression",
                MetaProperty: "MetaProperty",
                MethodDefinition: "MethodDefinition",
                NewExpression: "NewExpression",
                ObjectExpression: "ObjectExpression",
                ObjectPattern: "ObjectPattern",
                Program: "Program",
                Property: "Property",
                RestElement: "RestElement",
                ReturnStatement: "ReturnStatement",
                SequenceExpression: "SequenceExpression",
                SpreadElement: "SpreadElement",
                Super: "Super",
                SwitchCase: "SwitchCase",
                SwitchStatement: "SwitchStatement",
                TaggedTemplateExpression: "TaggedTemplateExpression",
                TemplateElement: "TemplateElement",
                TemplateLiteral: "TemplateLiteral",
                ThisExpression: "ThisExpression",
                ThrowStatement: "ThrowStatement",
                TryStatement: "TryStatement",
                UnaryExpression: "UnaryExpression",
                UpdateExpression: "UpdateExpression",
                VariableDeclaration: "VariableDeclaration",
                VariableDeclarator: "VariableDeclarator",
                WhileStatement: "WhileStatement",
                WithStatement: "WithStatement",
                YieldExpression: "YieldExpression"
            };
        /***/ },
        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_18710__) {
            "use strict";
            /* istanbul ignore next */ var __extends = this && this.__extends || function() {
                var extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(d, b) {
                    d.__proto__ = b;
                } || function(d, b) {
                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function(d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var character_1 = __nested_webpack_require_18710__(4);
            var JSXNode = __nested_webpack_require_18710__(5);
            var jsx_syntax_1 = __nested_webpack_require_18710__(6);
            var Node = __nested_webpack_require_18710__(7);
            var parser_1 = __nested_webpack_require_18710__(8);
            var token_1 = __nested_webpack_require_18710__(13);
            var xhtml_entities_1 = __nested_webpack_require_18710__(14);
            token_1.TokenName[100 /* Identifier */ ] = "JSXIdentifier";
            token_1.TokenName[101 /* Text */ ] = "JSXText";
            // Fully qualified element name, e.g. <svg:path> returns "svg:path"
            function getQualifiedElementName(elementName) {
                var qualifiedName;
                switch(elementName.type){
                    case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                        var id = elementName;
                        qualifiedName = id.name;
                        break;
                    case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                        var ns = elementName;
                        qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                        break;
                    case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                        var expr = elementName;
                        qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                        break;
                    /* istanbul ignore next */ default:
                        break;
                }
                return qualifiedName;
            }
            var JSXParser = function(_super) {
                __extends(JSXParser, _super);
                function JSXParser(code, options, delegate) {
                    return _super.call(this, code, options, delegate) || this;
                }
                JSXParser.prototype.parsePrimaryExpression = function() {
                    return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
                };
                JSXParser.prototype.startJSX = function() {
                    // Unwind the scanner before the lookahead token.
                    this.scanner.index = this.startMarker.index;
                    this.scanner.lineNumber = this.startMarker.line;
                    this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                };
                JSXParser.prototype.finishJSX = function() {
                    // Prime the next lookahead.
                    this.nextToken();
                };
                JSXParser.prototype.reenterJSX = function() {
                    this.startJSX();
                    this.expectJSX("}");
                    // Pop the closing '}' added from the lookahead.
                    if (this.config.tokens) {
                        this.tokens.pop();
                    }
                };
                JSXParser.prototype.createJSXNode = function() {
                    this.collectComments();
                    return {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                };
                JSXParser.prototype.createJSXChildNode = function() {
                    return {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                };
                JSXParser.prototype.scanXHTMLEntity = function(quote) {
                    var result = "&";
                    var valid = true;
                    var terminated = false;
                    var numeric = false;
                    var hex = false;
                    while(!this.scanner.eof() && valid && !terminated){
                        var ch = this.scanner.source[this.scanner.index];
                        if (ch === quote) {
                            break;
                        }
                        terminated = ch === ";";
                        result += ch;
                        ++this.scanner.index;
                        if (!terminated) {
                            switch(result.length){
                                case 2:
                                    // e.g. '&#123;'
                                    numeric = ch === "#";
                                    break;
                                case 3:
                                    if (numeric) {
                                        // e.g. '&#x41;'
                                        hex = ch === "x";
                                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                                        numeric = numeric && !hex;
                                    }
                                    break;
                                default:
                                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                                    break;
                            }
                        }
                    }
                    if (valid && terminated && result.length > 2) {
                        // e.g. '&#x41;' becomes just '#x41'
                        var str = result.substr(1, result.length - 2);
                        if (numeric && str.length > 1) {
                            result = String.fromCharCode(parseInt(str.substr(1), 10));
                        } else if (hex && str.length > 2) {
                            result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                        } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                            result = xhtml_entities_1.XHTMLEntities[str];
                        }
                    }
                    return result;
                };
                // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
                JSXParser.prototype.lexJSX = function() {
                    var cp = this.scanner.source.charCodeAt(this.scanner.index);
                    // < > / : = { }
                    if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                        var value = this.scanner.source[this.scanner.index++];
                        return {
                            type: 7 /* Punctuator */ ,
                            value: value,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: this.scanner.index - 1,
                            end: this.scanner.index
                        };
                    }
                    // " '
                    if (cp === 34 || cp === 39) {
                        var start = this.scanner.index;
                        var quote = this.scanner.source[this.scanner.index++];
                        var str = "";
                        while(!this.scanner.eof()){
                            var ch = this.scanner.source[this.scanner.index++];
                            if (ch === quote) {
                                break;
                            } else if (ch === "&") {
                                str += this.scanXHTMLEntity(quote);
                            } else {
                                str += ch;
                            }
                        }
                        return {
                            type: 8 /* StringLiteral */ ,
                            value: str,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    // ... or .
                    if (cp === 46) {
                        var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                        var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                        var value = n1 === 46 && n2 === 46 ? "..." : ".";
                        var start = this.scanner.index;
                        this.scanner.index += value.length;
                        return {
                            type: 7 /* Punctuator */ ,
                            value: value,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    // `
                    if (cp === 96) {
                        // Only placeholder, since it will be rescanned as a real assignment expression.
                        return {
                            type: 10 /* Template */ ,
                            value: "",
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: this.scanner.index,
                            end: this.scanner.index
                        };
                    }
                    // Identifer can not contain backslash (char code 92).
                    if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                        var start = this.scanner.index;
                        ++this.scanner.index;
                        while(!this.scanner.eof()){
                            var ch = this.scanner.source.charCodeAt(this.scanner.index);
                            if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                                ++this.scanner.index;
                            } else if (ch === 45) {
                                // Hyphen (char code 45) can be part of an identifier.
                                ++this.scanner.index;
                            } else {
                                break;
                            }
                        }
                        var id = this.scanner.source.slice(start, this.scanner.index);
                        return {
                            type: 100 /* Identifier */ ,
                            value: id,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    return this.scanner.lex();
                };
                JSXParser.prototype.nextJSXToken = function() {
                    this.collectComments();
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = this.lexJSX();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    if (this.config.tokens) {
                        this.tokens.push(this.convertToken(token));
                    }
                    return token;
                };
                JSXParser.prototype.nextJSXText = function() {
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var start = this.scanner.index;
                    var text = "";
                    while(!this.scanner.eof()){
                        var ch = this.scanner.source[this.scanner.index];
                        if (ch === "{" || ch === "<") {
                            break;
                        }
                        ++this.scanner.index;
                        text += ch;
                        if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            ++this.scanner.lineNumber;
                            if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                                ++this.scanner.index;
                            }
                            this.scanner.lineStart = this.scanner.index;
                        }
                    }
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = {
                        type: 101 /* Text */ ,
                        value: text,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start: start,
                        end: this.scanner.index
                    };
                    if (text.length > 0 && this.config.tokens) {
                        this.tokens.push(this.convertToken(token));
                    }
                    return token;
                };
                JSXParser.prototype.peekJSXToken = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.lexJSX();
                    this.scanner.restoreState(state);
                    return next;
                };
                // Expect the next JSX token to match the specified punctuator.
                // If not, an exception will be thrown.
                JSXParser.prototype.expectJSX = function(value) {
                    var token = this.nextJSXToken();
                    if (token.type !== 7 /* Punctuator */  || token.value !== value) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Return true if the next JSX token matches the specified punctuator.
                JSXParser.prototype.matchJSX = function(value) {
                    var next = this.peekJSXToken();
                    return next.type === 7 /* Punctuator */  && next.value === value;
                };
                JSXParser.prototype.parseJSXIdentifier = function() {
                    var node = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 100 /* Identifier */ ) {
                        this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
                };
                JSXParser.prototype.parseJSXElementName = function() {
                    var node = this.createJSXNode();
                    var elementName = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                        var namespace = elementName;
                        this.expectJSX(":");
                        var name_1 = this.parseJSXIdentifier();
                        elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                    } else if (this.matchJSX(".")) {
                        while(this.matchJSX(".")){
                            var object = elementName;
                            this.expectJSX(".");
                            var property = this.parseJSXIdentifier();
                            elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                        }
                    }
                    return elementName;
                };
                JSXParser.prototype.parseJSXAttributeName = function() {
                    var node = this.createJSXNode();
                    var attributeName;
                    var identifier = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                        var namespace = identifier;
                        this.expectJSX(":");
                        var name_2 = this.parseJSXIdentifier();
                        attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                    } else {
                        attributeName = identifier;
                    }
                    return attributeName;
                };
                JSXParser.prototype.parseJSXStringLiteralAttribute = function() {
                    var node = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 8 /* StringLiteral */ ) {
                        this.throwUnexpectedToken(token);
                    }
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node, new Node.Literal(token.value, raw));
                };
                JSXParser.prototype.parseJSXExpressionAttribute = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    this.finishJSX();
                    if (this.match("}")) {
                        this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                    }
                    var expression = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser.prototype.parseJSXAttributeValue = function() {
                    return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                };
                JSXParser.prototype.parseJSXNameValueAttribute = function() {
                    var node = this.createJSXNode();
                    var name = this.parseJSXAttributeName();
                    var value = null;
                    if (this.matchJSX("=")) {
                        this.expectJSX("=");
                        value = this.parseJSXAttributeValue();
                    }
                    return this.finalize(node, new JSXNode.JSXAttribute(name, value));
                };
                JSXParser.prototype.parseJSXSpreadAttribute = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    this.expectJSX("...");
                    this.finishJSX();
                    var argument = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
                };
                JSXParser.prototype.parseJSXAttributes = function() {
                    var attributes = [];
                    while(!this.matchJSX("/") && !this.matchJSX(">")){
                        var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                        attributes.push(attribute);
                    }
                    return attributes;
                };
                JSXParser.prototype.parseJSXOpeningElement = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("<");
                    var name = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                        this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser.prototype.parseJSXBoundaryElement = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("<");
                    if (this.matchJSX("/")) {
                        this.expectJSX("/");
                        var name_3 = this.parseJSXElementName();
                        this.expectJSX(">");
                        return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                    }
                    var name = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                        this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser.prototype.parseJSXEmptyExpression = function() {
                    var node = this.createJSXChildNode();
                    this.collectComments();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    return this.finalize(node, new JSXNode.JSXEmptyExpression());
                };
                JSXParser.prototype.parseJSXExpressionContainer = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    var expression;
                    if (this.matchJSX("}")) {
                        expression = this.parseJSXEmptyExpression();
                        this.expectJSX("}");
                    } else {
                        this.finishJSX();
                        expression = this.parseAssignmentExpression();
                        this.reenterJSX();
                    }
                    return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser.prototype.parseJSXChildren = function() {
                    var children = [];
                    while(!this.scanner.eof()){
                        var node = this.createJSXChildNode();
                        var token = this.nextJSXText();
                        if (token.start < token.end) {
                            var raw = this.getTokenRaw(token);
                            var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                            children.push(child);
                        }
                        if (this.scanner.source[this.scanner.index] === "{") {
                            var container = this.parseJSXExpressionContainer();
                            children.push(container);
                        } else {
                            break;
                        }
                    }
                    return children;
                };
                JSXParser.prototype.parseComplexJSXElement = function(el) {
                    var stack = [];
                    while(!this.scanner.eof()){
                        el.children = el.children.concat(this.parseJSXChildren());
                        var node = this.createJSXChildNode();
                        var element = this.parseJSXBoundaryElement();
                        if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                            var opening = element;
                            if (opening.selfClosing) {
                                var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                                el.children.push(child);
                            } else {
                                stack.push(el);
                                el = {
                                    node: node,
                                    opening: opening,
                                    closing: null,
                                    children: []
                                };
                            }
                        }
                        if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                            el.closing = element;
                            var open_1 = getQualifiedElementName(el.opening.name);
                            var close_1 = getQualifiedElementName(el.closing.name);
                            if (open_1 !== close_1) {
                                this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                            }
                            if (stack.length > 0) {
                                var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                                el = stack[stack.length - 1];
                                el.children.push(child);
                                stack.pop();
                            } else {
                                break;
                            }
                        }
                    }
                    return el;
                };
                JSXParser.prototype.parseJSXElement = function() {
                    var node = this.createJSXNode();
                    var opening = this.parseJSXOpeningElement();
                    var children = [];
                    var closing = null;
                    if (!opening.selfClosing) {
                        var el = this.parseComplexJSXElement({
                            node: node,
                            opening: opening,
                            closing: closing,
                            children: children
                        });
                        children = el.children;
                        closing = el.closing;
                    }
                    return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
                };
                JSXParser.prototype.parseJSXRoot = function() {
                    // Pop the opening '<' added from the lookahead.
                    if (this.config.tokens) {
                        this.tokens.pop();
                    }
                    this.startJSX();
                    var element = this.parseJSXElement();
                    this.finishJSX();
                    return element;
                };
                JSXParser.prototype.isStartOfExpression = function() {
                    return _super.prototype.isStartOfExpression.call(this) || this.match("<");
                };
                return JSXParser;
            }(parser_1.Parser);
            exports1.JSXParser = JSXParser;
        /***/ },
        /* 4 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            // See also tools/generate-unicode-regex.js.
            var Regex = {
                // Unicode v8.0.0 NonAsciiIdentifierStart:
                NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                // Unicode v8.0.0 NonAsciiIdentifierPart:
                NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports1.Character = {
                /* tslint:disable:no-bitwise */ fromCodePoint: function(cp) {
                    return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
                },
                // https://tc39.github.io/ecma262/#sec-white-space
                isWhiteSpace: function(cp) {
                    return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [
                        0x1680,
                        0x2000,
                        0x2001,
                        0x2002,
                        0x2003,
                        0x2004,
                        0x2005,
                        0x2006,
                        0x2007,
                        0x2008,
                        0x2009,
                        0x200A,
                        0x202F,
                        0x205F,
                        0x3000,
                        0xFEFF
                    ].indexOf(cp) >= 0;
                },
                // https://tc39.github.io/ecma262/#sec-line-terminators
                isLineTerminator: function(cp) {
                    return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
                },
                // https://tc39.github.io/ecma262/#sec-names-and-keywords
                isIdentifierStart: function(cp) {
                    return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports1.Character.fromCodePoint(cp));
                },
                isIdentifierPart: function(cp) {
                    return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports1.Character.fromCodePoint(cp));
                },
                // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
                isDecimalDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x39; // 0..9
                },
                isHexDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
                },
                isOctalDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x37; // 0..7
                }
            };
        /***/ },
        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_64544__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var jsx_syntax_1 = __nested_webpack_require_64544__(6);
            /* tslint:disable:max-classes-per-file */ var JSXClosingElement = function() {
                function JSXClosingElement(name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                    this.name = name;
                }
                return JSXClosingElement;
            }();
            exports1.JSXClosingElement = JSXClosingElement;
            var JSXElement = function() {
                function JSXElement(openingElement, children, closingElement) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                    this.openingElement = openingElement;
                    this.children = children;
                    this.closingElement = closingElement;
                }
                return JSXElement;
            }();
            exports1.JSXElement = JSXElement;
            var JSXEmptyExpression = function() {
                function JSXEmptyExpression() {
                    this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
                }
                return JSXEmptyExpression;
            }();
            exports1.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = function() {
                function JSXExpressionContainer(expression) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                    this.expression = expression;
                }
                return JSXExpressionContainer;
            }();
            exports1.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = function() {
                function JSXIdentifier(name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                    this.name = name;
                }
                return JSXIdentifier;
            }();
            exports1.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = function() {
                function JSXMemberExpression(object, property) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                    this.object = object;
                    this.property = property;
                }
                return JSXMemberExpression;
            }();
            exports1.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = function() {
                function JSXAttribute(name, value) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                    this.name = name;
                    this.value = value;
                }
                return JSXAttribute;
            }();
            exports1.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = function() {
                function JSXNamespacedName(namespace, name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                    this.namespace = namespace;
                    this.name = name;
                }
                return JSXNamespacedName;
            }();
            exports1.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = function() {
                function JSXOpeningElement(name, selfClosing, attributes) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                    this.name = name;
                    this.selfClosing = selfClosing;
                    this.attributes = attributes;
                }
                return JSXOpeningElement;
            }();
            exports1.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = function() {
                function JSXSpreadAttribute(argument) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                    this.argument = argument;
                }
                return JSXSpreadAttribute;
            }();
            exports1.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = function() {
                function JSXText(value, raw) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXText;
                    this.value = value;
                    this.raw = raw;
                }
                return JSXText;
            }();
            exports1.JSXText = JSXText;
        /***/ },
        /* 6 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.JSXSyntax = {
                JSXAttribute: "JSXAttribute",
                JSXClosingElement: "JSXClosingElement",
                JSXElement: "JSXElement",
                JSXEmptyExpression: "JSXEmptyExpression",
                JSXExpressionContainer: "JSXExpressionContainer",
                JSXIdentifier: "JSXIdentifier",
                JSXMemberExpression: "JSXMemberExpression",
                JSXNamespacedName: "JSXNamespacedName",
                JSXOpeningElement: "JSXOpeningElement",
                JSXSpreadAttribute: "JSXSpreadAttribute",
                JSXText: "JSXText"
            };
        /***/ },
        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_69915__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var syntax_1 = __nested_webpack_require_69915__(2);
            /* tslint:disable:max-classes-per-file */ var ArrayExpression = function() {
                function ArrayExpression(elements) {
                    this.type = syntax_1.Syntax.ArrayExpression;
                    this.elements = elements;
                }
                return ArrayExpression;
            }();
            exports1.ArrayExpression = ArrayExpression;
            var ArrayPattern = function() {
                function ArrayPattern(elements) {
                    this.type = syntax_1.Syntax.ArrayPattern;
                    this.elements = elements;
                }
                return ArrayPattern;
            }();
            exports1.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = function() {
                function ArrowFunctionExpression(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = false;
                }
                return ArrowFunctionExpression;
            }();
            exports1.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = function() {
                function AssignmentExpression(operator, left, right) {
                    this.type = syntax_1.Syntax.AssignmentExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                }
                return AssignmentExpression;
            }();
            exports1.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = function() {
                function AssignmentPattern(left, right) {
                    this.type = syntax_1.Syntax.AssignmentPattern;
                    this.left = left;
                    this.right = right;
                }
                return AssignmentPattern;
            }();
            exports1.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = function() {
                function AsyncArrowFunctionExpression(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = true;
                }
                return AsyncArrowFunctionExpression;
            }();
            exports1.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = function() {
                function AsyncFunctionDeclaration(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                }
                return AsyncFunctionDeclaration;
            }();
            exports1.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = function() {
                function AsyncFunctionExpression(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                }
                return AsyncFunctionExpression;
            }();
            exports1.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = function() {
                function AwaitExpression(argument) {
                    this.type = syntax_1.Syntax.AwaitExpression;
                    this.argument = argument;
                }
                return AwaitExpression;
            }();
            exports1.AwaitExpression = AwaitExpression;
            var BinaryExpression = function() {
                function BinaryExpression(operator, left, right) {
                    var logical = operator === "||" || operator === "&&";
                    this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                }
                return BinaryExpression;
            }();
            exports1.BinaryExpression = BinaryExpression;
            var BlockStatement = function() {
                function BlockStatement(body) {
                    this.type = syntax_1.Syntax.BlockStatement;
                    this.body = body;
                }
                return BlockStatement;
            }();
            exports1.BlockStatement = BlockStatement;
            var BreakStatement = function() {
                function BreakStatement(label) {
                    this.type = syntax_1.Syntax.BreakStatement;
                    this.label = label;
                }
                return BreakStatement;
            }();
            exports1.BreakStatement = BreakStatement;
            var CallExpression = function() {
                function CallExpression(callee, args) {
                    this.type = syntax_1.Syntax.CallExpression;
                    this.callee = callee;
                    this.arguments = args;
                }
                return CallExpression;
            }();
            exports1.CallExpression = CallExpression;
            var CatchClause = function() {
                function CatchClause(param, body) {
                    this.type = syntax_1.Syntax.CatchClause;
                    this.param = param;
                    this.body = body;
                }
                return CatchClause;
            }();
            exports1.CatchClause = CatchClause;
            var ClassBody = function() {
                function ClassBody(body) {
                    this.type = syntax_1.Syntax.ClassBody;
                    this.body = body;
                }
                return ClassBody;
            }();
            exports1.ClassBody = ClassBody;
            var ClassDeclaration = function() {
                function ClassDeclaration(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassDeclaration;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                }
                return ClassDeclaration;
            }();
            exports1.ClassDeclaration = ClassDeclaration;
            var ClassExpression = function() {
                function ClassExpression(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassExpression;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                }
                return ClassExpression;
            }();
            exports1.ClassExpression = ClassExpression;
            var ComputedMemberExpression = function() {
                function ComputedMemberExpression(object, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = true;
                    this.object = object;
                    this.property = property;
                }
                return ComputedMemberExpression;
            }();
            exports1.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = function() {
                function ConditionalExpression(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.ConditionalExpression;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                }
                return ConditionalExpression;
            }();
            exports1.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = function() {
                function ContinueStatement(label) {
                    this.type = syntax_1.Syntax.ContinueStatement;
                    this.label = label;
                }
                return ContinueStatement;
            }();
            exports1.ContinueStatement = ContinueStatement;
            var DebuggerStatement = function() {
                function DebuggerStatement() {
                    this.type = syntax_1.Syntax.DebuggerStatement;
                }
                return DebuggerStatement;
            }();
            exports1.DebuggerStatement = DebuggerStatement;
            var Directive = function() {
                function Directive(expression, directive) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                    this.directive = directive;
                }
                return Directive;
            }();
            exports1.Directive = Directive;
            var DoWhileStatement = function() {
                function DoWhileStatement(body, test) {
                    this.type = syntax_1.Syntax.DoWhileStatement;
                    this.body = body;
                    this.test = test;
                }
                return DoWhileStatement;
            }();
            exports1.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = function() {
                function EmptyStatement() {
                    this.type = syntax_1.Syntax.EmptyStatement;
                }
                return EmptyStatement;
            }();
            exports1.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = function() {
                function ExportAllDeclaration(source) {
                    this.type = syntax_1.Syntax.ExportAllDeclaration;
                    this.source = source;
                }
                return ExportAllDeclaration;
            }();
            exports1.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = function() {
                function ExportDefaultDeclaration(declaration) {
                    this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                    this.declaration = declaration;
                }
                return ExportDefaultDeclaration;
            }();
            exports1.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = function() {
                function ExportNamedDeclaration(declaration, specifiers, source) {
                    this.type = syntax_1.Syntax.ExportNamedDeclaration;
                    this.declaration = declaration;
                    this.specifiers = specifiers;
                    this.source = source;
                }
                return ExportNamedDeclaration;
            }();
            exports1.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = function() {
                function ExportSpecifier(local, exported) {
                    this.type = syntax_1.Syntax.ExportSpecifier;
                    this.exported = exported;
                    this.local = local;
                }
                return ExportSpecifier;
            }();
            exports1.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = function() {
                function ExpressionStatement(expression) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                }
                return ExpressionStatement;
            }();
            exports1.ExpressionStatement = ExpressionStatement;
            var ForInStatement = function() {
                function ForInStatement(left, right, body) {
                    this.type = syntax_1.Syntax.ForInStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                    this.each = false;
                }
                return ForInStatement;
            }();
            exports1.ForInStatement = ForInStatement;
            var ForOfStatement = function() {
                function ForOfStatement(left, right, body) {
                    this.type = syntax_1.Syntax.ForOfStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                }
                return ForOfStatement;
            }();
            exports1.ForOfStatement = ForOfStatement;
            var ForStatement = function() {
                function ForStatement(init, test, update, body) {
                    this.type = syntax_1.Syntax.ForStatement;
                    this.init = init;
                    this.test = test;
                    this.update = update;
                    this.body = body;
                }
                return ForStatement;
            }();
            exports1.ForStatement = ForStatement;
            var FunctionDeclaration = function() {
                function FunctionDeclaration(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                }
                return FunctionDeclaration;
            }();
            exports1.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = function() {
                function FunctionExpression(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                }
                return FunctionExpression;
            }();
            exports1.FunctionExpression = FunctionExpression;
            var Identifier = function() {
                function Identifier(name) {
                    this.type = syntax_1.Syntax.Identifier;
                    this.name = name;
                }
                return Identifier;
            }();
            exports1.Identifier = Identifier;
            var IfStatement = function() {
                function IfStatement(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.IfStatement;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                }
                return IfStatement;
            }();
            exports1.IfStatement = IfStatement;
            var ImportDeclaration = function() {
                function ImportDeclaration(specifiers, source) {
                    this.type = syntax_1.Syntax.ImportDeclaration;
                    this.specifiers = specifiers;
                    this.source = source;
                }
                return ImportDeclaration;
            }();
            exports1.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = function() {
                function ImportDefaultSpecifier(local) {
                    this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                    this.local = local;
                }
                return ImportDefaultSpecifier;
            }();
            exports1.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = function() {
                function ImportNamespaceSpecifier(local) {
                    this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                    this.local = local;
                }
                return ImportNamespaceSpecifier;
            }();
            exports1.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = function() {
                function ImportSpecifier(local, imported) {
                    this.type = syntax_1.Syntax.ImportSpecifier;
                    this.local = local;
                    this.imported = imported;
                }
                return ImportSpecifier;
            }();
            exports1.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = function() {
                function LabeledStatement(label, body) {
                    this.type = syntax_1.Syntax.LabeledStatement;
                    this.label = label;
                    this.body = body;
                }
                return LabeledStatement;
            }();
            exports1.LabeledStatement = LabeledStatement;
            var Literal = function() {
                function Literal(value, raw) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                }
                return Literal;
            }();
            exports1.Literal = Literal;
            var MetaProperty = function() {
                function MetaProperty(meta, property) {
                    this.type = syntax_1.Syntax.MetaProperty;
                    this.meta = meta;
                    this.property = property;
                }
                return MetaProperty;
            }();
            exports1.MetaProperty = MetaProperty;
            var MethodDefinition = function() {
                function MethodDefinition(key, computed, value, kind, isStatic) {
                    this.type = syntax_1.Syntax.MethodDefinition;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.static = isStatic;
                }
                return MethodDefinition;
            }();
            exports1.MethodDefinition = MethodDefinition;
            var Module = function() {
                function Module(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "module";
                }
                return Module;
            }();
            exports1.Module = Module;
            var NewExpression = function() {
                function NewExpression(callee, args) {
                    this.type = syntax_1.Syntax.NewExpression;
                    this.callee = callee;
                    this.arguments = args;
                }
                return NewExpression;
            }();
            exports1.NewExpression = NewExpression;
            var ObjectExpression = function() {
                function ObjectExpression(properties) {
                    this.type = syntax_1.Syntax.ObjectExpression;
                    this.properties = properties;
                }
                return ObjectExpression;
            }();
            exports1.ObjectExpression = ObjectExpression;
            var ObjectPattern = function() {
                function ObjectPattern(properties) {
                    this.type = syntax_1.Syntax.ObjectPattern;
                    this.properties = properties;
                }
                return ObjectPattern;
            }();
            exports1.ObjectPattern = ObjectPattern;
            var Property = function() {
                function Property(kind, key, computed, value, method, shorthand) {
                    this.type = syntax_1.Syntax.Property;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.method = method;
                    this.shorthand = shorthand;
                }
                return Property;
            }();
            exports1.Property = Property;
            var RegexLiteral = function() {
                function RegexLiteral(value, raw, pattern, flags) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                    this.regex = {
                        pattern: pattern,
                        flags: flags
                    };
                }
                return RegexLiteral;
            }();
            exports1.RegexLiteral = RegexLiteral;
            var RestElement = function() {
                function RestElement(argument) {
                    this.type = syntax_1.Syntax.RestElement;
                    this.argument = argument;
                }
                return RestElement;
            }();
            exports1.RestElement = RestElement;
            var ReturnStatement = function() {
                function ReturnStatement(argument) {
                    this.type = syntax_1.Syntax.ReturnStatement;
                    this.argument = argument;
                }
                return ReturnStatement;
            }();
            exports1.ReturnStatement = ReturnStatement;
            var Script = function() {
                function Script(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "script";
                }
                return Script;
            }();
            exports1.Script = Script;
            var SequenceExpression = function() {
                function SequenceExpression(expressions) {
                    this.type = syntax_1.Syntax.SequenceExpression;
                    this.expressions = expressions;
                }
                return SequenceExpression;
            }();
            exports1.SequenceExpression = SequenceExpression;
            var SpreadElement = function() {
                function SpreadElement(argument) {
                    this.type = syntax_1.Syntax.SpreadElement;
                    this.argument = argument;
                }
                return SpreadElement;
            }();
            exports1.SpreadElement = SpreadElement;
            var StaticMemberExpression = function() {
                function StaticMemberExpression(object, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = false;
                    this.object = object;
                    this.property = property;
                }
                return StaticMemberExpression;
            }();
            exports1.StaticMemberExpression = StaticMemberExpression;
            var Super = function() {
                function Super() {
                    this.type = syntax_1.Syntax.Super;
                }
                return Super;
            }();
            exports1.Super = Super;
            var SwitchCase = function() {
                function SwitchCase(test, consequent) {
                    this.type = syntax_1.Syntax.SwitchCase;
                    this.test = test;
                    this.consequent = consequent;
                }
                return SwitchCase;
            }();
            exports1.SwitchCase = SwitchCase;
            var SwitchStatement = function() {
                function SwitchStatement(discriminant, cases) {
                    this.type = syntax_1.Syntax.SwitchStatement;
                    this.discriminant = discriminant;
                    this.cases = cases;
                }
                return SwitchStatement;
            }();
            exports1.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = function() {
                function TaggedTemplateExpression(tag, quasi) {
                    this.type = syntax_1.Syntax.TaggedTemplateExpression;
                    this.tag = tag;
                    this.quasi = quasi;
                }
                return TaggedTemplateExpression;
            }();
            exports1.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = function() {
                function TemplateElement(value, tail) {
                    this.type = syntax_1.Syntax.TemplateElement;
                    this.value = value;
                    this.tail = tail;
                }
                return TemplateElement;
            }();
            exports1.TemplateElement = TemplateElement;
            var TemplateLiteral = function() {
                function TemplateLiteral(quasis, expressions) {
                    this.type = syntax_1.Syntax.TemplateLiteral;
                    this.quasis = quasis;
                    this.expressions = expressions;
                }
                return TemplateLiteral;
            }();
            exports1.TemplateLiteral = TemplateLiteral;
            var ThisExpression = function() {
                function ThisExpression() {
                    this.type = syntax_1.Syntax.ThisExpression;
                }
                return ThisExpression;
            }();
            exports1.ThisExpression = ThisExpression;
            var ThrowStatement = function() {
                function ThrowStatement(argument) {
                    this.type = syntax_1.Syntax.ThrowStatement;
                    this.argument = argument;
                }
                return ThrowStatement;
            }();
            exports1.ThrowStatement = ThrowStatement;
            var TryStatement = function() {
                function TryStatement(block, handler, finalizer) {
                    this.type = syntax_1.Syntax.TryStatement;
                    this.block = block;
                    this.handler = handler;
                    this.finalizer = finalizer;
                }
                return TryStatement;
            }();
            exports1.TryStatement = TryStatement;
            var UnaryExpression = function() {
                function UnaryExpression(operator, argument) {
                    this.type = syntax_1.Syntax.UnaryExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = true;
                }
                return UnaryExpression;
            }();
            exports1.UnaryExpression = UnaryExpression;
            var UpdateExpression = function() {
                function UpdateExpression(operator, argument, prefix) {
                    this.type = syntax_1.Syntax.UpdateExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = prefix;
                }
                return UpdateExpression;
            }();
            exports1.UpdateExpression = UpdateExpression;
            var VariableDeclaration = function() {
                function VariableDeclaration(declarations, kind) {
                    this.type = syntax_1.Syntax.VariableDeclaration;
                    this.declarations = declarations;
                    this.kind = kind;
                }
                return VariableDeclaration;
            }();
            exports1.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = function() {
                function VariableDeclarator(id, init) {
                    this.type = syntax_1.Syntax.VariableDeclarator;
                    this.id = id;
                    this.init = init;
                }
                return VariableDeclarator;
            }();
            exports1.VariableDeclarator = VariableDeclarator;
            var WhileStatement = function() {
                function WhileStatement(test, body) {
                    this.type = syntax_1.Syntax.WhileStatement;
                    this.test = test;
                    this.body = body;
                }
                return WhileStatement;
            }();
            exports1.WhileStatement = WhileStatement;
            var WithStatement = function() {
                function WithStatement(object, body) {
                    this.type = syntax_1.Syntax.WithStatement;
                    this.object = object;
                    this.body = body;
                }
                return WithStatement;
            }();
            exports1.WithStatement = WithStatement;
            var YieldExpression = function() {
                function YieldExpression(argument, delegate) {
                    this.type = syntax_1.Syntax.YieldExpression;
                    this.argument = argument;
                    this.delegate = delegate;
                }
                return YieldExpression;
            }();
            exports1.YieldExpression = YieldExpression;
        /***/ },
        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_99358__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var assert_1 = __nested_webpack_require_99358__(9);
            var error_handler_1 = __nested_webpack_require_99358__(10);
            var messages_1 = __nested_webpack_require_99358__(11);
            var Node = __nested_webpack_require_99358__(7);
            var scanner_1 = __nested_webpack_require_99358__(12);
            var syntax_1 = __nested_webpack_require_99358__(2);
            var token_1 = __nested_webpack_require_99358__(13);
            var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
            var Parser = function() {
                function Parser(code, options, delegate) {
                    if (options === void 0) {
                        options = {};
                    }
                    this.config = {
                        range: typeof options.range === "boolean" && options.range,
                        loc: typeof options.loc === "boolean" && options.loc,
                        source: null,
                        tokens: typeof options.tokens === "boolean" && options.tokens,
                        comment: typeof options.comment === "boolean" && options.comment,
                        tolerant: typeof options.tolerant === "boolean" && options.tolerant
                    };
                    if (this.config.loc && options.source && options.source !== null) {
                        this.config.source = String(options.source);
                    }
                    this.delegate = delegate;
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = this.config.tolerant;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = this.config.comment;
                    this.operatorPrecedence = {
                        ")": 0,
                        ";": 0,
                        ",": 0,
                        "=": 0,
                        "]": 0,
                        "||": 1,
                        "&&": 2,
                        "|": 3,
                        "^": 4,
                        "&": 5,
                        "==": 6,
                        "!=": 6,
                        "===": 6,
                        "!==": 6,
                        "<": 7,
                        ">": 7,
                        "<=": 7,
                        ">=": 7,
                        "<<": 8,
                        ">>": 8,
                        ">>>": 8,
                        "+": 9,
                        "-": 9,
                        "*": 11,
                        "/": 11,
                        "%": 11
                    };
                    this.lookahead = {
                        type: 2 /* EOF */ ,
                        value: "",
                        lineNumber: this.scanner.lineNumber,
                        lineStart: 0,
                        start: 0,
                        end: 0
                    };
                    this.hasLineTerminator = false;
                    this.context = {
                        isModule: false,
                        await: false,
                        allowIn: true,
                        allowStrictDirective: true,
                        allowYield: true,
                        firstCoverInitializedNameError: null,
                        isAssignmentTarget: false,
                        isBindingElement: false,
                        inFunctionBody: false,
                        inIteration: false,
                        inSwitch: false,
                        labelSet: {},
                        strict: false
                    };
                    this.tokens = [];
                    this.startMarker = {
                        index: 0,
                        line: this.scanner.lineNumber,
                        column: 0
                    };
                    this.lastMarker = {
                        index: 0,
                        line: this.scanner.lineNumber,
                        column: 0
                    };
                    this.nextToken();
                    this.lastMarker = {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                }
                Parser.prototype.throwError = function(messageFormat) {
                    var values = [];
                    for(var _i = 1; _i < arguments.length; _i++){
                        values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                        assert_1.assert(idx < args.length, "Message reference must be in range");
                        return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.lastMarker.line;
                    var column = this.lastMarker.column + 1;
                    throw this.errorHandler.createError(index, line, column, msg);
                };
                Parser.prototype.tolerateError = function(messageFormat) {
                    var values = [];
                    for(var _i = 1; _i < arguments.length; _i++){
                        values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                        assert_1.assert(idx < args.length, "Message reference must be in range");
                        return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.scanner.lineNumber;
                    var column = this.lastMarker.column + 1;
                    this.errorHandler.tolerateError(index, line, column, msg);
                };
                // Throw an exception because of the token.
                Parser.prototype.unexpectedTokenError = function(token, message) {
                    var msg = message || messages_1.Messages.UnexpectedToken;
                    var value;
                    if (token) {
                        if (!message) {
                            msg = token.type === 2 /* EOF */  ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */  ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */  ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */  ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */  ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                            if (token.type === 4 /* Keyword */ ) {
                                if (this.scanner.isFutureReservedWord(token.value)) {
                                    msg = messages_1.Messages.UnexpectedReserved;
                                } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                                    msg = messages_1.Messages.StrictReservedWord;
                                }
                            }
                        }
                        value = token.value;
                    } else {
                        value = "ILLEGAL";
                    }
                    msg = msg.replace("%0", value);
                    if (token && typeof token.lineNumber === "number") {
                        var index = token.start;
                        var line = token.lineNumber;
                        var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                        var column = token.start - lastMarkerLineStart + 1;
                        return this.errorHandler.createError(index, line, column, msg);
                    } else {
                        var index = this.lastMarker.index;
                        var line = this.lastMarker.line;
                        var column = this.lastMarker.column + 1;
                        return this.errorHandler.createError(index, line, column, msg);
                    }
                };
                Parser.prototype.throwUnexpectedToken = function(token, message) {
                    throw this.unexpectedTokenError(token, message);
                };
                Parser.prototype.tolerateUnexpectedToken = function(token, message) {
                    this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
                };
                Parser.prototype.collectComments = function() {
                    if (!this.config.comment) {
                        this.scanner.scanComments();
                    } else {
                        var comments = this.scanner.scanComments();
                        if (comments.length > 0 && this.delegate) {
                            for(var i = 0; i < comments.length; ++i){
                                var e = comments[i];
                                var node = void 0;
                                node = {
                                    type: e.multiLine ? "BlockComment" : "LineComment",
                                    value: this.scanner.source.slice(e.slice[0], e.slice[1])
                                };
                                if (this.config.range) {
                                    node.range = e.range;
                                }
                                if (this.config.loc) {
                                    node.loc = e.loc;
                                }
                                var metadata = {
                                    start: {
                                        line: e.loc.start.line,
                                        column: e.loc.start.column,
                                        offset: e.range[0]
                                    },
                                    end: {
                                        line: e.loc.end.line,
                                        column: e.loc.end.column,
                                        offset: e.range[1]
                                    }
                                };
                                this.delegate(node, metadata);
                            }
                        }
                    }
                };
                // From internal representation to an external structure
                Parser.prototype.getTokenRaw = function(token) {
                    return this.scanner.source.slice(token.start, token.end);
                };
                Parser.prototype.convertToken = function(token) {
                    var t = {
                        type: token_1.TokenName[token.type],
                        value: this.getTokenRaw(token)
                    };
                    if (this.config.range) {
                        t.range = [
                            token.start,
                            token.end
                        ];
                    }
                    if (this.config.loc) {
                        t.loc = {
                            start: {
                                line: this.startMarker.line,
                                column: this.startMarker.column
                            },
                            end: {
                                line: this.scanner.lineNumber,
                                column: this.scanner.index - this.scanner.lineStart
                            }
                        };
                    }
                    if (token.type === 9 /* RegularExpression */ ) {
                        var pattern = token.pattern;
                        var flags = token.flags;
                        t.regex = {
                            pattern: pattern,
                            flags: flags
                        };
                    }
                    return t;
                };
                Parser.prototype.nextToken = function() {
                    var token = this.lookahead;
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    this.collectComments();
                    if (this.scanner.index !== this.startMarker.index) {
                        this.startMarker.index = this.scanner.index;
                        this.startMarker.line = this.scanner.lineNumber;
                        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    }
                    var next = this.scanner.lex();
                    this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                    if (next && this.context.strict && next.type === 3 /* Identifier */ ) {
                        if (this.scanner.isStrictModeReservedWord(next.value)) {
                            next.type = 4 /* Keyword */ ;
                        }
                    }
                    this.lookahead = next;
                    if (this.config.tokens && next.type !== 2 /* EOF */ ) {
                        this.tokens.push(this.convertToken(next));
                    }
                    return token;
                };
                Parser.prototype.nextRegexToken = function() {
                    this.collectComments();
                    var token = this.scanner.scanRegExp();
                    if (this.config.tokens) {
                        // Pop the previous token, '/' or '/='
                        // This is added from the lookahead token.
                        this.tokens.pop();
                        this.tokens.push(this.convertToken(token));
                    }
                    // Prime the next lookahead.
                    this.lookahead = token;
                    this.nextToken();
                    return token;
                };
                Parser.prototype.createNode = function() {
                    return {
                        index: this.startMarker.index,
                        line: this.startMarker.line,
                        column: this.startMarker.column
                    };
                };
                Parser.prototype.startNode = function(token, lastLineStart) {
                    if (lastLineStart === void 0) {
                        lastLineStart = 0;
                    }
                    var column = token.start - token.lineStart;
                    var line = token.lineNumber;
                    if (column < 0) {
                        column += lastLineStart;
                        line--;
                    }
                    return {
                        index: token.start,
                        line: line,
                        column: column
                    };
                };
                Parser.prototype.finalize = function(marker, node) {
                    if (this.config.range) {
                        node.range = [
                            marker.index,
                            this.lastMarker.index
                        ];
                    }
                    if (this.config.loc) {
                        node.loc = {
                            start: {
                                line: marker.line,
                                column: marker.column
                            },
                            end: {
                                line: this.lastMarker.line,
                                column: this.lastMarker.column
                            }
                        };
                        if (this.config.source) {
                            node.loc.source = this.config.source;
                        }
                    }
                    if (this.delegate) {
                        var metadata = {
                            start: {
                                line: marker.line,
                                column: marker.column,
                                offset: marker.index
                            },
                            end: {
                                line: this.lastMarker.line,
                                column: this.lastMarker.column,
                                offset: this.lastMarker.index
                            }
                        };
                        this.delegate(node, metadata);
                    }
                    return node;
                };
                // Expect the next token to match the specified punctuator.
                // If not, an exception will be thrown.
                Parser.prototype.expect = function(value) {
                    var token = this.nextToken();
                    if (token.type !== 7 /* Punctuator */  || token.value !== value) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
                Parser.prototype.expectCommaSeparator = function() {
                    if (this.config.tolerant) {
                        var token = this.lookahead;
                        if (token.type === 7 /* Punctuator */  && token.value === ",") {
                            this.nextToken();
                        } else if (token.type === 7 /* Punctuator */  && token.value === ";") {
                            this.nextToken();
                            this.tolerateUnexpectedToken(token);
                        } else {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                        }
                    } else {
                        this.expect(",");
                    }
                };
                // Expect the next token to match the specified keyword.
                // If not, an exception will be thrown.
                Parser.prototype.expectKeyword = function(keyword) {
                    var token = this.nextToken();
                    if (token.type !== 4 /* Keyword */  || token.value !== keyword) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Return true if the next token matches the specified punctuator.
                Parser.prototype.match = function(value) {
                    return this.lookahead.type === 7 /* Punctuator */  && this.lookahead.value === value;
                };
                // Return true if the next token matches the specified keyword
                Parser.prototype.matchKeyword = function(keyword) {
                    return this.lookahead.type === 4 /* Keyword */  && this.lookahead.value === keyword;
                };
                // Return true if the next token matches the specified contextual keyword
                // (where an identifier is sometimes a keyword depending on the context)
                Parser.prototype.matchContextualKeyword = function(keyword) {
                    return this.lookahead.type === 3 /* Identifier */  && this.lookahead.value === keyword;
                };
                // Return true if the next token is an assignment operator
                Parser.prototype.matchAssign = function() {
                    if (this.lookahead.type !== 7 /* Punctuator */ ) {
                        return false;
                    }
                    var op = this.lookahead.value;
                    return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
                };
                // Cover grammar support.
                //
                // When an assignment expression position starts with an left parenthesis, the determination of the type
                // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
                // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
                //
                // There are three productions that can be parsed in a parentheses pair that needs to be determined
                // after the outermost pair is closed. They are:
                //
                //   1. AssignmentExpression
                //   2. BindingElements
                //   3. AssignmentTargets
                //
                // In order to avoid exponential backtracking, we use two flags to denote if the production can be
                // binding element or assignment target.
                //
                // The three productions have the relationship:
                //
                //   BindingElements  AssignmentTargets  AssignmentExpression
                //
                // with a single exception that CoverInitializedName when used directly in an Expression, generates
                // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
                // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
                //
                // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
                // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
                // the CoverInitializedName check is conducted.
                //
                // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
                // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
                // pattern. The CoverInitializedName check is deferred.
                Parser.prototype.isolateCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    if (this.context.firstCoverInitializedNameError !== null) {
                        this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                    }
                    this.context.isBindingElement = previousIsBindingElement;
                    this.context.isAssignmentTarget = previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                    return result;
                };
                Parser.prototype.inheritCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                    this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                    return result;
                };
                Parser.prototype.consumeSemicolon = function() {
                    if (this.match(";")) {
                        this.nextToken();
                    } else if (!this.hasLineTerminator) {
                        if (this.lookahead.type !== 2 /* EOF */  && !this.match("}")) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        this.lastMarker.index = this.startMarker.index;
                        this.lastMarker.line = this.startMarker.line;
                        this.lastMarker.column = this.startMarker.column;
                    }
                };
                // https://tc39.github.io/ecma262/#sec-primary-expression
                Parser.prototype.parsePrimaryExpression = function() {
                    var node = this.createNode();
                    var expr;
                    var token, raw;
                    switch(this.lookahead.type){
                        case 3 /* Identifier */ :
                            if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                                this.tolerateUnexpectedToken(this.lookahead);
                            }
                            expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                            break;
                        case 6 /* NumericLiteral */ :
                        case 8 /* StringLiteral */ :
                            if (this.context.strict && this.lookahead.octal) {
                                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                            }
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(token.value, raw));
                            break;
                        case 1 /* BooleanLiteral */ :
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                            break;
                        case 5 /* NullLiteral */ :
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(null, raw));
                            break;
                        case 10 /* Template */ :
                            expr = this.parseTemplateLiteral();
                            break;
                        case 7 /* Punctuator */ :
                            switch(this.lookahead.value){
                                case "(":
                                    this.context.isBindingElement = false;
                                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                                    break;
                                case "[":
                                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                                    break;
                                case "{":
                                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                                    break;
                                case "/":
                                case "/=":
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                    this.scanner.index = this.startMarker.index;
                                    token = this.nextRegexToken();
                                    raw = this.getTokenRaw(token);
                                    expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                                    break;
                                default:
                                    expr = this.throwUnexpectedToken(this.nextToken());
                            }
                            break;
                        case 4 /* Keyword */ :
                            if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                                expr = this.parseIdentifierName();
                            } else if (!this.context.strict && this.matchKeyword("let")) {
                                expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                            } else {
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                if (this.matchKeyword("function")) {
                                    expr = this.parseFunctionExpression();
                                } else if (this.matchKeyword("this")) {
                                    this.nextToken();
                                    expr = this.finalize(node, new Node.ThisExpression());
                                } else if (this.matchKeyword("class")) {
                                    expr = this.parseClassExpression();
                                } else {
                                    expr = this.throwUnexpectedToken(this.nextToken());
                                }
                            }
                            break;
                        default:
                            expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-array-initializer
                Parser.prototype.parseSpreadElement = function() {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    return this.finalize(node, new Node.SpreadElement(arg));
                };
                Parser.prototype.parseArrayInitializer = function() {
                    var node = this.createNode();
                    var elements = [];
                    this.expect("[");
                    while(!this.match("]")){
                        if (this.match(",")) {
                            this.nextToken();
                            elements.push(null);
                        } else if (this.match("...")) {
                            var element = this.parseSpreadElement();
                            if (!this.match("]")) {
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                this.expect(",");
                            }
                            elements.push(element);
                        } else {
                            elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                            if (!this.match("]")) {
                                this.expect(",");
                            }
                        }
                    }
                    this.expect("]");
                    return this.finalize(node, new Node.ArrayExpression(elements));
                };
                // https://tc39.github.io/ecma262/#sec-object-initializer
                Parser.prototype.parsePropertyMethod = function(params) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = params.simple;
                    var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                    if (this.context.strict && params.firstRestricted) {
                        this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                    }
                    if (this.context.strict && params.stricted) {
                        this.tolerateUnexpectedToken(params.stricted, params.message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    return body;
                };
                Parser.prototype.parsePropertyMethodFunction = function() {
                    var isGenerator = false;
                    var node = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
                };
                Parser.prototype.parsePropertyMethodAsyncFunction = function() {
                    var node = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = false;
                    this.context.await = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                    return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
                };
                Parser.prototype.parseObjectPropertyKey = function() {
                    var node = this.createNode();
                    var token = this.nextToken();
                    var key;
                    switch(token.type){
                        case 8 /* StringLiteral */ :
                        case 6 /* NumericLiteral */ :
                            if (this.context.strict && token.octal) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                            }
                            var raw = this.getTokenRaw(token);
                            key = this.finalize(node, new Node.Literal(token.value, raw));
                            break;
                        case 3 /* Identifier */ :
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 4 /* Keyword */ :
                            key = this.finalize(node, new Node.Identifier(token.value));
                            break;
                        case 7 /* Punctuator */ :
                            if (token.value === "[") {
                                key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                this.expect("]");
                            } else {
                                key = this.throwUnexpectedToken(token);
                            }
                            break;
                        default:
                            key = this.throwUnexpectedToken(token);
                    }
                    return key;
                };
                Parser.prototype.isPropertyKey = function(key, value) {
                    return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
                };
                Parser.prototype.parseObjectProperty = function(hasProto) {
                    var node = this.createNode();
                    var token = this.lookahead;
                    var kind;
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var shorthand = false;
                    var isAsync = false;
                    if (token.type === 3 /* Identifier */ ) {
                        var id = token.value;
                        this.nextToken();
                        computed = this.match("[");
                        isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                        key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                    } else if (this.match("*")) {
                        this.nextToken();
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 /* Identifier */  && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                        kind = "get";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.context.allowYield = false;
                        value = this.parseGetterMethod();
                    } else if (token.type === 3 /* Identifier */  && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                        kind = "set";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseSetterMethod();
                    } else if (token.type === 7 /* Punctuator */  && token.value === "*" && lookaheadPropertyKey) {
                        kind = "init";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseGeneratorMethod();
                        method = true;
                    } else {
                        if (!key) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        kind = "init";
                        if (this.match(":") && !isAsync) {
                            if (!computed && this.isPropertyKey(key, "__proto__")) {
                                if (hasProto.value) {
                                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                                }
                                hasProto.value = true;
                            }
                            this.nextToken();
                            value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        } else if (this.match("(")) {
                            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                            method = true;
                        } else if (token.type === 3 /* Identifier */ ) {
                            var id = this.finalize(node, new Node.Identifier(token.value));
                            if (this.match("=")) {
                                this.context.firstCoverInitializedNameError = this.lookahead;
                                this.nextToken();
                                shorthand = true;
                                var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                value = this.finalize(node, new Node.AssignmentPattern(id, init));
                            } else {
                                shorthand = true;
                                value = id;
                            }
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                    }
                    return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
                };
                Parser.prototype.parseObjectInitializer = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var properties = [];
                    var hasProto = {
                        value: false
                    };
                    while(!this.match("}")){
                        properties.push(this.parseObjectProperty(hasProto));
                        if (!this.match("}")) {
                            this.expectCommaSeparator();
                        }
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.ObjectExpression(properties));
                };
                // https://tc39.github.io/ecma262/#sec-template-literals
                Parser.prototype.parseTemplateHead = function() {
                    assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                    var node = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node, new Node.TemplateElement({
                        raw: raw,
                        cooked: cooked
                    }, token.tail));
                };
                Parser.prototype.parseTemplateElement = function() {
                    if (this.lookahead.type !== 10 /* Template */ ) {
                        this.throwUnexpectedToken();
                    }
                    var node = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node, new Node.TemplateElement({
                        raw: raw,
                        cooked: cooked
                    }, token.tail));
                };
                Parser.prototype.parseTemplateLiteral = function() {
                    var node = this.createNode();
                    var expressions = [];
                    var quasis = [];
                    var quasi = this.parseTemplateHead();
                    quasis.push(quasi);
                    while(!quasi.tail){
                        expressions.push(this.parseExpression());
                        quasi = this.parseTemplateElement();
                        quasis.push(quasi);
                    }
                    return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
                };
                // https://tc39.github.io/ecma262/#sec-grouping-operator
                Parser.prototype.reinterpretExpressionAsPattern = function(expr) {
                    switch(expr.type){
                        case syntax_1.Syntax.Identifier:
                        case syntax_1.Syntax.MemberExpression:
                        case syntax_1.Syntax.RestElement:
                        case syntax_1.Syntax.AssignmentPattern:
                            break;
                        case syntax_1.Syntax.SpreadElement:
                            expr.type = syntax_1.Syntax.RestElement;
                            this.reinterpretExpressionAsPattern(expr.argument);
                            break;
                        case syntax_1.Syntax.ArrayExpression:
                            expr.type = syntax_1.Syntax.ArrayPattern;
                            for(var i = 0; i < expr.elements.length; i++){
                                if (expr.elements[i] !== null) {
                                    this.reinterpretExpressionAsPattern(expr.elements[i]);
                                }
                            }
                            break;
                        case syntax_1.Syntax.ObjectExpression:
                            expr.type = syntax_1.Syntax.ObjectPattern;
                            for(var i = 0; i < expr.properties.length; i++){
                                this.reinterpretExpressionAsPattern(expr.properties[i].value);
                            }
                            break;
                        case syntax_1.Syntax.AssignmentExpression:
                            expr.type = syntax_1.Syntax.AssignmentPattern;
                            delete expr.operator;
                            this.reinterpretExpressionAsPattern(expr.left);
                            break;
                        default:
                            break;
                    }
                };
                Parser.prototype.parseGroupExpression = function() {
                    var expr;
                    this.expect("(");
                    if (this.match(")")) {
                        this.nextToken();
                        if (!this.match("=>")) {
                            this.expect("=>");
                        }
                        expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [],
                            async: false
                        };
                    } else {
                        var startToken = this.lookahead;
                        var params = [];
                        if (this.match("...")) {
                            expr = this.parseRestElement(params);
                            this.expect(")");
                            if (!this.match("=>")) {
                                this.expect("=>");
                            }
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: [
                                    expr
                                ],
                                async: false
                            };
                        } else {
                            var arrow = false;
                            this.context.isBindingElement = true;
                            expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                            if (this.match(",")) {
                                var expressions = [];
                                this.context.isAssignmentTarget = false;
                                expressions.push(expr);
                                while(this.lookahead.type !== 2 /* EOF */ ){
                                    if (!this.match(",")) {
                                        break;
                                    }
                                    this.nextToken();
                                    if (this.match(")")) {
                                        this.nextToken();
                                        for(var i = 0; i < expressions.length; i++){
                                            this.reinterpretExpressionAsPattern(expressions[i]);
                                        }
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: expressions,
                                            async: false
                                        };
                                    } else if (this.match("...")) {
                                        if (!this.context.isBindingElement) {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                        expressions.push(this.parseRestElement(params));
                                        this.expect(")");
                                        if (!this.match("=>")) {
                                            this.expect("=>");
                                        }
                                        this.context.isBindingElement = false;
                                        for(var i = 0; i < expressions.length; i++){
                                            this.reinterpretExpressionAsPattern(expressions[i]);
                                        }
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: expressions,
                                            async: false
                                        };
                                    } else {
                                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                                    }
                                    if (arrow) {
                                        break;
                                    }
                                }
                                if (!arrow) {
                                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                                }
                            }
                            if (!arrow) {
                                this.expect(")");
                                if (this.match("=>")) {
                                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: [
                                                expr
                                            ],
                                            async: false
                                        };
                                    }
                                    if (!arrow) {
                                        if (!this.context.isBindingElement) {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                                            for(var i = 0; i < expr.expressions.length; i++){
                                                this.reinterpretExpressionAsPattern(expr.expressions[i]);
                                            }
                                        } else {
                                            this.reinterpretExpressionAsPattern(expr);
                                        }
                                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [
                                            expr
                                        ];
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: parameters,
                                            async: false
                                        };
                                    }
                                }
                                this.context.isBindingElement = false;
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
                Parser.prototype.parseArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                        while(true){
                            var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                            args.push(expr);
                            if (this.match(")")) {
                                break;
                            }
                            this.expectCommaSeparator();
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return args;
                };
                Parser.prototype.isIdentifierName = function(token) {
                    return token.type === 3 /* Identifier */  || token.type === 4 /* Keyword */  || token.type === 1 /* BooleanLiteral */  || token.type === 5 /* NullLiteral */ ;
                };
                Parser.prototype.parseIdentifierName = function() {
                    var node = this.createNode();
                    var token = this.nextToken();
                    if (!this.isIdentifierName(token)) {
                        this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node, new Node.Identifier(token.value));
                };
                Parser.prototype.parseNewExpression = function() {
                    var node = this.createNode();
                    var id = this.parseIdentifierName();
                    assert_1.assert(id.name === "new", "New expression must start with `new`");
                    var expr;
                    if (this.match(".")) {
                        this.nextToken();
                        if (this.lookahead.type === 3 /* Identifier */  && this.context.inFunctionBody && this.lookahead.value === "target") {
                            var property = this.parseIdentifierName();
                            expr = new Node.MetaProperty(id, property);
                        } else {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                    } else {
                        var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                        var args = this.match("(") ? this.parseArguments() : [];
                        expr = new Node.NewExpression(callee, args);
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    }
                    return this.finalize(node, expr);
                };
                Parser.prototype.parseAsyncArgument = function() {
                    var arg = this.parseAssignmentExpression();
                    this.context.firstCoverInitializedNameError = null;
                    return arg;
                };
                Parser.prototype.parseAsyncArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                        while(true){
                            var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                            args.push(expr);
                            if (this.match(")")) {
                                break;
                            }
                            this.expectCommaSeparator();
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return args;
                };
                Parser.prototype.parseLeftHandSideExpressionAllowCall = function() {
                    var startToken = this.lookahead;
                    var maybeAsync = this.matchContextualKeyword("async");
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    var expr;
                    if (this.matchKeyword("super") && this.context.inFunctionBody) {
                        expr = this.createNode();
                        this.nextToken();
                        expr = this.finalize(expr, new Node.Super());
                        if (!this.match("(") && !this.match(".") && !this.match("[")) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                    } else {
                        expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    }
                    while(true){
                        if (this.match(".")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect(".");
                            var property = this.parseIdentifierName();
                            expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                        } else if (this.match("(")) {
                            var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = false;
                            var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                            expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                            if (asyncArrow && this.match("=>")) {
                                for(var i = 0; i < args.length; ++i){
                                    this.reinterpretExpressionAsPattern(args[i]);
                                }
                                expr = {
                                    type: ArrowParameterPlaceHolder,
                                    params: args,
                                    async: true
                                };
                            }
                        } else if (this.match("[")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect("[");
                            var property = this.isolateCoverGrammar(this.parseExpression);
                            this.expect("]");
                            expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                        } else if (this.lookahead.type === 10 /* Template */  && this.lookahead.head) {
                            var quasi = this.parseTemplateLiteral();
                            expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                        } else {
                            break;
                        }
                    }
                    this.context.allowIn = previousAllowIn;
                    return expr;
                };
                Parser.prototype.parseSuper = function() {
                    var node = this.createNode();
                    this.expectKeyword("super");
                    if (!this.match("[") && !this.match(".")) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    return this.finalize(node, new Node.Super());
                };
                Parser.prototype.parseLeftHandSideExpression = function() {
                    assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                    var node = this.startNode(this.lookahead);
                    var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    while(true){
                        if (this.match("[")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect("[");
                            var property = this.isolateCoverGrammar(this.parseExpression);
                            this.expect("]");
                            expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                        } else if (this.match(".")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect(".");
                            var property = this.parseIdentifierName();
                            expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                        } else if (this.lookahead.type === 10 /* Template */  && this.lookahead.head) {
                            var quasi = this.parseTemplateLiteral();
                            expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                        } else {
                            break;
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-update-expressions
                Parser.prototype.parseUpdateExpression = function() {
                    var expr;
                    var startToken = this.lookahead;
                    if (this.match("++") || this.match("--")) {
                        var node = this.startNode(startToken);
                        var token = this.nextToken();
                        expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                        if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                            this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                        }
                        if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                        }
                        var prefix = true;
                        expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    } else {
                        expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                        if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */ ) {
                            if (this.match("++") || this.match("--")) {
                                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                                }
                                if (!this.context.isAssignmentTarget) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                                }
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                var operator = this.nextToken().value;
                                var prefix = false;
                                expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-unary-operators
                Parser.prototype.parseAwaitExpression = function() {
                    var node = this.createNode();
                    this.nextToken();
                    var argument = this.parseUnaryExpression();
                    return this.finalize(node, new Node.AwaitExpression(argument));
                };
                Parser.prototype.parseUnaryExpression = function() {
                    var expr;
                    if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                        var node = this.startNode(this.lookahead);
                        var token = this.nextToken();
                        expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                        expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                        if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                            this.tolerateError(messages_1.Messages.StrictDelete);
                        }
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    } else if (this.context.await && this.matchContextualKeyword("await")) {
                        expr = this.parseAwaitExpression();
                    } else {
                        expr = this.parseUpdateExpression();
                    }
                    return expr;
                };
                Parser.prototype.parseExponentiationExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                    if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                        this.nextToken();
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var left = expr;
                        var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                        expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-exp-operator
                // https://tc39.github.io/ecma262/#sec-multiplicative-operators
                // https://tc39.github.io/ecma262/#sec-additive-operators
                // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
                // https://tc39.github.io/ecma262/#sec-relational-operators
                // https://tc39.github.io/ecma262/#sec-equality-operators
                // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
                // https://tc39.github.io/ecma262/#sec-binary-logical-operators
                Parser.prototype.binaryPrecedence = function(token) {
                    var op = token.value;
                    var precedence;
                    if (token.type === 7 /* Punctuator */ ) {
                        precedence = this.operatorPrecedence[op] || 0;
                    } else if (token.type === 4 /* Keyword */ ) {
                        precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                    } else {
                        precedence = 0;
                    }
                    return precedence;
                };
                Parser.prototype.parseBinaryExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                    var token = this.lookahead;
                    var prec = this.binaryPrecedence(token);
                    if (prec > 0) {
                        this.nextToken();
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var markers = [
                            startToken,
                            this.lookahead
                        ];
                        var left = expr;
                        var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                        var stack = [
                            left,
                            token.value,
                            right
                        ];
                        var precedences = [
                            prec
                        ];
                        while(true){
                            prec = this.binaryPrecedence(this.lookahead);
                            if (prec <= 0) {
                                break;
                            }
                            // Reduce: make a binary expression from the three topmost entries.
                            while(stack.length > 2 && prec <= precedences[precedences.length - 1]){
                                right = stack.pop();
                                var operator = stack.pop();
                                precedences.pop();
                                left = stack.pop();
                                markers.pop();
                                var node = this.startNode(markers[markers.length - 1]);
                                stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                            }
                            // Shift.
                            stack.push(this.nextToken().value);
                            precedences.push(prec);
                            markers.push(this.lookahead);
                            stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                        }
                        // Final reduce to clean-up the stack.
                        var i = stack.length - 1;
                        expr = stack[i];
                        var lastMarker = markers.pop();
                        while(i > 1){
                            var marker = markers.pop();
                            var lastLineStart = lastMarker && lastMarker.lineStart;
                            var node = this.startNode(marker, lastLineStart);
                            var operator = stack[i - 1];
                            expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                            i -= 2;
                            lastMarker = marker;
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-conditional-operator
                Parser.prototype.parseConditionalExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                    if (this.match("?")) {
                        this.nextToken();
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowIn = previousAllowIn;
                        this.expect(":");
                        var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-assignment-operators
                Parser.prototype.checkPatternParam = function(options, param) {
                    switch(param.type){
                        case syntax_1.Syntax.Identifier:
                            this.validateParam(options, param, param.name);
                            break;
                        case syntax_1.Syntax.RestElement:
                            this.checkPatternParam(options, param.argument);
                            break;
                        case syntax_1.Syntax.AssignmentPattern:
                            this.checkPatternParam(options, param.left);
                            break;
                        case syntax_1.Syntax.ArrayPattern:
                            for(var i = 0; i < param.elements.length; i++){
                                if (param.elements[i] !== null) {
                                    this.checkPatternParam(options, param.elements[i]);
                                }
                            }
                            break;
                        case syntax_1.Syntax.ObjectPattern:
                            for(var i = 0; i < param.properties.length; i++){
                                this.checkPatternParam(options, param.properties[i].value);
                            }
                            break;
                        default:
                            break;
                    }
                    options.simple = options.simple && param instanceof Node.Identifier;
                };
                Parser.prototype.reinterpretAsCoverFormalsList = function(expr) {
                    var params = [
                        expr
                    ];
                    var options;
                    var asyncArrow = false;
                    switch(expr.type){
                        case syntax_1.Syntax.Identifier:
                            break;
                        case ArrowParameterPlaceHolder:
                            params = expr.params;
                            asyncArrow = expr.async;
                            break;
                        default:
                            return null;
                    }
                    options = {
                        simple: true,
                        paramSet: {}
                    };
                    for(var i = 0; i < params.length; ++i){
                        var param = params[i];
                        if (param.type === syntax_1.Syntax.AssignmentPattern) {
                            if (param.right.type === syntax_1.Syntax.YieldExpression) {
                                if (param.right.argument) {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                param.right.type = syntax_1.Syntax.Identifier;
                                param.right.name = "yield";
                                delete param.right.argument;
                                delete param.right.delegate;
                            }
                        } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        this.checkPatternParam(options, param);
                        params[i] = param;
                    }
                    if (this.context.strict || !this.context.allowYield) {
                        for(var i = 0; i < params.length; ++i){
                            var param = params[i];
                            if (param.type === syntax_1.Syntax.YieldExpression) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                        }
                    }
                    if (options.message === messages_1.Messages.StrictParamDupe) {
                        var token = this.context.strict ? options.stricted : options.firstRestricted;
                        this.throwUnexpectedToken(token, options.message);
                    }
                    return {
                        simple: options.simple,
                        params: params,
                        stricted: options.stricted,
                        firstRestricted: options.firstRestricted,
                        message: options.message
                    };
                };
                Parser.prototype.parseAssignmentExpression = function() {
                    var expr;
                    if (!this.context.allowYield && this.matchKeyword("yield")) {
                        expr = this.parseYieldExpression();
                    } else {
                        var startToken = this.lookahead;
                        var token = startToken;
                        expr = this.parseConditionalExpression();
                        if (token.type === 3 /* Identifier */  && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                            if (this.lookahead.type === 3 /* Identifier */  || this.matchKeyword("yield")) {
                                var arg = this.parsePrimaryExpression();
                                this.reinterpretExpressionAsPattern(arg);
                                expr = {
                                    type: ArrowParameterPlaceHolder,
                                    params: [
                                        arg
                                    ],
                                    async: true
                                };
                            }
                        }
                        if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                            // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            var isAsync = expr.async;
                            var list = this.reinterpretAsCoverFormalsList(expr);
                            if (list) {
                                if (this.hasLineTerminator) {
                                    this.tolerateUnexpectedToken(this.lookahead);
                                }
                                this.context.firstCoverInitializedNameError = null;
                                var previousStrict = this.context.strict;
                                var previousAllowStrictDirective = this.context.allowStrictDirective;
                                this.context.allowStrictDirective = list.simple;
                                var previousAllowYield = this.context.allowYield;
                                var previousAwait = this.context.await;
                                this.context.allowYield = true;
                                this.context.await = isAsync;
                                var node = this.startNode(startToken);
                                this.expect("=>");
                                var body = void 0;
                                if (this.match("{")) {
                                    var previousAllowIn = this.context.allowIn;
                                    this.context.allowIn = true;
                                    body = this.parseFunctionSourceElements();
                                    this.context.allowIn = previousAllowIn;
                                } else {
                                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                }
                                var expression = body.type !== syntax_1.Syntax.BlockStatement;
                                if (this.context.strict && list.firstRestricted) {
                                    this.throwUnexpectedToken(list.firstRestricted, list.message);
                                }
                                if (this.context.strict && list.stricted) {
                                    this.tolerateUnexpectedToken(list.stricted, list.message);
                                }
                                expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                                this.context.strict = previousStrict;
                                this.context.allowStrictDirective = previousAllowStrictDirective;
                                this.context.allowYield = previousAllowYield;
                                this.context.await = previousAwait;
                            }
                        } else {
                            if (this.matchAssign()) {
                                if (!this.context.isAssignmentTarget) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                                }
                                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                                    var id = expr;
                                    if (this.scanner.isRestrictedWord(id.name)) {
                                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                                    }
                                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                                    }
                                }
                                if (!this.match("=")) {
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                } else {
                                    this.reinterpretExpressionAsPattern(expr);
                                }
                                token = this.nextToken();
                                var operator = token.value;
                                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                                this.context.firstCoverInitializedNameError = null;
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-comma-operator
                Parser.prototype.parseExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                        var expressions = [];
                        expressions.push(expr);
                        while(this.lookahead.type !== 2 /* EOF */ ){
                            if (!this.match(",")) {
                                break;
                            }
                            this.nextToken();
                            expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-block
                Parser.prototype.parseStatementListItem = function() {
                    var statement;
                    this.context.isAssignmentTarget = true;
                    this.context.isBindingElement = true;
                    if (this.lookahead.type === 4 /* Keyword */ ) {
                        switch(this.lookahead.value){
                            case "export":
                                if (!this.context.isModule) {
                                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                                }
                                statement = this.parseExportDeclaration();
                                break;
                            case "import":
                                if (!this.context.isModule) {
                                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                                }
                                statement = this.parseImportDeclaration();
                                break;
                            case "const":
                                statement = this.parseLexicalDeclaration({
                                    inFor: false
                                });
                                break;
                            case "function":
                                statement = this.parseFunctionDeclaration();
                                break;
                            case "class":
                                statement = this.parseClassDeclaration();
                                break;
                            case "let":
                                statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({
                                    inFor: false
                                }) : this.parseStatement();
                                break;
                            default:
                                statement = this.parseStatement();
                                break;
                        }
                    } else {
                        statement = this.parseStatement();
                    }
                    return statement;
                };
                Parser.prototype.parseBlock = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var block = [];
                    while(true){
                        if (this.match("}")) {
                            break;
                        }
                        block.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.BlockStatement(block));
                };
                // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
                Parser.prototype.parseLexicalBinding = function(kind, options) {
                    var node = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, kind);
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateError(messages_1.Messages.StrictVarName);
                        }
                    }
                    var init = null;
                    if (kind === "const") {
                        if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                            if (this.match("=")) {
                                this.nextToken();
                                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                            } else {
                                this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                            }
                        }
                    } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                        this.expect("=");
                        init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    return this.finalize(node, new Node.VariableDeclarator(id, init));
                };
                Parser.prototype.parseBindingList = function(kind, options) {
                    var list = [
                        this.parseLexicalBinding(kind, options)
                    ];
                    while(this.match(",")){
                        this.nextToken();
                        list.push(this.parseLexicalBinding(kind, options));
                    }
                    return list;
                };
                Parser.prototype.isLexicalDeclaration = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.scanner.lex();
                    this.scanner.restoreState(state);
                    return next.type === 3 /* Identifier */  || next.type === 7 /* Punctuator */  && next.value === "[" || next.type === 7 /* Punctuator */  && next.value === "{" || next.type === 4 /* Keyword */  && next.value === "let" || next.type === 4 /* Keyword */  && next.value === "yield";
                };
                Parser.prototype.parseLexicalDeclaration = function(options) {
                    var node = this.createNode();
                    var kind = this.nextToken().value;
                    assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                    var declarations = this.parseBindingList(kind, options);
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
                };
                // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
                Parser.prototype.parseBindingRestElement = function(params, kind) {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params, kind);
                    return this.finalize(node, new Node.RestElement(arg));
                };
                Parser.prototype.parseArrayPattern = function(params, kind) {
                    var node = this.createNode();
                    this.expect("[");
                    var elements = [];
                    while(!this.match("]")){
                        if (this.match(",")) {
                            this.nextToken();
                            elements.push(null);
                        } else {
                            if (this.match("...")) {
                                elements.push(this.parseBindingRestElement(params, kind));
                                break;
                            } else {
                                elements.push(this.parsePatternWithDefault(params, kind));
                            }
                            if (!this.match("]")) {
                                this.expect(",");
                            }
                        }
                    }
                    this.expect("]");
                    return this.finalize(node, new Node.ArrayPattern(elements));
                };
                Parser.prototype.parsePropertyPattern = function(params, kind) {
                    var node = this.createNode();
                    var computed = false;
                    var shorthand = false;
                    var method = false;
                    var key;
                    var value;
                    if (this.lookahead.type === 3 /* Identifier */ ) {
                        var keyToken = this.lookahead;
                        key = this.parseVariableIdentifier();
                        var init = this.finalize(node, new Node.Identifier(keyToken.value));
                        if (this.match("=")) {
                            params.push(keyToken);
                            shorthand = true;
                            this.nextToken();
                            var expr = this.parseAssignmentExpression();
                            value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                        } else if (!this.match(":")) {
                            params.push(keyToken);
                            shorthand = true;
                            value = init;
                        } else {
                            this.expect(":");
                            value = this.parsePatternWithDefault(params, kind);
                        }
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.expect(":");
                        value = this.parsePatternWithDefault(params, kind);
                    }
                    return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
                };
                Parser.prototype.parseObjectPattern = function(params, kind) {
                    var node = this.createNode();
                    var properties = [];
                    this.expect("{");
                    while(!this.match("}")){
                        properties.push(this.parsePropertyPattern(params, kind));
                        if (!this.match("}")) {
                            this.expect(",");
                        }
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.ObjectPattern(properties));
                };
                Parser.prototype.parsePattern = function(params, kind) {
                    var pattern;
                    if (this.match("[")) {
                        pattern = this.parseArrayPattern(params, kind);
                    } else if (this.match("{")) {
                        pattern = this.parseObjectPattern(params, kind);
                    } else {
                        if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                        }
                        params.push(this.lookahead);
                        pattern = this.parseVariableIdentifier(kind);
                    }
                    return pattern;
                };
                Parser.prototype.parsePatternWithDefault = function(params, kind) {
                    var startToken = this.lookahead;
                    var pattern = this.parsePattern(params, kind);
                    if (this.match("=")) {
                        this.nextToken();
                        var previousAllowYield = this.context.allowYield;
                        this.context.allowYield = true;
                        var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowYield = previousAllowYield;
                        pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                    }
                    return pattern;
                };
                // https://tc39.github.io/ecma262/#sec-variable-statement
                Parser.prototype.parseVariableIdentifier = function(kind) {
                    var node = this.createNode();
                    var token = this.nextToken();
                    if (token.type === 4 /* Keyword */  && token.value === "yield") {
                        if (this.context.strict) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        } else if (!this.context.allowYield) {
                            this.throwUnexpectedToken(token);
                        }
                    } else if (token.type !== 3 /* Identifier */ ) {
                        if (this.context.strict && token.type === 4 /* Keyword */  && this.scanner.isStrictModeReservedWord(token.value)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        } else {
                            if (this.context.strict || token.value !== "let" || kind !== "var") {
                                this.throwUnexpectedToken(token);
                            }
                        }
                    } else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */  && token.value === "await") {
                        this.tolerateUnexpectedToken(token);
                    }
                    return this.finalize(node, new Node.Identifier(token.value));
                };
                Parser.prototype.parseVariableDeclaration = function(options) {
                    var node = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, "var");
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateError(messages_1.Messages.StrictVarName);
                        }
                    }
                    var init = null;
                    if (this.match("=")) {
                        this.nextToken();
                        init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                        this.expect("=");
                    }
                    return this.finalize(node, new Node.VariableDeclarator(id, init));
                };
                Parser.prototype.parseVariableDeclarationList = function(options) {
                    var opt = {
                        inFor: options.inFor
                    };
                    var list = [];
                    list.push(this.parseVariableDeclaration(opt));
                    while(this.match(",")){
                        this.nextToken();
                        list.push(this.parseVariableDeclaration(opt));
                    }
                    return list;
                };
                Parser.prototype.parseVariableStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("var");
                    var declarations = this.parseVariableDeclarationList({
                        inFor: false
                    });
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
                };
                // https://tc39.github.io/ecma262/#sec-empty-statement
                Parser.prototype.parseEmptyStatement = function() {
                    var node = this.createNode();
                    this.expect(";");
                    return this.finalize(node, new Node.EmptyStatement());
                };
                // https://tc39.github.io/ecma262/#sec-expression-statement
                Parser.prototype.parseExpressionStatement = function() {
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ExpressionStatement(expr));
                };
                // https://tc39.github.io/ecma262/#sec-if-statement
                Parser.prototype.parseIfClause = function() {
                    if (this.context.strict && this.matchKeyword("function")) {
                        this.tolerateError(messages_1.Messages.StrictFunction);
                    }
                    return this.parseStatement();
                };
                Parser.prototype.parseIfStatement = function() {
                    var node = this.createNode();
                    var consequent;
                    var alternate = null;
                    this.expectKeyword("if");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        consequent = this.parseIfClause();
                        if (this.matchKeyword("else")) {
                            this.nextToken();
                            alternate = this.parseIfClause();
                        }
                    }
                    return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
                };
                // https://tc39.github.io/ecma262/#sec-do-while-statement
                Parser.prototype.parseDoWhileStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("do");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    var body = this.parseStatement();
                    this.context.inIteration = previousInIteration;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                    } else {
                        this.expect(")");
                        if (this.match(";")) {
                            this.nextToken();
                        }
                    }
                    return this.finalize(node, new Node.DoWhileStatement(body, test));
                };
                // https://tc39.github.io/ecma262/#sec-while-statement
                Parser.prototype.parseWhileStatement = function() {
                    var node = this.createNode();
                    var body;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        var previousInIteration = this.context.inIteration;
                        this.context.inIteration = true;
                        body = this.parseStatement();
                        this.context.inIteration = previousInIteration;
                    }
                    return this.finalize(node, new Node.WhileStatement(test, body));
                };
                // https://tc39.github.io/ecma262/#sec-for-statement
                // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
                Parser.prototype.parseForStatement = function() {
                    var init = null;
                    var test = null;
                    var update = null;
                    var forIn = true;
                    var left, right;
                    var node = this.createNode();
                    this.expectKeyword("for");
                    this.expect("(");
                    if (this.match(";")) {
                        this.nextToken();
                    } else {
                        if (this.matchKeyword("var")) {
                            init = this.createNode();
                            this.nextToken();
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = false;
                            var declarations = this.parseVariableDeclarationList({
                                inFor: true
                            });
                            this.context.allowIn = previousAllowIn;
                            if (declarations.length === 1 && this.matchKeyword("in")) {
                                var decl = declarations[0];
                                if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                                }
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.nextToken();
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.nextToken();
                                left = init;
                                right = this.parseAssignmentExpression();
                                init = null;
                                forIn = false;
                            } else {
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.expect(";");
                            }
                        } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                            init = this.createNode();
                            var kind = this.nextToken().value;
                            if (!this.context.strict && this.lookahead.value === "in") {
                                init = this.finalize(init, new Node.Identifier(kind));
                                this.nextToken();
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else {
                                var previousAllowIn = this.context.allowIn;
                                this.context.allowIn = false;
                                var declarations = this.parseBindingList(kind, {
                                    inFor: true
                                });
                                this.context.allowIn = previousAllowIn;
                                if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                    this.nextToken();
                                    left = init;
                                    right = this.parseExpression();
                                    init = null;
                                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                    this.nextToken();
                                    left = init;
                                    right = this.parseAssignmentExpression();
                                    init = null;
                                    forIn = false;
                                } else {
                                    this.consumeSemicolon();
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                }
                            }
                        } else {
                            var initStartToken = this.lookahead;
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = false;
                            init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                            this.context.allowIn = previousAllowIn;
                            if (this.matchKeyword("in")) {
                                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                                }
                                this.nextToken();
                                this.reinterpretExpressionAsPattern(init);
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else if (this.matchContextualKeyword("of")) {
                                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                                }
                                this.nextToken();
                                this.reinterpretExpressionAsPattern(init);
                                left = init;
                                right = this.parseAssignmentExpression();
                                init = null;
                                forIn = false;
                            } else {
                                if (this.match(",")) {
                                    var initSeq = [
                                        init
                                    ];
                                    while(this.match(",")){
                                        this.nextToken();
                                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                                    }
                                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                                }
                                this.expect(";");
                            }
                        }
                    }
                    if (typeof left === "undefined") {
                        if (!this.match(";")) {
                            test = this.parseExpression();
                        }
                        this.expect(";");
                        if (!this.match(")")) {
                            update = this.parseExpression();
                        }
                    }
                    var body;
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        var previousInIteration = this.context.inIteration;
                        this.context.inIteration = true;
                        body = this.isolateCoverGrammar(this.parseStatement);
                        this.context.inIteration = previousInIteration;
                    }
                    return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
                };
                // https://tc39.github.io/ecma262/#sec-continue-statement
                Parser.prototype.parseContinueStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("continue");
                    var label = null;
                    if (this.lookahead.type === 3 /* Identifier */  && !this.hasLineTerminator) {
                        var id = this.parseVariableIdentifier();
                        label = id;
                        var key = "$" + id.name;
                        if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.UnknownLabel, id.name);
                        }
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration) {
                        this.throwError(messages_1.Messages.IllegalContinue);
                    }
                    return this.finalize(node, new Node.ContinueStatement(label));
                };
                // https://tc39.github.io/ecma262/#sec-break-statement
                Parser.prototype.parseBreakStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("break");
                    var label = null;
                    if (this.lookahead.type === 3 /* Identifier */  && !this.hasLineTerminator) {
                        var id = this.parseVariableIdentifier();
                        var key = "$" + id.name;
                        if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.UnknownLabel, id.name);
                        }
                        label = id;
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                        this.throwError(messages_1.Messages.IllegalBreak);
                    }
                    return this.finalize(node, new Node.BreakStatement(label));
                };
                // https://tc39.github.io/ecma262/#sec-return-statement
                Parser.prototype.parseReturnStatement = function() {
                    if (!this.context.inFunctionBody) {
                        this.tolerateError(messages_1.Messages.IllegalReturn);
                    }
                    var node = this.createNode();
                    this.expectKeyword("return");
                    var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */  || this.lookahead.type === 8 /* StringLiteral */  || this.lookahead.type === 10 /* Template */ ;
                    var argument = hasArgument ? this.parseExpression() : null;
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ReturnStatement(argument));
                };
                // https://tc39.github.io/ecma262/#sec-with-statement
                Parser.prototype.parseWithStatement = function() {
                    if (this.context.strict) {
                        this.tolerateError(messages_1.Messages.StrictModeWith);
                    }
                    var node = this.createNode();
                    var body;
                    this.expectKeyword("with");
                    this.expect("(");
                    var object = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        body = this.parseStatement();
                    }
                    return this.finalize(node, new Node.WithStatement(object, body));
                };
                // https://tc39.github.io/ecma262/#sec-switch-statement
                Parser.prototype.parseSwitchCase = function() {
                    var node = this.createNode();
                    var test;
                    if (this.matchKeyword("default")) {
                        this.nextToken();
                        test = null;
                    } else {
                        this.expectKeyword("case");
                        test = this.parseExpression();
                    }
                    this.expect(":");
                    var consequent = [];
                    while(true){
                        if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                            break;
                        }
                        consequent.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.SwitchCase(test, consequent));
                };
                Parser.prototype.parseSwitchStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("switch");
                    this.expect("(");
                    var discriminant = this.parseExpression();
                    this.expect(")");
                    var previousInSwitch = this.context.inSwitch;
                    this.context.inSwitch = true;
                    var cases = [];
                    var defaultFound = false;
                    this.expect("{");
                    while(true){
                        if (this.match("}")) {
                            break;
                        }
                        var clause = this.parseSwitchCase();
                        if (clause.test === null) {
                            if (defaultFound) {
                                this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                            }
                            defaultFound = true;
                        }
                        cases.push(clause);
                    }
                    this.expect("}");
                    this.context.inSwitch = previousInSwitch;
                    return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
                };
                // https://tc39.github.io/ecma262/#sec-labelled-statements
                Parser.prototype.parseLabelledStatement = function() {
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    var statement;
                    if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                        this.nextToken();
                        var id = expr;
                        var key = "$" + id.name;
                        if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                        }
                        this.context.labelSet[key] = true;
                        var body = void 0;
                        if (this.matchKeyword("class")) {
                            this.tolerateUnexpectedToken(this.lookahead);
                            body = this.parseClassDeclaration();
                        } else if (this.matchKeyword("function")) {
                            var token = this.lookahead;
                            var declaration = this.parseFunctionDeclaration();
                            if (this.context.strict) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                            } else if (declaration.generator) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                            }
                            body = declaration;
                        } else {
                            body = this.parseStatement();
                        }
                        delete this.context.labelSet[key];
                        statement = new Node.LabeledStatement(id, body);
                    } else {
                        this.consumeSemicolon();
                        statement = new Node.ExpressionStatement(expr);
                    }
                    return this.finalize(node, statement);
                };
                // https://tc39.github.io/ecma262/#sec-throw-statement
                Parser.prototype.parseThrowStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("throw");
                    if (this.hasLineTerminator) {
                        this.throwError(messages_1.Messages.NewlineAfterThrow);
                    }
                    var argument = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ThrowStatement(argument));
                };
                // https://tc39.github.io/ecma262/#sec-try-statement
                Parser.prototype.parseCatchClause = function() {
                    var node = this.createNode();
                    this.expectKeyword("catch");
                    this.expect("(");
                    if (this.match(")")) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    var params = [];
                    var param = this.parsePattern(params);
                    var paramMap = {};
                    for(var i = 0; i < params.length; i++){
                        var key = "$" + params[i].value;
                        if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                            this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                        }
                        paramMap[key] = true;
                    }
                    if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(param.name)) {
                            this.tolerateError(messages_1.Messages.StrictCatchVariable);
                        }
                    }
                    this.expect(")");
                    var body = this.parseBlock();
                    return this.finalize(node, new Node.CatchClause(param, body));
                };
                Parser.prototype.parseFinallyClause = function() {
                    this.expectKeyword("finally");
                    return this.parseBlock();
                };
                Parser.prototype.parseTryStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("try");
                    var block = this.parseBlock();
                    var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                    var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                    if (!handler && !finalizer) {
                        this.throwError(messages_1.Messages.NoCatchOrFinally);
                    }
                    return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
                };
                // https://tc39.github.io/ecma262/#sec-debugger-statement
                Parser.prototype.parseDebuggerStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("debugger");
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.DebuggerStatement());
                };
                // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
                Parser.prototype.parseStatement = function() {
                    var statement;
                    switch(this.lookahead.type){
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 6 /* NumericLiteral */ :
                        case 8 /* StringLiteral */ :
                        case 10 /* Template */ :
                        case 9 /* RegularExpression */ :
                            statement = this.parseExpressionStatement();
                            break;
                        case 7 /* Punctuator */ :
                            var value = this.lookahead.value;
                            if (value === "{") {
                                statement = this.parseBlock();
                            } else if (value === "(") {
                                statement = this.parseExpressionStatement();
                            } else if (value === ";") {
                                statement = this.parseEmptyStatement();
                            } else {
                                statement = this.parseExpressionStatement();
                            }
                            break;
                        case 3 /* Identifier */ :
                            statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                            break;
                        case 4 /* Keyword */ :
                            switch(this.lookahead.value){
                                case "break":
                                    statement = this.parseBreakStatement();
                                    break;
                                case "continue":
                                    statement = this.parseContinueStatement();
                                    break;
                                case "debugger":
                                    statement = this.parseDebuggerStatement();
                                    break;
                                case "do":
                                    statement = this.parseDoWhileStatement();
                                    break;
                                case "for":
                                    statement = this.parseForStatement();
                                    break;
                                case "function":
                                    statement = this.parseFunctionDeclaration();
                                    break;
                                case "if":
                                    statement = this.parseIfStatement();
                                    break;
                                case "return":
                                    statement = this.parseReturnStatement();
                                    break;
                                case "switch":
                                    statement = this.parseSwitchStatement();
                                    break;
                                case "throw":
                                    statement = this.parseThrowStatement();
                                    break;
                                case "try":
                                    statement = this.parseTryStatement();
                                    break;
                                case "var":
                                    statement = this.parseVariableStatement();
                                    break;
                                case "while":
                                    statement = this.parseWhileStatement();
                                    break;
                                case "with":
                                    statement = this.parseWithStatement();
                                    break;
                                default:
                                    statement = this.parseExpressionStatement();
                                    break;
                            }
                            break;
                        default:
                            statement = this.throwUnexpectedToken(this.lookahead);
                    }
                    return statement;
                };
                // https://tc39.github.io/ecma262/#sec-function-definitions
                Parser.prototype.parseFunctionSourceElements = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var body = this.parseDirectivePrologues();
                    var previousLabelSet = this.context.labelSet;
                    var previousInIteration = this.context.inIteration;
                    var previousInSwitch = this.context.inSwitch;
                    var previousInFunctionBody = this.context.inFunctionBody;
                    this.context.labelSet = {};
                    this.context.inIteration = false;
                    this.context.inSwitch = false;
                    this.context.inFunctionBody = true;
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        if (this.match("}")) {
                            break;
                        }
                        body.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    this.context.labelSet = previousLabelSet;
                    this.context.inIteration = previousInIteration;
                    this.context.inSwitch = previousInSwitch;
                    this.context.inFunctionBody = previousInFunctionBody;
                    return this.finalize(node, new Node.BlockStatement(body));
                };
                Parser.prototype.validateParam = function(options, param, name) {
                    var key = "$" + name;
                    if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(name)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamName;
                        }
                        if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamDupe;
                        }
                    } else if (!options.firstRestricted) {
                        if (this.scanner.isRestrictedWord(name)) {
                            options.firstRestricted = param;
                            options.message = messages_1.Messages.StrictParamName;
                        } else if (this.scanner.isStrictModeReservedWord(name)) {
                            options.firstRestricted = param;
                            options.message = messages_1.Messages.StrictReservedWord;
                        } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamDupe;
                        }
                    }
                    /* istanbul ignore next */ if (typeof Object.defineProperty === "function") {
                        Object.defineProperty(options.paramSet, key, {
                            value: true,
                            enumerable: true,
                            writable: true,
                            configurable: true
                        });
                    } else {
                        options.paramSet[key] = true;
                    }
                };
                Parser.prototype.parseRestElement = function(params) {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params);
                    if (this.match("=")) {
                        this.throwError(messages_1.Messages.DefaultRestParameter);
                    }
                    if (!this.match(")")) {
                        this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                    }
                    return this.finalize(node, new Node.RestElement(arg));
                };
                Parser.prototype.parseFormalParameter = function(options) {
                    var params = [];
                    var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                    for(var i = 0; i < params.length; i++){
                        this.validateParam(options, params[i], params[i].value);
                    }
                    options.simple = options.simple && param instanceof Node.Identifier;
                    options.params.push(param);
                };
                Parser.prototype.parseFormalParameters = function(firstRestricted) {
                    var options;
                    options = {
                        simple: true,
                        params: [],
                        firstRestricted: firstRestricted
                    };
                    this.expect("(");
                    if (!this.match(")")) {
                        options.paramSet = {};
                        while(this.lookahead.type !== 2 /* EOF */ ){
                            this.parseFormalParameter(options);
                            if (this.match(")")) {
                                break;
                            }
                            this.expect(",");
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return {
                        simple: options.simple,
                        params: options.params,
                        stricted: options.stricted,
                        firstRestricted: options.firstRestricted,
                        message: options.message
                    };
                };
                Parser.prototype.matchAsyncFunction = function() {
                    var match = this.matchContextualKeyword("async");
                    if (match) {
                        var state = this.scanner.saveState();
                        this.scanner.scanComments();
                        var next = this.scanner.lex();
                        this.scanner.restoreState(state);
                        match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */  && next.value === "function";
                    }
                    return match;
                };
                Parser.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                    var node = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                        this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                        this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted = null;
                    if (!identifierIsOptional || !this.match("(")) {
                        var token = this.lookahead;
                        id = this.parseVariableIdentifier();
                        if (this.context.strict) {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                            }
                        } else {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictFunctionName;
                            } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictReservedWord;
                            }
                        }
                    }
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                        message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                        this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                        this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
                };
                Parser.prototype.parseFunctionExpression = function() {
                    var node = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                        this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                        this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted;
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    if (!this.match("(")) {
                        var token = this.lookahead;
                        id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                        if (this.context.strict) {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                            }
                        } else {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictFunctionName;
                            } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictReservedWord;
                            }
                        }
                    }
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                        message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                        this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                        this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
                };
                // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
                Parser.prototype.parseDirective = function() {
                    var token = this.lookahead;
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                    this.consumeSemicolon();
                    return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
                };
                Parser.prototype.parseDirectivePrologues = function() {
                    var firstRestricted = null;
                    var body = [];
                    while(true){
                        var token = this.lookahead;
                        if (token.type !== 8 /* StringLiteral */ ) {
                            break;
                        }
                        var statement = this.parseDirective();
                        body.push(statement);
                        var directive = statement.directive;
                        if (typeof directive !== "string") {
                            break;
                        }
                        if (directive === "use strict") {
                            this.context.strict = true;
                            if (firstRestricted) {
                                this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                            }
                            if (!this.context.allowStrictDirective) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                            }
                        } else {
                            if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }
                    }
                    return body;
                };
                // https://tc39.github.io/ecma262/#sec-method-definitions
                Parser.prototype.qualifiedPropertyName = function(token) {
                    switch(token.type){
                        case 3 /* Identifier */ :
                        case 8 /* StringLiteral */ :
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 6 /* NumericLiteral */ :
                        case 4 /* Keyword */ :
                            return true;
                        case 7 /* Punctuator */ :
                            return token.value === "[";
                        default:
                            break;
                    }
                    return false;
                };
                Parser.prototype.parseGetterMethod = function() {
                    var node = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length > 0) {
                        this.tolerateError(messages_1.Messages.BadGetterArity);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser.prototype.parseSetterMethod = function() {
                    var node = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length !== 1) {
                        this.tolerateError(messages_1.Messages.BadSetterArity);
                    } else if (formalParameters.params[0] instanceof Node.RestElement) {
                        this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser.prototype.parseGeneratorMethod = function() {
                    var node = this.createNode();
                    var isGenerator = true;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    this.context.allowYield = false;
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
                };
                // https://tc39.github.io/ecma262/#sec-generator-function-definitions
                Parser.prototype.isStartOfExpression = function() {
                    var start = true;
                    var value = this.lookahead.value;
                    switch(this.lookahead.type){
                        case 7 /* Punctuator */ :
                            start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/="; // regular expression literal
                            break;
                        case 4 /* Keyword */ :
                            start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                            break;
                        default:
                            break;
                    }
                    return start;
                };
                Parser.prototype.parseYieldExpression = function() {
                    var node = this.createNode();
                    this.expectKeyword("yield");
                    var argument = null;
                    var delegate = false;
                    if (!this.hasLineTerminator) {
                        var previousAllowYield = this.context.allowYield;
                        this.context.allowYield = false;
                        delegate = this.match("*");
                        if (delegate) {
                            this.nextToken();
                            argument = this.parseAssignmentExpression();
                        } else if (this.isStartOfExpression()) {
                            argument = this.parseAssignmentExpression();
                        }
                        this.context.allowYield = previousAllowYield;
                    }
                    return this.finalize(node, new Node.YieldExpression(argument, delegate));
                };
                // https://tc39.github.io/ecma262/#sec-class-definitions
                Parser.prototype.parseClassElement = function(hasConstructor) {
                    var token = this.lookahead;
                    var node = this.createNode();
                    var kind = "";
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var isStatic = false;
                    var isAsync = false;
                    if (this.match("*")) {
                        this.nextToken();
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        var id = key;
                        if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                            token = this.lookahead;
                            isStatic = true;
                            computed = this.match("[");
                            if (this.match("*")) {
                                this.nextToken();
                            } else {
                                key = this.parseObjectPropertyKey();
                            }
                        }
                        if (token.type === 3 /* Identifier */  && !this.hasLineTerminator && token.value === "async") {
                            var punctuator = this.lookahead.value;
                            if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                                isAsync = true;
                                token = this.lookahead;
                                key = this.parseObjectPropertyKey();
                                if (token.type === 3 /* Identifier */  && token.value === "constructor") {
                                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                                }
                            }
                        }
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 /* Identifier */ ) {
                        if (token.value === "get" && lookaheadPropertyKey) {
                            kind = "get";
                            computed = this.match("[");
                            key = this.parseObjectPropertyKey();
                            this.context.allowYield = false;
                            value = this.parseGetterMethod();
                        } else if (token.value === "set" && lookaheadPropertyKey) {
                            kind = "set";
                            computed = this.match("[");
                            key = this.parseObjectPropertyKey();
                            value = this.parseSetterMethod();
                        }
                    } else if (token.type === 7 /* Punctuator */  && token.value === "*" && lookaheadPropertyKey) {
                        kind = "init";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseGeneratorMethod();
                        method = true;
                    }
                    if (!kind && key && this.match("(")) {
                        kind = "init";
                        value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                        method = true;
                    }
                    if (!kind) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    if (kind === "init") {
                        kind = "method";
                    }
                    if (!computed) {
                        if (isStatic && this.isPropertyKey(key, "prototype")) {
                            this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                        }
                        if (!isStatic && this.isPropertyKey(key, "constructor")) {
                            if (kind !== "method" || !method || value && value.generator) {
                                this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor.value) {
                                this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                            } else {
                                hasConstructor.value = true;
                            }
                            kind = "constructor";
                        }
                    }
                    return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
                };
                Parser.prototype.parseClassElementList = function() {
                    var body = [];
                    var hasConstructor = {
                        value: false
                    };
                    this.expect("{");
                    while(!this.match("}")){
                        if (this.match(";")) {
                            this.nextToken();
                        } else {
                            body.push(this.parseClassElement(hasConstructor));
                        }
                    }
                    this.expect("}");
                    return body;
                };
                Parser.prototype.parseClassBody = function() {
                    var node = this.createNode();
                    var elementList = this.parseClassElementList();
                    return this.finalize(node, new Node.ClassBody(elementList));
                };
                Parser.prototype.parseClassDeclaration = function(identifierIsOptional) {
                    var node = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */  ? null : this.parseVariableIdentifier();
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                        this.nextToken();
                        superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
                };
                Parser.prototype.parseClassExpression = function() {
                    var node = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = this.lookahead.type === 3 /* Identifier */  ? this.parseVariableIdentifier() : null;
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                        this.nextToken();
                        superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
                };
                // https://tc39.github.io/ecma262/#sec-scripts
                // https://tc39.github.io/ecma262/#sec-modules
                Parser.prototype.parseModule = function() {
                    this.context.strict = true;
                    this.context.isModule = true;
                    this.scanner.isModule = true;
                    var node = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.Module(body));
                };
                Parser.prototype.parseScript = function() {
                    var node = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.Script(body));
                };
                // https://tc39.github.io/ecma262/#sec-imports
                Parser.prototype.parseModuleSpecifier = function() {
                    var node = this.createNode();
                    if (this.lookahead.type !== 8 /* StringLiteral */ ) {
                        this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                    }
                    var token = this.nextToken();
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node, new Node.Literal(token.value, raw));
                };
                // import {<foo as bar>} ...;
                Parser.prototype.parseImportSpecifier = function() {
                    var node = this.createNode();
                    var imported;
                    var local;
                    if (this.lookahead.type === 3 /* Identifier */ ) {
                        imported = this.parseVariableIdentifier();
                        local = imported;
                        if (this.matchContextualKeyword("as")) {
                            this.nextToken();
                            local = this.parseVariableIdentifier();
                        }
                    } else {
                        imported = this.parseIdentifierName();
                        local = imported;
                        if (this.matchContextualKeyword("as")) {
                            this.nextToken();
                            local = this.parseVariableIdentifier();
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                    }
                    return this.finalize(node, new Node.ImportSpecifier(local, imported));
                };
                // {foo, bar as bas}
                Parser.prototype.parseNamedImports = function() {
                    this.expect("{");
                    var specifiers = [];
                    while(!this.match("}")){
                        specifiers.push(this.parseImportSpecifier());
                        if (!this.match("}")) {
                            this.expect(",");
                        }
                    }
                    this.expect("}");
                    return specifiers;
                };
                // import <foo> ...;
                Parser.prototype.parseImportDefaultSpecifier = function() {
                    var node = this.createNode();
                    var local = this.parseIdentifierName();
                    return this.finalize(node, new Node.ImportDefaultSpecifier(local));
                };
                // import <* as foo> ...;
                Parser.prototype.parseImportNamespaceSpecifier = function() {
                    var node = this.createNode();
                    this.expect("*");
                    if (!this.matchContextualKeyword("as")) {
                        this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                    }
                    this.nextToken();
                    var local = this.parseIdentifierName();
                    return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
                };
                Parser.prototype.parseImportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                        this.throwError(messages_1.Messages.IllegalImportDeclaration);
                    }
                    var node = this.createNode();
                    this.expectKeyword("import");
                    var src;
                    var specifiers = [];
                    if (this.lookahead.type === 8 /* StringLiteral */ ) {
                        // import 'foo';
                        src = this.parseModuleSpecifier();
                    } else {
                        if (this.match("{")) {
                            // import {bar}
                            specifiers = specifiers.concat(this.parseNamedImports());
                        } else if (this.match("*")) {
                            // import * as foo
                            specifiers.push(this.parseImportNamespaceSpecifier());
                        } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                            // import foo
                            specifiers.push(this.parseImportDefaultSpecifier());
                            if (this.match(",")) {
                                this.nextToken();
                                if (this.match("*")) {
                                    // import foo, * as foo
                                    specifiers.push(this.parseImportNamespaceSpecifier());
                                } else if (this.match("{")) {
                                    // import foo, {bar}
                                    specifiers = specifiers.concat(this.parseNamedImports());
                                } else {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                            }
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                        if (!this.matchContextualKeyword("from")) {
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        }
                        this.nextToken();
                        src = this.parseModuleSpecifier();
                    }
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
                };
                // https://tc39.github.io/ecma262/#sec-exports
                Parser.prototype.parseExportSpecifier = function() {
                    var node = this.createNode();
                    var local = this.parseIdentifierName();
                    var exported = local;
                    if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        exported = this.parseIdentifierName();
                    }
                    return this.finalize(node, new Node.ExportSpecifier(local, exported));
                };
                Parser.prototype.parseExportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                        this.throwError(messages_1.Messages.IllegalExportDeclaration);
                    }
                    var node = this.createNode();
                    this.expectKeyword("export");
                    var exportDeclaration;
                    if (this.matchKeyword("default")) {
                        // export default ...
                        this.nextToken();
                        if (this.matchKeyword("function")) {
                            // export default function foo () {}
                            // export default function () {}
                            var declaration = this.parseFunctionDeclaration(true);
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else if (this.matchKeyword("class")) {
                            // export default class foo {}
                            var declaration = this.parseClassDeclaration(true);
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else if (this.matchContextualKeyword("async")) {
                            // export default async function f () {}
                            // export default async function () {}
                            // export default async x => x
                            var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else {
                            if (this.matchContextualKeyword("from")) {
                                this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                            }
                            // export default {};
                            // export default [];
                            // export default (1 + 2);
                            var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                            this.consumeSemicolon();
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        }
                    } else if (this.match("*")) {
                        // export * from 'foo';
                        this.nextToken();
                        if (!this.matchContextualKeyword("from")) {
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        }
                        this.nextToken();
                        var src = this.parseModuleSpecifier();
                        this.consumeSemicolon();
                        exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
                    } else if (this.lookahead.type === 4 /* Keyword */ ) {
                        // export var f = 1;
                        var declaration = void 0;
                        switch(this.lookahead.value){
                            case "let":
                            case "const":
                                declaration = this.parseLexicalDeclaration({
                                    inFor: false
                                });
                                break;
                            case "var":
                            case "class":
                            case "function":
                                declaration = this.parseStatementListItem();
                                break;
                            default:
                                this.throwUnexpectedToken(this.lookahead);
                        }
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                    } else if (this.matchAsyncFunction()) {
                        var declaration = this.parseFunctionDeclaration();
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                    } else {
                        var specifiers = [];
                        var source = null;
                        var isExportFromIdentifier = false;
                        this.expect("{");
                        while(!this.match("}")){
                            isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                            specifiers.push(this.parseExportSpecifier());
                            if (!this.match("}")) {
                                this.expect(",");
                            }
                        }
                        this.expect("}");
                        if (this.matchContextualKeyword("from")) {
                            // export {default} from 'foo';
                            // export {foo} from 'foo';
                            this.nextToken();
                            source = this.parseModuleSpecifier();
                            this.consumeSemicolon();
                        } else if (isExportFromIdentifier) {
                            // export {default}; // missing fromClause
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        } else {
                            // export {foo};
                            this.consumeSemicolon();
                        }
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
                    }
                    return exportDeclaration;
                };
                return Parser;
            }();
            exports1.Parser = Parser;
        /***/ },
        /* 9 */ /***/ function(module1, exports1) {
            "use strict";
            // Ensure the condition is true, otherwise throw an error.
            // This is only to have a better contract semantic, i.e. another safety net
            // to catch a logic error. The condition shall be fulfilled in normal case.
            // Do NOT use this to enforce a certain condition on any user input.
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            function assert(condition, message) {
                /* istanbul ignore if */ if (!condition) {
                    throw new Error("ASSERT: " + message);
                }
            }
            exports1.assert = assert;
        /***/ },
        /* 10 */ /***/ function(module1, exports1) {
            "use strict";
            /* tslint:disable:max-classes-per-file */ Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var ErrorHandler = function() {
                function ErrorHandler() {
                    this.errors = [];
                    this.tolerant = false;
                }
                ErrorHandler.prototype.recordError = function(error) {
                    this.errors.push(error);
                };
                ErrorHandler.prototype.tolerate = function(error) {
                    if (this.tolerant) {
                        this.recordError(error);
                    } else {
                        throw error;
                    }
                };
                ErrorHandler.prototype.constructError = function(msg, column) {
                    var error = new Error(msg);
                    try {
                        throw error;
                    } catch (base) {
                        /* istanbul ignore else */ if (Object.create && Object.defineProperty) {
                            error = Object.create(base);
                            Object.defineProperty(error, "column", {
                                value: column
                            });
                        }
                    }
                    /* istanbul ignore next */ return error;
                };
                ErrorHandler.prototype.createError = function(index, line, col, description) {
                    var msg = "Line " + line + ": " + description;
                    var error = this.constructError(msg, col);
                    error.index = index;
                    error.lineNumber = line;
                    error.description = description;
                    return error;
                };
                ErrorHandler.prototype.throwError = function(index, line, col, description) {
                    throw this.createError(index, line, col, description);
                };
                ErrorHandler.prototype.tolerateError = function(index, line, col, description) {
                    var error = this.createError(index, line, col, description);
                    if (this.tolerant) {
                        this.recordError(error);
                    } else {
                        throw error;
                    }
                };
                return ErrorHandler;
            }();
            exports1.ErrorHandler = ErrorHandler;
        /***/ },
        /* 11 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            // Error messages should be identical to V8.
            exports1.Messages = {
                BadGetterArity: "Getter must not have any formal parameters",
                BadSetterArity: "Setter must have exactly one formal parameter",
                BadSetterRestParameter: "Setter function argument must not be a rest parameter",
                ConstructorIsAsync: "Class constructor may not be an async method",
                ConstructorSpecialMethod: "Class constructor may not be an accessor",
                DeclarationMissingInitializer: "Missing initializer in %0 declaration",
                DefaultRestParameter: "Unexpected token =",
                DuplicateBinding: "Duplicate binding %0",
                DuplicateConstructor: "A class may only have one constructor",
                DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
                ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
                GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
                IllegalBreak: "Illegal break statement",
                IllegalContinue: "Illegal continue statement",
                IllegalExportDeclaration: "Unexpected token",
                IllegalImportDeclaration: "Unexpected token",
                IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
                IllegalReturn: "Illegal return statement",
                InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
                InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
                InvalidLHSInAssignment: "Invalid left-hand side in assignment",
                InvalidLHSInForIn: "Invalid left-hand side in for-in",
                InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
                InvalidModuleSpecifier: "Unexpected token",
                InvalidRegExp: "Invalid regular expression",
                LetInLexicalBinding: "let is disallowed as a lexically bound name",
                MissingFromClause: "Unexpected token",
                MultipleDefaultsInSwitch: "More than one default clause in switch statement",
                NewlineAfterThrow: "Illegal newline after throw",
                NoAsAfterImportNamespace: "Unexpected token",
                NoCatchOrFinally: "Missing catch or finally after try",
                ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
                Redeclaration: "%0 '%1' has already been declared",
                StaticPrototype: "Classes may not have static property named prototype",
                StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
                StrictDelete: "Delete of an unqualified identifier in strict mode.",
                StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
                StrictFunctionName: "Function name may not be eval or arguments in strict mode",
                StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
                StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
                StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
                StrictModeWith: "Strict mode code may not include a with statement",
                StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
                StrictParamDupe: "Strict mode function may not have duplicate parameter names",
                StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
                StrictReservedWord: "Use of future reserved word in strict mode",
                StrictVarName: "Variable name may not be eval or arguments in strict mode",
                TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
                UnexpectedEOS: "Unexpected end of input",
                UnexpectedIdentifier: "Unexpected identifier",
                UnexpectedNumber: "Unexpected number",
                UnexpectedReserved: "Unexpected reserved word",
                UnexpectedString: "Unexpected string",
                UnexpectedTemplate: "Unexpected quasi %0",
                UnexpectedToken: "Unexpected token %0",
                UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
                UnknownLabel: "Undefined label '%0'",
                UnterminatedRegExp: "Invalid regular expression: missing /"
            };
        /***/ },
        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_278838__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var assert_1 = __nested_webpack_require_278838__(9);
            var character_1 = __nested_webpack_require_278838__(4);
            var messages_1 = __nested_webpack_require_278838__(11);
            function hexValue(ch) {
                return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
                return "01234567".indexOf(ch);
            }
            var Scanner = function() {
                function Scanner(code, handler) {
                    this.source = code;
                    this.errorHandler = handler;
                    this.trackComment = false;
                    this.isModule = false;
                    this.length = code.length;
                    this.index = 0;
                    this.lineNumber = code.length > 0 ? 1 : 0;
                    this.lineStart = 0;
                    this.curlyStack = [];
                }
                Scanner.prototype.saveState = function() {
                    return {
                        index: this.index,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart
                    };
                };
                Scanner.prototype.restoreState = function(state) {
                    this.index = state.index;
                    this.lineNumber = state.lineNumber;
                    this.lineStart = state.lineStart;
                };
                Scanner.prototype.eof = function() {
                    return this.index >= this.length;
                };
                Scanner.prototype.throwUnexpectedToken = function(message) {
                    if (message === void 0) {
                        message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                Scanner.prototype.tolerateUnexpectedToken = function(message) {
                    if (message === void 0) {
                        message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                // https://tc39.github.io/ecma262/#sec-comments
                Scanner.prototype.skipSingleLineComment = function(offset) {
                    var comments = [];
                    var start, loc;
                    if (this.trackComment) {
                        comments = [];
                        start = this.index - offset;
                        loc = {
                            start: {
                                line: this.lineNumber,
                                column: this.index - this.lineStart - offset
                            },
                            end: {}
                        };
                    }
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        ++this.index;
                        if (character_1.Character.isLineTerminator(ch)) {
                            if (this.trackComment) {
                                loc.end = {
                                    line: this.lineNumber,
                                    column: this.index - this.lineStart - 1
                                };
                                var entry = {
                                    multiLine: false,
                                    slice: [
                                        start + offset,
                                        this.index - 1
                                    ],
                                    range: [
                                        start,
                                        this.index - 1
                                    ],
                                    loc: loc
                                };
                                comments.push(entry);
                            }
                            if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            this.lineStart = this.index;
                            return comments;
                        }
                    }
                    if (this.trackComment) {
                        loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart
                        };
                        var entry = {
                            multiLine: false,
                            slice: [
                                start + offset,
                                this.index
                            ],
                            range: [
                                start,
                                this.index
                            ],
                            loc: loc
                        };
                        comments.push(entry);
                    }
                    return comments;
                };
                Scanner.prototype.skipMultiLineComment = function() {
                    var comments = [];
                    var start, loc;
                    if (this.trackComment) {
                        comments = [];
                        start = this.index - 2;
                        loc = {
                            start: {
                                line: this.lineNumber,
                                column: this.index - this.lineStart - 2
                            },
                            end: {}
                        };
                    }
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (character_1.Character.isLineTerminator(ch)) {
                            if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            ++this.index;
                            this.lineStart = this.index;
                        } else if (ch === 0x2A) {
                            // Block comment ends with '*/'.
                            if (this.source.charCodeAt(this.index + 1) === 0x2F) {
                                this.index += 2;
                                if (this.trackComment) {
                                    loc.end = {
                                        line: this.lineNumber,
                                        column: this.index - this.lineStart
                                    };
                                    var entry = {
                                        multiLine: true,
                                        slice: [
                                            start + 2,
                                            this.index - 2
                                        ],
                                        range: [
                                            start,
                                            this.index
                                        ],
                                        loc: loc
                                    };
                                    comments.push(entry);
                                }
                                return comments;
                            }
                            ++this.index;
                        } else {
                            ++this.index;
                        }
                    }
                    // Ran off the end of the file - the whole thing is a comment
                    if (this.trackComment) {
                        loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart
                        };
                        var entry = {
                            multiLine: true,
                            slice: [
                                start + 2,
                                this.index
                            ],
                            range: [
                                start,
                                this.index
                            ],
                            loc: loc
                        };
                        comments.push(entry);
                    }
                    this.tolerateUnexpectedToken();
                    return comments;
                };
                Scanner.prototype.scanComments = function() {
                    var comments;
                    if (this.trackComment) {
                        comments = [];
                    }
                    var start = this.index === 0;
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (character_1.Character.isWhiteSpace(ch)) {
                            ++this.index;
                        } else if (character_1.Character.isLineTerminator(ch)) {
                            ++this.index;
                            if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            this.lineStart = this.index;
                            start = true;
                        } else if (ch === 0x2F) {
                            ch = this.source.charCodeAt(this.index + 1);
                            if (ch === 0x2F) {
                                this.index += 2;
                                var comment = this.skipSingleLineComment(2);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                                start = true;
                            } else if (ch === 0x2A) {
                                this.index += 2;
                                var comment = this.skipMultiLineComment();
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else if (start && ch === 0x2D) {
                            // U+003E is '>'
                            if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
                                // '-->' is a single-line comment
                                this.index += 3;
                                var comment = this.skipSingleLineComment(3);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else if (ch === 0x3C && !this.isModule) {
                            if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                                this.index += 4; // `<!--`
                                var comment = this.skipSingleLineComment(4);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    return comments;
                };
                // https://tc39.github.io/ecma262/#sec-future-reserved-words
                Scanner.prototype.isFutureReservedWord = function(id) {
                    switch(id){
                        case "enum":
                        case "export":
                        case "import":
                        case "super":
                            return true;
                        default:
                            return false;
                    }
                };
                Scanner.prototype.isStrictModeReservedWord = function(id) {
                    switch(id){
                        case "implements":
                        case "interface":
                        case "package":
                        case "private":
                        case "protected":
                        case "public":
                        case "static":
                        case "yield":
                        case "let":
                            return true;
                        default:
                            return false;
                    }
                };
                Scanner.prototype.isRestrictedWord = function(id) {
                    return id === "eval" || id === "arguments";
                };
                // https://tc39.github.io/ecma262/#sec-keywords
                Scanner.prototype.isKeyword = function(id) {
                    switch(id.length){
                        case 2:
                            return id === "if" || id === "in" || id === "do";
                        case 3:
                            return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                        case 4:
                            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                        case 5:
                            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                        case 6:
                            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                        case 7:
                            return id === "default" || id === "finally" || id === "extends";
                        case 8:
                            return id === "function" || id === "continue" || id === "debugger";
                        case 10:
                            return id === "instanceof";
                        default:
                            return false;
                    }
                };
                Scanner.prototype.codePointAt = function(i) {
                    var cp = this.source.charCodeAt(i);
                    if (cp >= 0xD800 && cp <= 0xDBFF) {
                        var second = this.source.charCodeAt(i + 1);
                        if (second >= 0xDC00 && second <= 0xDFFF) {
                            var first = cp;
                            cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                        }
                    }
                    return cp;
                };
                Scanner.prototype.scanHexEscape = function(prefix) {
                    var len = prefix === "u" ? 4 : 2;
                    var code = 0;
                    for(var i = 0; i < len; ++i){
                        if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                            code = code * 16 + hexValue(this.source[this.index++]);
                        } else {
                            return null;
                        }
                    }
                    return String.fromCharCode(code);
                };
                Scanner.prototype.scanUnicodeCodePointEscape = function() {
                    var ch = this.source[this.index];
                    var code = 0;
                    // At least, one hex digit is required.
                    if (ch === "}") {
                        this.throwUnexpectedToken();
                    }
                    while(!this.eof()){
                        ch = this.source[this.index++];
                        if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                            break;
                        }
                        code = code * 16 + hexValue(ch);
                    }
                    if (code > 0x10FFFF || ch !== "}") {
                        this.throwUnexpectedToken();
                    }
                    return character_1.Character.fromCodePoint(code);
                };
                Scanner.prototype.getIdentifier = function() {
                    var start = this.index++;
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (ch === 0x5C) {
                            // Blackslash (U+005C) marks Unicode escape sequence.
                            this.index = start;
                            return this.getComplexIdentifier();
                        } else if (ch >= 0xD800 && ch < 0xDFFF) {
                            // Need to handle surrogate pairs.
                            this.index = start;
                            return this.getComplexIdentifier();
                        }
                        if (character_1.Character.isIdentifierPart(ch)) {
                            ++this.index;
                        } else {
                            break;
                        }
                    }
                    return this.source.slice(start, this.index);
                };
                Scanner.prototype.getComplexIdentifier = function() {
                    var cp = this.codePointAt(this.index);
                    var id = character_1.Character.fromCodePoint(cp);
                    this.index += id.length;
                    // '\u' (U+005C, U+0075) denotes an escaped character.
                    var ch;
                    if (cp === 0x5C) {
                        if (this.source.charCodeAt(this.index) !== 0x75) {
                            this.throwUnexpectedToken();
                        }
                        ++this.index;
                        if (this.source[this.index] === "{") {
                            ++this.index;
                            ch = this.scanUnicodeCodePointEscape();
                        } else {
                            ch = this.scanHexEscape("u");
                            if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken();
                            }
                        }
                        id = ch;
                    }
                    while(!this.eof()){
                        cp = this.codePointAt(this.index);
                        if (!character_1.Character.isIdentifierPart(cp)) {
                            break;
                        }
                        ch = character_1.Character.fromCodePoint(cp);
                        id += ch;
                        this.index += ch.length;
                        // '\u' (U+005C, U+0075) denotes an escaped character.
                        if (cp === 0x5C) {
                            id = id.substr(0, id.length - 1);
                            if (this.source.charCodeAt(this.index) !== 0x75) {
                                this.throwUnexpectedToken();
                            }
                            ++this.index;
                            if (this.source[this.index] === "{") {
                                ++this.index;
                                ch = this.scanUnicodeCodePointEscape();
                            } else {
                                ch = this.scanHexEscape("u");
                                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                                    this.throwUnexpectedToken();
                                }
                            }
                            id += ch;
                        }
                    }
                    return id;
                };
                Scanner.prototype.octalToDecimal = function(ch) {
                    // \0 is not octal escape sequence
                    var octal = ch !== "0";
                    var code = octalValue(ch);
                    if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        octal = true;
                        code = code * 8 + octalValue(this.source[this.index++]);
                        // 3 digits are only allowed when string starts
                        // with 0, 1, 2, 3
                        if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                            code = code * 8 + octalValue(this.source[this.index++]);
                        }
                    }
                    return {
                        code: code,
                        octal: octal
                    };
                };
                // https://tc39.github.io/ecma262/#sec-names-and-keywords
                Scanner.prototype.scanIdentifier = function() {
                    var type;
                    var start = this.index;
                    // Backslash (U+005C) starts an escaped character.
                    var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
                    // There is no keyword or literal with only one character.
                    // Thus, it must be an identifier.
                    if (id.length === 1) {
                        type = 3 /* Identifier */ ;
                    } else if (this.isKeyword(id)) {
                        type = 4 /* Keyword */ ;
                    } else if (id === "null") {
                        type = 5 /* NullLiteral */ ;
                    } else if (id === "true" || id === "false") {
                        type = 1 /* BooleanLiteral */ ;
                    } else {
                        type = 3 /* Identifier */ ;
                    }
                    if (type !== 3 /* Identifier */  && start + id.length !== this.index) {
                        var restore = this.index;
                        this.index = start;
                        this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                        this.index = restore;
                    }
                    return {
                        type: type,
                        value: id,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-punctuators
                Scanner.prototype.scanPunctuator = function() {
                    var start = this.index;
                    // Check for most common single-character punctuators.
                    var str = this.source[this.index];
                    switch(str){
                        case "(":
                        case "{":
                            if (str === "{") {
                                this.curlyStack.push("{");
                            }
                            ++this.index;
                            break;
                        case ".":
                            ++this.index;
                            if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                                // Spread operator: ...
                                this.index += 2;
                                str = "...";
                            }
                            break;
                        case "}":
                            ++this.index;
                            this.curlyStack.pop();
                            break;
                        case ")":
                        case ";":
                        case ",":
                        case "[":
                        case "]":
                        case ":":
                        case "?":
                        case "~":
                            ++this.index;
                            break;
                        default:
                            // 4-character punctuator.
                            str = this.source.substr(this.index, 4);
                            if (str === ">>>=") {
                                this.index += 4;
                            } else {
                                // 3-character punctuators.
                                str = str.substr(0, 3);
                                if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                                    this.index += 3;
                                } else {
                                    // 2-character punctuators.
                                    str = str.substr(0, 2);
                                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                                        this.index += 2;
                                    } else {
                                        // 1-character punctuators.
                                        str = this.source[this.index];
                                        if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                                            ++this.index;
                                        }
                                    }
                                }
                            }
                    }
                    if (this.index === start) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 7 /* Punctuator */ ,
                        value: str,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
                Scanner.prototype.scanHexLiteral = function(start) {
                    var num = "";
                    while(!this.eof()){
                        if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                        this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt("0x" + num, 16),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.scanBinaryLiteral = function(start) {
                    var num = "";
                    var ch;
                    while(!this.eof()){
                        ch = this.source[this.index];
                        if (ch !== "0" && ch !== "1") {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                        // only 0b or 0B
                        this.throwUnexpectedToken();
                    }
                    if (!this.eof()) {
                        ch = this.source.charCodeAt(this.index);
                        /* istanbul ignore else */ if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                            this.throwUnexpectedToken();
                        }
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt(num, 2),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.scanOctalLiteral = function(prefix, start) {
                    var num = "";
                    var octal = false;
                    if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                        octal = true;
                        num = "0" + this.source[this.index++];
                    } else {
                        ++this.index;
                    }
                    while(!this.eof()){
                        if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (!octal && num.length === 0) {
                        // only 0o or 0O
                        this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt(num, 8),
                        octal: octal,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.isImplicitOctalLiteral = function() {
                    // Implicit octal, unless there is a non-octal digit.
                    // (Annex B.1.1 on Numeric Literals)
                    for(var i = this.index + 1; i < this.length; ++i){
                        var ch = this.source[i];
                        if (ch === "8" || ch === "9") {
                            return false;
                        }
                        if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            return true;
                        }
                    }
                    return true;
                };
                Scanner.prototype.scanNumericLiteral = function() {
                    var start = this.index;
                    var ch = this.source[start];
                    assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                    var num = "";
                    if (ch !== ".") {
                        num = this.source[this.index++];
                        ch = this.source[this.index];
                        // Hex number starts with '0x'.
                        // Octal number starts with '0'.
                        // Octal number in ES6 starts with '0o'.
                        // Binary number in ES6 starts with '0b'.
                        if (num === "0") {
                            if (ch === "x" || ch === "X") {
                                ++this.index;
                                return this.scanHexLiteral(start);
                            }
                            if (ch === "b" || ch === "B") {
                                ++this.index;
                                return this.scanBinaryLiteral(start);
                            }
                            if (ch === "o" || ch === "O") {
                                return this.scanOctalLiteral(ch, start);
                            }
                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                if (this.isImplicitOctalLiteral()) {
                                    return this.scanOctalLiteral(ch, start);
                                }
                            }
                        }
                        while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                            num += this.source[this.index++];
                        }
                        ch = this.source[this.index];
                    }
                    if (ch === ".") {
                        num += this.source[this.index++];
                        while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                            num += this.source[this.index++];
                        }
                        ch = this.source[this.index];
                    }
                    if (ch === "e" || ch === "E") {
                        num += this.source[this.index++];
                        ch = this.source[this.index];
                        if (ch === "+" || ch === "-") {
                            num += this.source[this.index++];
                        }
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                                num += this.source[this.index++];
                            }
                        } else {
                            this.throwUnexpectedToken();
                        }
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseFloat(num),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-string-literals
                Scanner.prototype.scanStringLiteral = function() {
                    var start = this.index;
                    var quote = this.source[start];
                    assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                    ++this.index;
                    var octal = false;
                    var str = "";
                    while(!this.eof()){
                        var ch = this.source[this.index++];
                        if (ch === quote) {
                            quote = "";
                            break;
                        } else if (ch === "\\") {
                            ch = this.source[this.index++];
                            if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                switch(ch){
                                    case "u":
                                        if (this.source[this.index] === "{") {
                                            ++this.index;
                                            str += this.scanUnicodeCodePointEscape();
                                        } else {
                                            var unescaped_1 = this.scanHexEscape(ch);
                                            if (unescaped_1 === null) {
                                                this.throwUnexpectedToken();
                                            }
                                            str += unescaped_1;
                                        }
                                        break;
                                    case "x":
                                        var unescaped = this.scanHexEscape(ch);
                                        if (unescaped === null) {
                                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                                        }
                                        str += unescaped;
                                        break;
                                    case "n":
                                        str += "\n";
                                        break;
                                    case "r":
                                        str += "\r";
                                        break;
                                    case "t":
                                        str += "	";
                                        break;
                                    case "b":
                                        str += "\b";
                                        break;
                                    case "f":
                                        str += "\f";
                                        break;
                                    case "v":
                                        str += "\v";
                                        break;
                                    case "8":
                                    case "9":
                                        str += ch;
                                        this.tolerateUnexpectedToken();
                                        break;
                                    default:
                                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                            var octToDec = this.octalToDecimal(ch);
                                            octal = octToDec.octal || octal;
                                            str += String.fromCharCode(octToDec.code);
                                        } else {
                                            str += ch;
                                        }
                                        break;
                                }
                            } else {
                                ++this.lineNumber;
                                if (ch === "\r" && this.source[this.index] === "\n") {
                                    ++this.index;
                                }
                                this.lineStart = this.index;
                            }
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            break;
                        } else {
                            str += ch;
                        }
                    }
                    if (quote !== "") {
                        this.index = start;
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 8 /* StringLiteral */ ,
                        value: str,
                        octal: octal,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
                Scanner.prototype.scanTemplate = function() {
                    var cooked = "";
                    var terminated = false;
                    var start = this.index;
                    var head = this.source[start] === "`";
                    var tail = false;
                    var rawOffset = 2;
                    ++this.index;
                    while(!this.eof()){
                        var ch = this.source[this.index++];
                        if (ch === "`") {
                            rawOffset = 1;
                            tail = true;
                            terminated = true;
                            break;
                        } else if (ch === "$") {
                            if (this.source[this.index] === "{") {
                                this.curlyStack.push("${");
                                ++this.index;
                                terminated = true;
                                break;
                            }
                            cooked += ch;
                        } else if (ch === "\\") {
                            ch = this.source[this.index++];
                            if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                switch(ch){
                                    case "n":
                                        cooked += "\n";
                                        break;
                                    case "r":
                                        cooked += "\r";
                                        break;
                                    case "t":
                                        cooked += "	";
                                        break;
                                    case "u":
                                        if (this.source[this.index] === "{") {
                                            ++this.index;
                                            cooked += this.scanUnicodeCodePointEscape();
                                        } else {
                                            var restore = this.index;
                                            var unescaped_2 = this.scanHexEscape(ch);
                                            if (unescaped_2 !== null) {
                                                cooked += unescaped_2;
                                            } else {
                                                this.index = restore;
                                                cooked += ch;
                                            }
                                        }
                                        break;
                                    case "x":
                                        var unescaped = this.scanHexEscape(ch);
                                        if (unescaped === null) {
                                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                                        }
                                        cooked += unescaped;
                                        break;
                                    case "b":
                                        cooked += "\b";
                                        break;
                                    case "f":
                                        cooked += "\f";
                                        break;
                                    case "v":
                                        cooked += "\v";
                                        break;
                                    default:
                                        if (ch === "0") {
                                            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                                // Illegal: \01 \02 and so on
                                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                            }
                                            cooked += "\x00";
                                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                            // Illegal: \1 \2
                                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                        } else {
                                            cooked += ch;
                                        }
                                        break;
                                }
                            } else {
                                ++this.lineNumber;
                                if (ch === "\r" && this.source[this.index] === "\n") {
                                    ++this.index;
                                }
                                this.lineStart = this.index;
                            }
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            ++this.lineNumber;
                            if (ch === "\r" && this.source[this.index] === "\n") {
                                ++this.index;
                            }
                            this.lineStart = this.index;
                            cooked += "\n";
                        } else {
                            cooked += ch;
                        }
                    }
                    if (!terminated) {
                        this.throwUnexpectedToken();
                    }
                    if (!head) {
                        this.curlyStack.pop();
                    }
                    return {
                        type: 10 /* Template */ ,
                        value: this.source.slice(start + 1, this.index - rawOffset),
                        cooked: cooked,
                        head: head,
                        tail: tail,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
                Scanner.prototype.testRegExp = function(pattern, flags) {
                    // The BMP character to use as a replacement for astral symbols when
                    // translating an ES6 "u"-flagged pattern to an ES5-compatible
                    // approximation.
                    // Note: replacing with '\uFFFF' enables false positives in unlikely
                    // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
                    // pattern that would not be detected by this substitution.
                    var astralSubstitute = "";
                    var tmp = pattern;
                    var self = this;
                    if (flags.indexOf("u") >= 0) {
                        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                            var codePoint = parseInt($1 || $2, 16);
                            if (codePoint > 0x10FFFF) {
                                self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                            }
                            if (codePoint <= 0xFFFF) {
                                return String.fromCharCode(codePoint);
                            }
                            return astralSubstitute;
                        }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                    }
                    // First, detect invalid regular expressions.
                    try {
                        RegExp(tmp);
                    } catch (e) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    // Return a regular expression object for this pattern-flag pair, or
                    // `null` in case the current environment doesn't support the flags it
                    // uses.
                    try {
                        return new RegExp(pattern, flags);
                    } catch (exception) {
                        /* istanbul ignore next */ return null;
                    }
                };
                Scanner.prototype.scanRegExpBody = function() {
                    var ch = this.source[this.index];
                    assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                    var str = this.source[this.index++];
                    var classMarker = false;
                    var terminated = false;
                    while(!this.eof()){
                        ch = this.source[this.index++];
                        str += ch;
                        if (ch === "\\") {
                            ch = this.source[this.index++];
                            // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
                            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                            }
                            str += ch;
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                        } else if (classMarker) {
                            if (ch === "]") {
                                classMarker = false;
                            }
                        } else {
                            if (ch === "/") {
                                terminated = true;
                                break;
                            } else if (ch === "[") {
                                classMarker = true;
                            }
                        }
                    }
                    if (!terminated) {
                        this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    // Exclude leading and trailing slash.
                    return str.substr(1, str.length - 2);
                };
                Scanner.prototype.scanRegExpFlags = function() {
                    var str = "";
                    var flags = "";
                    while(!this.eof()){
                        var ch = this.source[this.index];
                        if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                            break;
                        }
                        ++this.index;
                        if (ch === "\\" && !this.eof()) {
                            ch = this.source[this.index];
                            if (ch === "u") {
                                ++this.index;
                                var restore = this.index;
                                var char = this.scanHexEscape("u");
                                if (char !== null) {
                                    flags += char;
                                    for(str += "\\u"; restore < this.index; ++restore){
                                        str += this.source[restore];
                                    }
                                } else {
                                    this.index = restore;
                                    flags += "u";
                                    str += "\\u";
                                }
                                this.tolerateUnexpectedToken();
                            } else {
                                str += "\\";
                                this.tolerateUnexpectedToken();
                            }
                        } else {
                            flags += ch;
                            str += ch;
                        }
                    }
                    return flags;
                };
                Scanner.prototype.scanRegExp = function() {
                    var start = this.index;
                    var pattern = this.scanRegExpBody();
                    var flags = this.scanRegExpFlags();
                    var value = this.testRegExp(pattern, flags);
                    return {
                        type: 9 /* RegularExpression */ ,
                        value: "",
                        pattern: pattern,
                        flags: flags,
                        regex: value,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.lex = function() {
                    if (this.eof()) {
                        return {
                            type: 2 /* EOF */ ,
                            value: "",
                            lineNumber: this.lineNumber,
                            lineStart: this.lineStart,
                            start: this.index,
                            end: this.index
                        };
                    }
                    var cp = this.source.charCodeAt(this.index);
                    if (character_1.Character.isIdentifierStart(cp)) {
                        return this.scanIdentifier();
                    }
                    // Very common: ( and ) and ;
                    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
                        return this.scanPunctuator();
                    }
                    // String literal starts with single quote (U+0027) or double quote (U+0022).
                    if (cp === 0x27 || cp === 0x22) {
                        return this.scanStringLiteral();
                    }
                    // Dot (.) U+002E can also start a floating-point number, hence the need
                    // to check the next character.
                    if (cp === 0x2E) {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                            return this.scanNumericLiteral();
                        }
                        return this.scanPunctuator();
                    }
                    if (character_1.Character.isDecimalDigit(cp)) {
                        return this.scanNumericLiteral();
                    }
                    // Template literals start with ` (U+0060) for template head
                    // or } (U+007D) for template middle or template tail.
                    if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === "${") {
                        return this.scanTemplate();
                    }
                    // Possible identifier start in a surrogate pair.
                    if (cp >= 0xD800 && cp < 0xDFFF) {
                        if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                            return this.scanIdentifier();
                        }
                    }
                    return this.scanPunctuator();
                };
                return Scanner;
            }();
            exports1.Scanner = Scanner;
        /***/ },
        /* 13 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.TokenName = {};
            exports1.TokenName[1 /* BooleanLiteral */ ] = "Boolean";
            exports1.TokenName[2 /* EOF */ ] = "<end>";
            exports1.TokenName[3 /* Identifier */ ] = "Identifier";
            exports1.TokenName[4 /* Keyword */ ] = "Keyword";
            exports1.TokenName[5 /* NullLiteral */ ] = "Null";
            exports1.TokenName[6 /* NumericLiteral */ ] = "Numeric";
            exports1.TokenName[7 /* Punctuator */ ] = "Punctuator";
            exports1.TokenName[8 /* StringLiteral */ ] = "String";
            exports1.TokenName[9 /* RegularExpression */ ] = "RegularExpression";
            exports1.TokenName[10 /* Template */ ] = "Template";
        /***/ },
        /* 14 */ /***/ function(module1, exports1) {
            "use strict";
            // Generated by generate-xhtml-entities.js. DO NOT MODIFY!
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.XHTMLEntities = {
                quot: '"',
                amp: "&",
                apos: "'",
                gt: ">",
                nbsp: "\xa0",
                iexcl: "\xa1",
                cent: "\xa2",
                pound: "\xa3",
                curren: "\xa4",
                yen: "\xa5",
                brvbar: "\xa6",
                sect: "\xa7",
                uml: "\xa8",
                copy: "\xa9",
                ordf: "\xaa",
                laquo: "\xab",
                not: "\xac",
                shy: "\xad",
                reg: "\xae",
                macr: "\xaf",
                deg: "\xb0",
                plusmn: "\xb1",
                sup2: "\xb2",
                sup3: "\xb3",
                acute: "\xb4",
                micro: "\xb5",
                para: "\xb6",
                middot: "\xb7",
                cedil: "\xb8",
                sup1: "\xb9",
                ordm: "\xba",
                raquo: "\xbb",
                frac14: "\xbc",
                frac12: "\xbd",
                frac34: "\xbe",
                iquest: "\xbf",
                Agrave: "\xc0",
                Aacute: "\xc1",
                Acirc: "\xc2",
                Atilde: "\xc3",
                Auml: "\xc4",
                Aring: "\xc5",
                AElig: "\xc6",
                Ccedil: "\xc7",
                Egrave: "\xc8",
                Eacute: "\xc9",
                Ecirc: "\xca",
                Euml: "\xcb",
                Igrave: "\xcc",
                Iacute: "\xcd",
                Icirc: "\xce",
                Iuml: "\xcf",
                ETH: "\xd0",
                Ntilde: "\xd1",
                Ograve: "\xd2",
                Oacute: "\xd3",
                Ocirc: "\xd4",
                Otilde: "\xd5",
                Ouml: "\xd6",
                times: "\xd7",
                Oslash: "\xd8",
                Ugrave: "\xd9",
                Uacute: "\xda",
                Ucirc: "\xdb",
                Uuml: "\xdc",
                Yacute: "\xdd",
                THORN: "\xde",
                szlig: "\xdf",
                agrave: "\xe0",
                aacute: "\xe1",
                acirc: "\xe2",
                atilde: "\xe3",
                auml: "\xe4",
                aring: "\xe5",
                aelig: "\xe6",
                ccedil: "\xe7",
                egrave: "\xe8",
                eacute: "\xe9",
                ecirc: "\xea",
                euml: "\xeb",
                igrave: "\xec",
                iacute: "\xed",
                icirc: "\xee",
                iuml: "\xef",
                eth: "\xf0",
                ntilde: "\xf1",
                ograve: "\xf2",
                oacute: "\xf3",
                ocirc: "\xf4",
                otilde: "\xf5",
                ouml: "\xf6",
                divide: "\xf7",
                oslash: "\xf8",
                ugrave: "\xf9",
                uacute: "\xfa",
                ucirc: "\xfb",
                uuml: "\xfc",
                yacute: "\xfd",
                thorn: "\xfe",
                yuml: "\xff",
                OElig: "",
                oelig: "",
                Scaron: "",
                scaron: "",
                Yuml: "",
                fnof: "",
                circ: "",
                tilde: "",
                Alpha: "",
                Beta: "",
                Gamma: "",
                Delta: "",
                Epsilon: "",
                Zeta: "",
                Eta: "",
                Theta: "",
                Iota: "",
                Kappa: "",
                Lambda: "",
                Mu: "",
                Nu: "",
                Xi: "",
                Omicron: "",
                Pi: "",
                Rho: "",
                Sigma: "",
                Tau: "",
                Upsilon: "",
                Phi: "",
                Chi: "",
                Psi: "",
                Omega: "",
                alpha: "",
                beta: "",
                gamma: "",
                delta: "",
                epsilon: "",
                zeta: "",
                eta: "",
                theta: "",
                iota: "",
                kappa: "",
                lambda: "",
                mu: "",
                nu: "",
                xi: "",
                omicron: "",
                pi: "",
                rho: "",
                sigmaf: "",
                sigma: "",
                tau: "",
                upsilon: "",
                phi: "",
                chi: "",
                psi: "",
                omega: "",
                thetasym: "",
                upsih: "",
                piv: "",
                ensp: "",
                emsp: "",
                thinsp: "",
                zwnj: "",
                zwj: "",
                lrm: "",
                rlm: "",
                ndash: "",
                mdash: "",
                lsquo: "",
                rsquo: "",
                sbquo: "",
                ldquo: "",
                rdquo: "",
                bdquo: "",
                dagger: "",
                Dagger: "",
                bull: "",
                hellip: "",
                permil: "",
                prime: "",
                Prime: "",
                lsaquo: "",
                rsaquo: "",
                oline: "",
                frasl: "",
                euro: "",
                image: "",
                weierp: "",
                real: "",
                trade: "",
                alefsym: "",
                larr: "",
                uarr: "",
                rarr: "",
                darr: "",
                harr: "",
                crarr: "",
                lArr: "",
                uArr: "",
                rArr: "",
                dArr: "",
                hArr: "",
                forall: "",
                part: "",
                exist: "",
                empty: "",
                nabla: "",
                isin: "",
                notin: "",
                ni: "",
                prod: "",
                sum: "",
                minus: "",
                lowast: "",
                radic: "",
                prop: "",
                infin: "",
                ang: "",
                and: "",
                or: "",
                cap: "",
                cup: "",
                int: "",
                there4: "",
                sim: "",
                cong: "",
                asymp: "",
                ne: "",
                equiv: "",
                le: "",
                ge: "",
                sub: "",
                sup: "",
                nsub: "",
                sube: "",
                supe: "",
                oplus: "",
                otimes: "",
                perp: "",
                sdot: "",
                lceil: "",
                rceil: "",
                lfloor: "",
                rfloor: "",
                loz: "",
                spades: "",
                clubs: "",
                hearts: "",
                diams: "",
                lang: "",
                rang: ""
            };
        /***/ },
        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_343122__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var error_handler_1 = __nested_webpack_require_343122__(10);
            var scanner_1 = __nested_webpack_require_343122__(12);
            var token_1 = __nested_webpack_require_343122__(13);
            var Reader = function() {
                function Reader() {
                    this.values = [];
                    this.curly = this.paren = -1;
                }
                // A function following one of those tokens is an expression.
                Reader.prototype.beforeFunctionExpression = function(t) {
                    return [
                        "(",
                        "{",
                        "[",
                        "in",
                        "typeof",
                        "instanceof",
                        "new",
                        "return",
                        "case",
                        "delete",
                        "throw",
                        "void",
                        // assignment operators
                        "=",
                        "+=",
                        "-=",
                        "*=",
                        "**=",
                        "/=",
                        "%=",
                        "<<=",
                        ">>=",
                        ">>>=",
                        "&=",
                        "|=",
                        "^=",
                        ",",
                        // binary/unary operators
                        "+",
                        "-",
                        "*",
                        "**",
                        "/",
                        "%",
                        "++",
                        "--",
                        "<<",
                        ">>",
                        ">>>",
                        "&",
                        "|",
                        "^",
                        "!",
                        "~",
                        "&&",
                        "||",
                        "?",
                        ":",
                        "===",
                        "==",
                        ">=",
                        "<=",
                        "<",
                        ">",
                        "!=",
                        "!=="
                    ].indexOf(t) >= 0;
                };
                // Determine if forward slash (/) is an operator or part of a regular expression
                // https://github.com/mozilla/sweet.js/wiki/design
                Reader.prototype.isRegexStart = function() {
                    var previous = this.values[this.values.length - 1];
                    var regex = previous !== null;
                    switch(previous){
                        case "this":
                        case "]":
                            regex = false;
                            break;
                        case ")":
                            var keyword = this.values[this.paren - 1];
                            regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                            break;
                        case "}":
                            // Dividing a function by anything makes little sense,
                            // but we have to check for that.
                            regex = false;
                            if (this.values[this.curly - 3] === "function") {
                                // Anonymous function, e.g. function(){} /42
                                var check = this.values[this.curly - 4];
                                regex = check ? !this.beforeFunctionExpression(check) : false;
                            } else if (this.values[this.curly - 4] === "function") {
                                // Named function, e.g. function f(){} /42/
                                var check = this.values[this.curly - 5];
                                regex = check ? !this.beforeFunctionExpression(check) : true;
                            }
                            break;
                        default:
                            break;
                    }
                    return regex;
                };
                Reader.prototype.push = function(token) {
                    if (token.type === 7 /* Punctuator */  || token.type === 4 /* Keyword */ ) {
                        if (token.value === "{") {
                            this.curly = this.values.length;
                        } else if (token.value === "(") {
                            this.paren = this.values.length;
                        }
                        this.values.push(token.value);
                    } else {
                        this.values.push(null);
                    }
                };
                return Reader;
            }();
            var Tokenizer = function() {
                function Tokenizer(code, config) {
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                    this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                    this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                    this.buffer = [];
                    this.reader = new Reader();
                }
                Tokenizer.prototype.errors = function() {
                    return this.errorHandler.errors;
                };
                Tokenizer.prototype.getNextToken = function() {
                    if (this.buffer.length === 0) {
                        var comments = this.scanner.scanComments();
                        if (this.scanner.trackComment) {
                            for(var i = 0; i < comments.length; ++i){
                                var e = comments[i];
                                var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                                var comment = {
                                    type: e.multiLine ? "BlockComment" : "LineComment",
                                    value: value
                                };
                                if (this.trackRange) {
                                    comment.range = e.range;
                                }
                                if (this.trackLoc) {
                                    comment.loc = e.loc;
                                }
                                this.buffer.push(comment);
                            }
                        }
                        if (!this.scanner.eof()) {
                            var loc = void 0;
                            if (this.trackLoc) {
                                loc = {
                                    start: {
                                        line: this.scanner.lineNumber,
                                        column: this.scanner.index - this.scanner.lineStart
                                    },
                                    end: {}
                                };
                            }
                            var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                            var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                            this.reader.push(token);
                            var entry = {
                                type: token_1.TokenName[token.type],
                                value: this.scanner.source.slice(token.start, token.end)
                            };
                            if (this.trackRange) {
                                entry.range = [
                                    token.start,
                                    token.end
                                ];
                            }
                            if (this.trackLoc) {
                                loc.end = {
                                    line: this.scanner.lineNumber,
                                    column: this.scanner.index - this.scanner.lineStart
                                };
                                entry.loc = loc;
                            }
                            if (token.type === 9 /* RegularExpression */ ) {
                                var pattern = token.pattern;
                                var flags = token.flags;
                                entry.regex = {
                                    pattern: pattern,
                                    flags: flags
                                };
                            }
                            this.buffer.push(entry);
                        }
                    }
                    return this.buffer.shift();
                };
                return Tokenizer;
            }();
            exports1.Tokenizer = Tokenizer;
        /***/ }
    ]);
});
;


/***/ }),

/***/ 8706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(4601);
module.exports = function extend(o /*, objects*/ ) {
    if (!isObject(o)) {
        o = {};
    }
    var len = arguments.length;
    for(var i = 1; i < len; i++){
        var obj = arguments[i];
        if (isObject(obj)) {
            assign(o, obj);
        }
    }
    return o;
};
function assign(a, b) {
    for(var key in b){
        if (hasOwn(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */ function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}


/***/ }),

/***/ 5872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(7147);
const sections = __webpack_require__(4689);
const defaults = __webpack_require__(2289);
const stringify = __webpack_require__(4824);
const excerpt = __webpack_require__(5597);
const engines = __webpack_require__(1376);
const toFile = __webpack_require__(8237);
const parse = __webpack_require__(1394);
const utils = __webpack_require__(5114);
/**
 * Takes a string or object with `content` property, extracts
 * and parses front-matter from the string, then returns an object
 * with `data`, `content` and other [useful properties](#returned-object).
 *
 * ```js
 * const matter = require('gray-matter');
 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
 * ```
 * @param {Object|String} `input` String, or object with `content` string
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */ function matter(input, options) {
    if (input === "") {
        return {
            data: {},
            content: input,
            excerpt: "",
            orig: input
        };
    }
    let file = toFile(input);
    const cached = matter.cache[file.content];
    if (!options) {
        if (cached) {
            file = Object.assign({}, cached);
            file.orig = cached.orig;
            return file;
        }
        // only cache if there are no options passed. if we cache when options
        // are passed, we would need to also cache options values, which would
        // negate any performance benefits of caching
        matter.cache[file.content] = file;
    }
    return parseMatter(file, options);
}
/**
 * Parse front matter
 */ function parseMatter(file, options) {
    const opts = defaults(options);
    const open = opts.delimiters[0];
    const close = "\n" + opts.delimiters[1];
    let str = file.content;
    if (opts.language) {
        file.language = opts.language;
    }
    // get the length of the opening delimiter
    const openLen = open.length;
    if (!utils.startsWith(str, open, openLen)) {
        excerpt(file, opts);
        return file;
    }
    // if the next character after the opening delimiter is
    // a character from the delimiter, then it's not a front-
    // matter delimiter
    if (str.charAt(openLen) === open.slice(-1)) {
        return file;
    }
    // strip the opening delimiter
    str = str.slice(openLen);
    const len = str.length;
    // use the language defined after first delimiter, if it exists
    const language = matter.language(str, opts);
    if (language.name) {
        file.language = language.name;
        str = str.slice(language.raw.length);
    }
    // get the index of the closing delimiter
    let closeIndex = str.indexOf(close);
    if (closeIndex === -1) {
        closeIndex = len;
    }
    // get the raw front-matter block
    file.matter = str.slice(0, closeIndex);
    const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
    if (block === "") {
        file.isEmpty = true;
        file.empty = file.content;
        file.data = {};
    } else {
        // create file.data by parsing the raw file.matter block
        file.data = parse(file.language, file.matter, opts);
    }
    // update file.content
    if (closeIndex === len) {
        file.content = "";
    } else {
        file.content = str.slice(closeIndex + close.length);
        if (file.content[0] === "\r") {
            file.content = file.content.slice(1);
        }
        if (file.content[0] === "\n") {
            file.content = file.content.slice(1);
        }
    }
    excerpt(file, opts);
    if (opts.sections === true || typeof opts.section === "function") {
        sections(file, opts.section);
    }
    return file;
}
/**
 * Expose engines
 */ matter.engines = engines;
/**
 * Stringify an object to YAML or the specified language, and
 * append it to the given string. By default, only YAML and JSON
 * can be stringified. See the [engines](#engines) section to learn
 * how to stringify other languages.
 *
 * ```js
 * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
 * // results in:
 * // ---
 * // title: Home
 * // ---
 * // foo bar baz
 * ```
 * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
 * @param {Object} `data` Front matter to stringify.
 * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
 * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
 * @api public
 */ matter.stringify = function(file, data, options) {
    if (typeof file === "string") file = matter(file, options);
    return stringify(file, data, options);
};
/**
 * Synchronously read a file from the file system and parse
 * front matter. Returns the same object as the [main function](#matter).
 *
 * ```js
 * const file = matter.read('./content/blog-post.md');
 * ```
 * @param {String} `filepath` file path of the file to read.
 * @param {Object} `options` [Options](#options) to pass to gray-matter.
 * @return {Object} Returns [an object](#returned-object) with `data` and `content`
 * @api public
 */ matter.read = function(filepath, options) {
    const str = fs.readFileSync(filepath, "utf8");
    const file = matter(str, options);
    file.path = filepath;
    return file;
};
/**
 * Returns true if the given `string` has front matter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Boolean} True if front matter exists.
 * @api public
 */ matter.test = function(str, options) {
    return utils.startsWith(str, defaults(options).delimiters[0]);
};
/**
 * Detect the language to use, if one is defined after the
 * first front-matter delimiter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
 */ matter.language = function(str, options) {
    const opts = defaults(options);
    const open = opts.delimiters[0];
    if (matter.test(str)) {
        str = str.slice(open.length);
    }
    const language = str.slice(0, str.search(/\r?\n/));
    return {
        raw: language,
        name: language ? language.trim() : ""
    };
};
/**
 * Expose `matter`
 */ matter.cache = {};
matter.clearCache = function() {
    matter.cache = {};
};
module.exports = matter;


/***/ }),

/***/ 2289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const engines = __webpack_require__(1376);
const utils = __webpack_require__(5114);
module.exports = function(options) {
    const opts = Object.assign({}, options);
    // ensure that delimiters are an array
    opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
    if (opts.delimiters.length === 1) {
        opts.delimiters.push(opts.delimiters[0]);
    }
    opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
    opts.engines = Object.assign({}, engines, opts.parsers, opts.engines);
    return opts;
};


/***/ }),

/***/ 8198:
/***/ ((module) => {

"use strict";

module.exports = function(name, options) {
    let engine = options.engines[name] || options.engines[aliase(name)];
    if (typeof engine === "undefined") {
        throw new Error('gray-matter engine "' + name + '" is not registered');
    }
    if (typeof engine === "function") {
        engine = {
            parse: engine
        };
    }
    return engine;
};
function aliase(name) {
    switch(name.toLowerCase()){
        case "js":
        case "javascript":
            return "javascript";
        case "coffee":
        case "coffeescript":
        case "cson":
            return "coffee";
        case "yaml":
        case "yml":
            return "yaml";
        default:
            {
                return name;
            }
    }
}


/***/ }),

/***/ 1376:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

const yaml = __webpack_require__(3205);
/**
 * Default engines
 */ const engines = exports = module.exports;
/**
 * YAML
 */ engines.yaml = {
    parse: yaml.safeLoad.bind(yaml),
    stringify: yaml.safeDump.bind(yaml)
};
/**
 * JSON
 */ engines.json = {
    parse: JSON.parse.bind(JSON),
    stringify: function(obj1, options1) {
        const opts1 = Object.assign({
            replacer: null,
            space: 2
        }, options1);
        return JSON.stringify(obj1, opts1.replacer, opts1.space);
    }
};
/**
 * JavaScript
 */ engines.javascript = {
    parse: function parse(str, options, wrap) {
        /* eslint no-eval: 0 */ try {
            if (wrap !== false) {
                str = "(function() {\nreturn " + str.trim() + ";\n}());";
            }
            return eval(str) || {};
        } catch (err) {
            if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
                return parse(str, options, false);
            }
            throw new SyntaxError(err);
        }
    },
    stringify: function() {
        throw new Error("stringifying JavaScript is not supported");
    }
};


/***/ }),

/***/ 5597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const defaults = __webpack_require__(2289);
module.exports = function(file, options) {
    const opts = defaults(options);
    if (file.data == null) {
        file.data = {};
    }
    if (typeof opts.excerpt === "function") {
        return opts.excerpt(file, opts);
    }
    const sep = file.data.excerpt_separator || opts.excerpt_separator;
    if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
        return file;
    }
    const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
    // if enabled, get the excerpt defined after front-matter
    const idx = file.content.indexOf(delimiter);
    if (idx !== -1) {
        file.excerpt = file.content.slice(0, idx);
    }
    return file;
};


/***/ }),

/***/ 1394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getEngine = __webpack_require__(8198);
const defaults = __webpack_require__(2289);
module.exports = function(language, str, options) {
    const opts = defaults(options);
    const engine = getEngine(language, opts);
    if (typeof engine.parse !== "function") {
        throw new TypeError('expected "' + language + '.parse" to be a function');
    }
    return engine.parse(str, opts);
};


/***/ }),

/***/ 4824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const typeOf = __webpack_require__(9157);
const getEngine = __webpack_require__(8198);
const defaults = __webpack_require__(2289);
module.exports = function(file, data, options) {
    if (data == null && options == null) {
        switch(typeOf(file)){
            case "object":
                data = file.data;
                options = {};
                break;
            case "string":
                return file;
            default:
                {
                    throw new TypeError("expected file to be a string or object");
                }
        }
    }
    const str = file.content;
    const opts = defaults(options);
    if (data == null) {
        if (!opts.data) return file;
        data = opts.data;
    }
    const language = file.language || opts.language;
    const engine = getEngine(language, opts);
    if (typeof engine.stringify !== "function") {
        throw new TypeError('expected "' + language + '.stringify" to be a function');
    }
    data = Object.assign({}, file.data, data);
    const open = opts.delimiters[0];
    const close = opts.delimiters[1];
    const matter = engine.stringify(data, options).trim();
    let buf = "";
    if (matter !== "{}") {
        buf = newline(open) + newline(matter) + newline(close);
    }
    if (typeof file.excerpt === "string" && file.excerpt !== "") {
        if (str.indexOf(file.excerpt.trim()) === -1) {
            buf += newline(file.excerpt) + newline(close);
        }
    }
    return buf + newline(str);
};
function newline(str) {
    return str.slice(-1) !== "\n" ? str + "\n" : str;
}


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const typeOf = __webpack_require__(9157);
const stringify = __webpack_require__(4824);
const utils = __webpack_require__(5114);
/**
 * Normalize the given value to ensure an object is returned
 * with the expected properties.
 */ module.exports = function(file) {
    if (typeOf(file) !== "object") {
        file = {
            content: file
        };
    }
    if (typeOf(file.data) !== "object") {
        file.data = {};
    }
    // if file was passed as an object, ensure that
    // "file.content" is set
    if (file.contents && file.content == null) {
        file.content = file.contents;
    }
    // set non-enumerable properties on the file object
    utils.define(file, "orig", utils.toBuffer(file.content));
    utils.define(file, "language", file.language || "");
    utils.define(file, "matter", file.matter || "");
    utils.define(file, "stringify", function(data, options) {
        if (options && options.language) {
            file.language = options.language;
        }
        return stringify(file, data, options);
    });
    // strip BOM and ensure that "file.content" is a string
    file.content = utils.toString(file.content);
    file.isEmpty = false;
    file.excerpt = "";
    return file;
};


/***/ }),

/***/ 5114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const stripBom = __webpack_require__(5578);
const typeOf = __webpack_require__(9157);
exports.define = function(obj, key, val) {
    Reflect.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: val
    });
};
/**
 * Returns true if `val` is a buffer
 */ exports.isBuffer = function(val) {
    return typeOf(val) === "buffer";
};
/**
 * Returns true if `val` is an object
 */ exports.isObject = function(val) {
    return typeOf(val) === "object";
};
/**
 * Cast `input` to a buffer
 */ exports.toBuffer = function(input) {
    return typeof input === "string" ? Buffer.from(input) : input;
};
/**
 * Cast `val` to a string.
 */ exports.toString = function(input) {
    if (exports.isBuffer(input)) return stripBom(String(input));
    if (typeof input !== "string") {
        throw new TypeError("expected input to be a string or buffer");
    }
    return stripBom(input);
};
/**
 * Cast `val` to an array.
 */ exports.arrayify = function(val) {
    return val ? Array.isArray(val) ? val : [
        val
    ] : [];
};
/**
 * Returns true if `str` starts with `substr`.
 */ exports.startsWith = function(str, substr, len) {
    if (typeof len !== "number") len = substr.length;
    return str.slice(0, len) === substr;
};


/***/ }),

/***/ 3205:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var yaml = __webpack_require__(6455);
module.exports = yaml;


/***/ }),

/***/ 6455:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var loader = __webpack_require__(7473);
var dumper = __webpack_require__(9083);
function deprecated(name) {
    return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
}
module.exports.Type = __webpack_require__(2595);
module.exports.Schema = __webpack_require__(8417);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(8017);
module.exports.JSON_SCHEMA = __webpack_require__(2889);
module.exports.CORE_SCHEMA = __webpack_require__(657);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(2865);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(2214);
module.exports.load = loader.load;
module.exports.loadAll = loader.loadAll;
module.exports.safeLoad = loader.safeLoad;
module.exports.safeLoadAll = loader.safeLoadAll;
module.exports.dump = dumper.dump;
module.exports.safeDump = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(1020);
// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(8017);
module.exports.SAFE_SCHEMA = __webpack_require__(2865);
module.exports.DEFAULT_SCHEMA = __webpack_require__(2214);
// Deprecated functions from JS-YAML 1.x.x
module.exports.scan = deprecated("scan");
module.exports.parse = deprecated("parse");
module.exports.compose = deprecated("compose");
module.exports.addConstructor = deprecated("addConstructor");


/***/ }),

/***/ 5109:
/***/ ((module) => {

"use strict";

function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
    return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function repeat(string, count) {
    var result = "", cycle;
    for(cycle = 0; cycle < count; cycle += 1){
        result += string;
    }
    return result;
}
function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
module.exports.isNothing = isNothing;
module.exports.isObject = isObject;
module.exports.toArray = toArray;
module.exports.repeat = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend = extend;


/***/ }),

/***/ 9083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*eslint-disable no-use-before-define*/ var common = __webpack_require__(5109);
var YAMLException = __webpack_require__(1020);
var DEFAULT_FULL_SCHEMA = __webpack_require__(2214);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(2865);
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 0x09; /* Tab */ 
var CHAR_LINE_FEED = 0x0A; /* LF */ 
var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var CHAR_SPACE = 0x20; /* Space */ 
var CHAR_EXCLAMATION = 0x21; /* ! */ 
var CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var CHAR_SHARP = 0x23; /* # */ 
var CHAR_PERCENT = 0x25; /* % */ 
var CHAR_AMPERSAND = 0x26; /* & */ 
var CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var CHAR_ASTERISK = 0x2A; /* * */ 
var CHAR_COMMA = 0x2C; /* , */ 
var CHAR_MINUS = 0x2D; /* - */ 
var CHAR_COLON = 0x3A; /* : */ 
var CHAR_EQUALS = 0x3D; /* = */ 
var CHAR_GREATER_THAN = 0x3E; /* > */ 
var CHAR_QUESTION = 0x3F; /* ? */ 
var CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = "\\0";
ESCAPE_SEQUENCES[0x07] = "\\a";
ESCAPE_SEQUENCES[0x08] = "\\b";
ESCAPE_SEQUENCES[0x09] = "\\t";
ESCAPE_SEQUENCES[0x0A] = "\\n";
ESCAPE_SEQUENCES[0x0B] = "\\v";
ESCAPE_SEQUENCES[0x0C] = "\\f";
ESCAPE_SEQUENCES[0x0D] = "\\r";
ESCAPE_SEQUENCES[0x1B] = "\\e";
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = "\\\\";
ESCAPE_SEQUENCES[0x85] = "\\N";
ESCAPE_SEQUENCES[0xA0] = "\\_";
ESCAPE_SEQUENCES[0x2028] = "\\L";
ESCAPE_SEQUENCES[0x2029] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
];
function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
            tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
        }
        result[tag] = style;
    }
    return result;
}
function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = "x";
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = "u";
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = "U";
        length = 8;
    } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while(position < length){
        next = string.indexOf("\n", position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
    }
    return result;
}
function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
            return true;
        }
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */  || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) && c !== 0xFEFF && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return isPrintable(c) && c !== 0xFEFF && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
}
// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
        // Case: no block styles.
        // Check for disallowed characters to rule out plain and single.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
        }
    } else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i;
                }
            } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
        // Strings interpretable as another type have to be quoted;
        // e.g. the string 'true' vs. the boolean true.
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
    state.dump = function() {
        if (string.length === 0) {
            return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
            return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return testImplicitResolving(state, string);
        }
        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)){
            case STYLE_PLAIN:
                return string;
            case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
                return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
                return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
                return '"' + escapeString(string, lineWidth) + '"';
            default:
                throw new YAMLException("impossible error: invalid scalar style");
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
}
// (See the note for writeScalar.)
function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += "\n" + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += "\n";
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
        result += line.slice(start);
    }
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for(var i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
        if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */ ) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */ ) {
                // Combine the surrogate pair and store it escaped.
                result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
            }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
}
function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1){
        // Write only valid elements.
        if (writeNode(state, level, object[index], false, false)) {
            if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1){
        // Write only valid elements.
        if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += "-";
            } else {
                _result += "- ";
            }
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = _result || "[]"; // Empty sequence if no valid values.
}
function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (index !== 0) pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
            continue; // Skip this pair because of invalid key;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
            continue; // Skip this pair because of invalid value.
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
        // Default sorting
        objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
        // Custom sort function
        objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
        // Something is wrong
        throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (!compact || index !== 0) {
            pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue; // Skip this pair because of invalid key.
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += "?";
            } else {
                pairBuffer += "? ";
            }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue; // Skip this pair because of invalid value.
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ":";
        } else {
            pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}"; // Empty mapping if no valid pairs.
}
function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === "[object Function]") {
                    _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                } else {
                    throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
        detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
    } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                }
            } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
            }
        } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                }
            } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
            }
        } else if (type === "[object String]") {
            if (state.tag !== "?") {
                writeScalar(state, state.dump, level, iskey);
            }
        } else {
            if (state.skipInvalid) return false;
            throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
            state.dump = "!<" + state.tag + "> " + state.dump;
        }
    }
    return true;
}
function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1){
        state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
            }
        } else {
            objects.push(object);
            if (Array.isArray(object)) {
                for(index = 0, length = object.length; index < length; index += 1){
                    inspectNode(object[index], objects, duplicatesIndexes);
                }
            } else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1){
                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
            }
        }
    }
}
function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
    return "";
}
function safeDump(input, options) {
    return dump(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
module.exports.dump = dump;
module.exports.safeDump = safeDump;


/***/ }),

/***/ 1020:
/***/ ((module) => {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//

function YAMLException(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    // Include stack trace in error object
    if (Error.captureStackTrace) {
        // Chrome and NodeJS
        Error.captureStackTrace(this, this.constructor);
    } else {
        // FF, IE 10+ and Safari 6+. Fallback for others
        this.stack = new Error().stack || "";
    }
}
// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;
YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
        result += " " + this.mark.toString();
    }
    return result;
};
module.exports = YAMLException;


/***/ }),

/***/ 7473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*eslint-disable max-len,no-use-before-define*/ var common = __webpack_require__(5109);
var YAMLException = __webpack_require__(1020);
var Mark = __webpack_require__(8544);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(2865);
var DEFAULT_FULL_SCHEMA = __webpack_require__(2214);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
    return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) {
        return lc - 0x61 + 10;
    }
    return -1;
}
function escapedHexLen(c) {
    if (c === 0x78 /* x */ ) {
        return 2;
    }
    if (c === 0x75 /* u */ ) {
        return 4;
    }
    if (c === 0x55 /* U */ ) {
        return 8;
    }
    return 0;
}
function fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    return -1;
}
function simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? "\x00" : c === 0x61 /* a */  ? "\x07" : c === 0x62 /* b */  ? "\b" : c === 0x74 /* t */  ? "	" : c === 0x09 /* Tab */  ? "	" : c === 0x6E /* n */  ? "\n" : c === 0x76 /* v */  ? "\v" : c === 0x66 /* f */  ? "\f" : c === 0x72 /* r */  ? "\r" : c === 0x65 /* e */  ? "\x1b" : c === 0x20 /* Space */  ? " " : c === 0x22 /* " */  ? '"' : c === 0x2F /* / */  ? "/" : c === 0x5C /* \ */  ? "\\" : c === 0x4E /* N */  ? "\x85" : c === 0x5F /* _ */  ? "\xa0" : c === 0x4C /* L */  ? "\u2028" : c === 0x50 /* P */  ? "\u2029" : "";
}
function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
        return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for(var i = 0; i < 256; i++){
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function throwError(state, message) {
    throw generateError(state, message);
}
function throwWarning(state, message) {
    if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
    }
}
var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
            throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
            throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
            throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
            throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
            throwWarning(state, "unsupported YAML version of the document");
        }
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
            throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
    }
};
function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
            for(_position = 0, _length = _result.length; _position < _length; _position += 1){
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
                    throwError(state, "expected valid JSON character");
                }
            }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
    }
}
function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) {
                throwError(state, "nested arrays are not supported inside keys");
            }
            if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                keyNode[index] = "[object Object]";
            }
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
        _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
            for(index = 0, quantity = valueNode.length; index < quantity; index += 1){
                mergeMappings(state, _result, valueNode[index], overridableKeys);
            }
        } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
        }
    } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
    }
    return _result;
}
function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) {
        state.position++;
    } else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) {
            state.position++;
        }
    } else {
        throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while(is_WHITE_SPACE(ch)){
            ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);
        }
        if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else {
            break;
        }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
}
function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
        }
    }
    return false;
}
function writeFoldedLines(state, count) {
    if (count === 1) {
        state.result += " ";
    } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
    }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) {
        return false;
    }
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
        }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
            }
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
                break;
            }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
        } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
        return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else {
                return true;
            }
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
            // TODO: rework to inline fn with no type cast?
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                    } else {
                        throwError(state, "expected hexadecimal character");
                    }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
            } else {
                throwError(state, "unknown escape sequence");
            }
            captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else {
        return false;
    }
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
        } else if (!readNext) {
            throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
            _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else {
            readNext = false;
        }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) {
        folding = false;
    } else if (ch === 0x3E /* > */ ) {
        folding = true;
    } else {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if (CHOMPING_CLIP === chomping) {
                chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
                throwError(state, "repeat of a chomping mode identifier");
            }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
                throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else {
                throwError(state, "repeat of an indentation width identifier");
            }
        } else {
            break;
        }
    }
    if (is_WHITE_SPACE(ch)) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (!is_EOL(ch) && ch !== 0);
        }
    }
    while(ch !== 0){
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                    state.result += "\n";
                }
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat("\n", emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) {
                    state.result += " ";
                }
            // Several line breaks - perceive as different lines.
            } else {
                state.result += common.repeat("\n", emptyLines);
            }
        // Literal style: just add exact number of line breaks between content lines.
        } else {
            // Keep all line breaks except the header line break.
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!is_EOL(ch) && ch !== 0){
            ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (ch !== 0x2D /* - */ ) {
            break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
            break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
    }
    return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        _pos = state.position;
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else {
                throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            }
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while(is_WHITE_SPACE(ch)){
                    ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                        throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    }
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) {
                    throwError(state, "can not read an implicit mapping pair; a colon is missed");
                } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) {
                throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        } else {
            break; // Reading is done. Go to the epilogue.
        }
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                    keyNode = state.result;
                } else {
                    valueNode = state.result;
                }
            }
            if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
    }
    return detected;
}
function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
    } else {
        tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (ch !== 0 && ch !== 0x3E /* > */ );
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else {
            throwError(state, "unexpected end of the stream within a verbatim tag");
        }
    } else {
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, "named tag handle cannot contain such characters");
                    }
                    isNamed = true;
                    _position = state.position + 1;
                } else {
                    throwError(state, "tag suffix cannot contain exclamation marks");
                }
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, "tag suffix cannot contain flow indicator characters");
        }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
        state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
}
function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
        state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
                indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
            }
        }
    }
    if (indentStatus === 1) {
        while(readTagProperty(state) || readAnchorProperty(state)){
            if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                }
            } else {
                allowBlockCollections = false;
            }
        }
    }
    if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
        } else {
            flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
            } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                    hasContent = true;
                } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                        throwError(state, "alias node should not have any properties");
                    }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) {
                        state.tag = "?";
                    }
                }
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        } else if (indentStatus === 0) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
    }
    if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== "scalar") {
                throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            }
            for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) {
                        state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                }
            }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) {
                throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            }
            if (!type.resolve(state.result)) {
                throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        } else {
            throwError(state, "unknown tag !<" + state.tag + ">");
        }
    }
    if (state.listener !== null) {
        state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) {
            break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
            throwError(state, "directive name must not be less than one character in length");
        }
        while(ch !== 0){
            while(is_WHITE_SPACE(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 0x23 /* # */ ) {
                do {
                    ch = state.input.charCodeAt(++state.position);
                }while (ch !== 0 && !is_EOL(ch));
                break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !is_WS_OR_EOL(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
    } else {
        return;
    }
}
function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) {
            input += "\n";
        }
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) {
            input = input.slice(1);
        }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\x00");
    if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += "\x00";
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1){
        readDocument(state);
    }
    return state.documents;
}
function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
        return documents;
    }
    for(var index = 0, length = documents.length; index < length; index += 1){
        iterator(documents[index]);
    }
}
function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
        /*eslint-disable no-undefined*/ return undefined;
    } else if (documents.length === 1) {
        return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
}
function safeLoadAll(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    return loadAll(input, iterator, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
function safeLoad(input, options) {
    return load(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
module.exports.loadAll = loadAll;
module.exports.load = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad = safeLoad;


/***/ }),

/***/ 8544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var common = __webpack_require__(5109);
function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
}
Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer) return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while(start > 0 && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1){
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
        }
    }
    tail = "";
    end = this.position;
    while(end < this.buffer.length && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1){
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
        }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
};
Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
        where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
            where += ":\n" + snippet;
        }
    }
    return where;
};
module.exports = Mark;


/***/ }),

/***/ 8417:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*eslint-disable max-len*/ var common = __webpack_require__(5109);
var YAMLException = __webpack_require__(1020);
var Type = __webpack_require__(2595);
function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
            }
        });
        result.push(currentType);
    });
    return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
    });
}
function compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
    }, index, length;
    function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for(index = 0, length = arguments.length; index < length; index += 1){
        arguments[index].forEach(collectType);
    }
    return result;
}
function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema.DEFAULT = null;
Schema.create = function createSchema() {
    var schemas, types;
    switch(arguments.length){
        case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
        case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
        default:
            throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas = common.toArray(schemas);
    types = common.toArray(types);
    if (!schemas.every(function(schema) {
        return schema instanceof Schema;
    })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
        return type instanceof Type;
    })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema({
        include: schemas,
        explicit: types
    });
};
module.exports = Schema;


/***/ }),

/***/ 657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.

var Schema = __webpack_require__(8417);
module.exports = new Schema({
    include: [
        __webpack_require__(2889)
    ]
});


/***/ }),

/***/ 2214:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.

var Schema = __webpack_require__(8417);
module.exports = Schema.DEFAULT = new Schema({
    include: [
        __webpack_require__(2865)
    ],
    explicit: [
        __webpack_require__(6957),
        __webpack_require__(3224),
        __webpack_require__(3660)
    ]
});


/***/ }),

/***/ 2865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)

var Schema = __webpack_require__(8417);
module.exports = new Schema({
    include: [
        __webpack_require__(657)
    ],
    implicit: [
        __webpack_require__(4926),
        __webpack_require__(7036)
    ],
    explicit: [
        __webpack_require__(3644),
        __webpack_require__(6185),
        __webpack_require__(5108),
        __webpack_require__(3164)
    ]
});


/***/ }),

/***/ 8017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346

var Schema = __webpack_require__(8417);
module.exports = new Schema({
    explicit: [
        __webpack_require__(3023),
        __webpack_require__(7165),
        __webpack_require__(6646)
    ]
});


/***/ }),

/***/ 2889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

var Schema = __webpack_require__(8417);
module.exports = new Schema({
    include: [
        __webpack_require__(8017)
    ],
    implicit: [
        __webpack_require__(1174),
        __webpack_require__(9933),
        __webpack_require__(6098),
        __webpack_require__(5138)
    ]
});


/***/ }),

/***/ 2595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var YAMLException = __webpack_require__(1020);
var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
];
var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
];
function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
        Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
                result[String(alias)] = style;
            });
        });
    }
    return result;
}
function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
    });
    // TODO: Add tag format check.
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
        return true;
    };
    this.construct = options["construct"] || function(data) {
        return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
}
module.exports = Type;


/***/ }),

/***/ 3644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*eslint-disable no-bitwise*/ var NodeBuffer;
try {
    // A trick for browserified version, to not include `Buffer` shim
    var _require = undefined;
    NodeBuffer = (__webpack_require__(4300).Buffer);
} catch (__) {}
var Type = __webpack_require__(2595);
// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) {
        result.push(bits >> 4 & 0xFF);
    }
    // Wrap into Buffer for NodeJS and leave Array for browser
    if (NodeBuffer) {
        // Support node 6.+ Buffer API when available
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
}
function representYamlBinary(object /*, style*/ ) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
}
module.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
});


/***/ }),

/***/ 9933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
}
module.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? "true" : "false";
        },
        uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
            return object ? "True" : "False";
        }
    },
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 5138:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var common = __webpack_require__(5109);
var Type = __webpack_require__(2595);
var YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
"^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + // .2e4, .2
// special case, seems not from spec
"|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + // 20:59
"|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + // .inf
"|[-+]?\\.(?:inf|Inf|INF)" + // .nan
"|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
        return false;
    }
    return true;
}
function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
    }
    if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
        return NaN;
    } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
        switch(style){
            case "lowercase":
                return ".nan";
            case "uppercase":
                return ".NAN";
            case "camelcase":
                return ".NaN";
        }
    } else if (Number.POSITIVE_INFINITY === object) {
        switch(style){
            case "lowercase":
                return ".inf";
            case "uppercase":
                return ".INF";
            case "camelcase":
                return ".Inf";
        }
    } else if (Number.NEGATIVE_INFINITY === object) {
        switch(style){
            case "lowercase":
                return "-.inf";
            case "uppercase":
                return "-.INF";
            case "camelcase":
                return "-.Inf";
        }
    } else if (common.isNegativeZero(object)) {
        return "-0.0";
    }
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
module.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 6098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var common = __webpack_require__(5109);
var Type = __webpack_require__(2595);
function isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === "-" || ch === "+") {
        ch = data[++index];
    }
    if (ch === "0") {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === "b") {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "x") {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        // base 8
        for(; index < max; index++){
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
        }
        return hasDigits && ch !== "_";
    }
    // base 10 (except 0) or base 60
    // value should not start with `_`;
    if (ch === "_") return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === "_") continue;
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index))) {
            return false;
        }
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === "_") return false;
    // if !base60 - done;
    if (ch !== ":") return true;
    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseInt(value, 10);
}
function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
}
module.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [
            2,
            "bin"
        ],
        octal: [
            8,
            "oct"
        ],
        decimal: [
            10,
            "dec"
        ],
        hexadecimal: [
            16,
            "hex"
        ]
    }
});


/***/ }),

/***/ 3660:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var esprima;
// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
    // workaround to exclude package from browserify list.
    var _require = undefined;
    esprima = __webpack_require__(654);
} catch (_) {
    /* eslint-disable no-redeclare */ /* global window */ if (false) {}
}
var Type = __webpack_require__(2595);
function resolveJavascriptFunction(data) {
    if (data === null) return false;
    try {
        var source = "(" + data + ")", ast = esprima.parse(source, {
            range: true
        });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
function constructJavascriptFunction(data) {
    /*jslint evil:true*/ var source = "(" + data + ")", ast = esprima.parse(source, {
        range: true
    }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === "BlockStatement") {
        /*eslint-disable no-new-func*/ return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/ return new Function(params, "return " + source.slice(body[0], body[1]));
}
function representJavascriptFunction(object /*, style*/ ) {
    return object.toString();
}
function isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
}
module.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
});


/***/ }),

/***/ 3224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
function resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
    }
    return true;
}
function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
}
function representJavascriptRegExp(object /*, style*/ ) {
    var result = "/" + object.source + "/";
    if (object.global) result += "g";
    if (object.multiline) result += "m";
    if (object.ignoreCase) result += "i";
    return result;
}
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}
module.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
});


/***/ }),

/***/ 6957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
function resolveJavascriptUndefined() {
    return true;
}
function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/ return undefined;
}
function representJavascriptUndefined() {
    return "";
}
function isUndefined(object) {
    return typeof object === "undefined";
}
module.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
});


/***/ }),

/***/ 6646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
module.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
        return data !== null ? data : {};
    }
});


/***/ }),

/***/ 7036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
function resolveYamlMerge(data) {
    return data === "<<" || data === null;
}
module.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
});


/***/ }),

/***/ 1174:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
    return null;
}
function isNull(object) {
    return object === null;
}
module.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
        canonical: function() {
            return "~";
        },
        lowercase: function() {
            return "null";
        },
        uppercase: function() {
            return "NULL";
        },
        camelcase: function() {
            return "Null";
        }
    },
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 6185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;
function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]") return false;
        for(pairKey in pair){
            if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;
                else return false;
            }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function constructYamlOmap(data) {
    return data !== null ? data : [];
}
module.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
});


/***/ }),

/***/ 5108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
var _toString = Object.prototype.toString;
function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
module.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
});


/***/ }),

/***/ 7165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
module.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
        return data !== null ? data : [];
    }
});


/***/ }),

/***/ 3164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object){
        if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false;
        }
    }
    return true;
}
function constructYamlSet(data) {
    return data !== null ? data : {};
}
module.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
});


/***/ }),

/***/ 3023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
module.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
        return data !== null ? data : "";
    }
});


/***/ }),

/***/ 4926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Type = __webpack_require__(2595);
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + // [1] year
"-([0-9][0-9])" + // [2] month
"-([0-9][0-9])$"); // [3] day
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + // [1] year
"-([0-9][0-9]?)" + // [2] month
"-([0-9][0-9]?)" + // [3] day
"(?:[Tt]|[ \\t]+)" + // ...
"([0-9][0-9]?)" + // [4] hour
":([0-9][0-9])" + // [5] minute
":([0-9][0-9])" + // [6] second
"(?:\\.([0-9]*))?" + // [7] fraction
"(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + // [8] tz [9] tz_sign [10] tz_hour
"(?::([0-9][0-9]))?))?$"); // [11] tz_minute
function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
    }
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3){
            fraction += "0";
        }
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
module.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
});


/***/ }),

/***/ 4601:
/***/ ((module) => {

"use strict";
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ 
module.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
};


/***/ }),

/***/ 9157:
/***/ ((module) => {

"use strict";

var toString = Object.prototype.toString;
module.exports = function kindOf(val) {
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    var type = typeof val;
    if (type === "boolean") return "boolean";
    if (type === "string") return "string";
    if (type === "number") return "number";
    if (type === "symbol") return "symbol";
    if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
    }
    if (isArray(val)) return "array";
    if (isBuffer(val)) return "buffer";
    if (isArguments(val)) return "arguments";
    if (isDate(val)) return "date";
    if (isError(val)) return "error";
    if (isRegexp(val)) return "regexp";
    switch(ctorName(val)){
        case "Symbol":
            return "symbol";
        case "Promise":
            return "promise";
        // Set, Map, WeakSet, WeakMap
        case "WeakMap":
            return "weakmap";
        case "WeakSet":
            return "weakset";
        case "Map":
            return "map";
        case "Set":
            return "set";
        // 8-bit typed arrays
        case "Int8Array":
            return "int8array";
        case "Uint8Array":
            return "uint8array";
        case "Uint8ClampedArray":
            return "uint8clampedarray";
        // 16-bit typed arrays
        case "Int16Array":
            return "int16array";
        case "Uint16Array":
            return "uint16array";
        // 32-bit typed arrays
        case "Int32Array":
            return "int32array";
        case "Uint32Array":
            return "uint32array";
        case "Float32Array":
            return "float32array";
        case "Float64Array":
            return "float64array";
    }
    if (isGeneratorObj(val)) {
        return "generator";
    }
    // Non-plain objects
    type = toString.call(val);
    switch(type){
        case "[object Object]":
            return "object";
        // iterators
        case "[object Map Iterator]":
            return "mapiterator";
        case "[object Set Iterator]":
            return "setiterator";
        case "[object String Iterator]":
            return "stringiterator";
        case "[object Array Iterator]":
            return "arrayiterator";
    }
    // other
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isArray(val) {
    if (Array.isArray) return Array.isArray(val);
    return val instanceof Array;
}
function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function isRegexp(val) {
    if (val instanceof RegExp) return true;
    return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function isGeneratorFn(name, val) {
    return ctorName(name) === "GeneratorFunction";
}
function isGeneratorObj(val) {
    return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function isArguments(val) {
    try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
            return true;
        }
    } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
            return true;
        }
    }
    return false;
}
/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */ function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
    }
    return false;
}


/***/ }),

/***/ 5985:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Modified from https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeRegister.js

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createProxy", ({
    enumerable: true,
    get: function() {
        return createProxy;
    }
}));
const CLIENT_REFERENCE = Symbol.for("react.client.reference");
const PROMISE_PROTOTYPE = Promise.prototype;
const deepProxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            // These names are read by the Flight runtime if you end up using the exports object.
            case "$$typeof":
                // These names are a little too common. We should probably have a way to
                // have the Flight runtime extract the inner target instead.
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            case "displayName":
                return undefined;
            // We need to special case this because createElement reads it if we pass this
            // reference.
            case "defaultProps":
                return undefined;
            // Avoid this attempting to be serialized.
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                // @ts-ignore
                return Object.prototype[Symbol.toPrimitive];
            case "Provider":
                throw new Error(`Cannot render a Client Context Provider on the Server. ` + `Instead, you can export a Client Component wrapper ` + `that itself renders a Client Context Provider.`);
            default:
                break;
        }
        const expression = String(target.name) + "." + String(name);
        throw new Error(`Cannot access ${expression} on the server. ` + "You cannot dot into a client module from a server component. " + "You can only pass the imported name through.");
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
const proxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            // These names are read by the Flight runtime if you end up using the exports object.
            case "$$typeof":
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            // We need to special case this because createElement reads it if we pass this
            // reference.
            case "defaultProps":
                return undefined;
            // Avoid this attempting to be serialized.
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                // @ts-ignore
                return Object.prototype[Symbol.toPrimitive];
            case "__esModule":
                // Something is conditionally checking which export to use. We'll pretend to be
                // an ESM compat module but then we'll check again on the client.
                const moduleId = target.$$id;
                target.default = Object.defineProperties(function() {
                    throw new Error(`Attempted to call the default export of ${moduleId} from the server ` + `but it's on the client. It's not possible to invoke a client function from ` + `the server, it can only be rendered as a Component or passed to props of a ` + `Client Component.`);
                }, {
                    $$typeof: {
                        value: CLIENT_REFERENCE
                    },
                    // This a placeholder value that tells the client to conditionally use the
                    // whole object or just the default export.
                    $$id: {
                        value: target.$$id + "#"
                    },
                    $$async: {
                        value: target.$$async
                    }
                });
                return true;
            case "then":
                if (target.then) {
                    // Use a cached value
                    return target.then;
                }
                if (!target.$$async) {
                    // If this module is expected to return a Promise (such as an AsyncModule) then
                    // we should resolve that with a client reference that unwraps the Promise on
                    // the client.
                    const clientReference = Object.defineProperties({}, {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: true
                        }
                    });
                    const proxy = new Proxy(clientReference, proxyHandlers);
                    // Treat this as a resolved Promise for React's use()
                    target.status = "fulfilled";
                    target.value = proxy;
                    const then = target.then = Object.defineProperties(function then(resolve, _reject) {
                        // Expose to React.
                        return Promise.resolve(resolve(proxy));
                    }, // export then we should treat it as a reference to that name.
                    {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: false
                        }
                    });
                    return then;
                } else {
                    // Since typeof .then === 'function' is a feature test we'd continue recursing
                    // indefinitely if we return a function. Instead, we return an object reference
                    // if we check further.
                    return undefined;
                }
            default:
                break;
        }
        let cachedReference = target[name];
        if (!cachedReference) {
            const reference = Object.defineProperties(function() {
                throw new Error(`Attempted to call ${String(name)}() from the server but ${String(name)} is on the client. ` + `It's not possible to invoke a client function from the server, it can ` + `only be rendered as a Component or passed to props of a Client Component.`);
            }, {
                $$typeof: {
                    value: CLIENT_REFERENCE
                },
                $$id: {
                    value: target.$$id + "#" + name
                },
                $$async: {
                    value: target.$$async
                }
            });
            cachedReference = target[name] = new Proxy(reference, deepProxyHandlers);
        }
        return cachedReference;
    },
    getPrototypeOf (_target) {
        // Pretend to be a Promise in case anyone asks.
        return PROMISE_PROTOTYPE;
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
function createProxy(moduleId) {
    const clientReference = Object.defineProperties({}, {
        $$typeof: {
            value: CLIENT_REFERENCE
        },
        // Represents the whole Module object instead of a particular import.
        $$id: {
            value: moduleId
        },
        $$async: {
            value: false
        }
    });
    return new Proxy(clientReference, proxyHandlers);
} //# sourceMappingURL=module-proxy.js.map


/***/ }),

/***/ 8829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
const { createProxy  } = __webpack_require__(5985);
module.exports = createProxy("/home/runner/work/movie42.github.io/movie42.github.io/node_modules/next/dist/client/components/app-router.js");
 //# sourceMappingURL=app-router.js.map


/***/ }),

/***/ 8412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
const { createProxy  } = __webpack_require__(5985);
module.exports = createProxy("/home/runner/work/movie42.github.io/movie42.github.io/node_modules/next/dist/client/components/error-boundary.js");
 //# sourceMappingURL=error-boundary.js.map


/***/ }),

/***/ 5815:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_ERROR_CODE: function() {
        return DYNAMIC_ERROR_CODE;
    },
    DynamicServerError: function() {
        return DynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(type){
        super("Dynamic server usage: " + type);
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map


/***/ }),

/***/ 5226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
const { createProxy  } = __webpack_require__(5985);
module.exports = createProxy("/home/runner/work/movie42.github.io/movie42.github.io/node_modules/next/dist/client/components/layout-router.js");
 //# sourceMappingURL=layout-router.js.map


/***/ }),

/***/ 2872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
const { createProxy  } = __webpack_require__(5985);
module.exports = createProxy("/home/runner/work/movie42.github.io/movie42.github.io/node_modules/next/dist/client/components/render-from-template-context.js");
 //# sourceMappingURL=render-from-template-context.js.map


/***/ }),

/***/ 5183:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createSearchParamsBailoutProxy", ({
    enumerable: true,
    get: function() {
        return createSearchParamsBailoutProxy;
    }
}));
const _staticgenerationbailout = __webpack_require__(9282);
function createSearchParamsBailoutProxy() {
    return new Proxy({}, {
        get (_target, prop) {
            // React adds some properties on the object when serializing for client components
            if (typeof prop === "string") {
                (0, _staticgenerationbailout.staticGenerationBailout)("searchParams." + prop);
            }
        }
    });
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=searchparams-bailout-proxy.js.map


/***/ }),

/***/ 9282:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "staticGenerationBailout", ({
    enumerable: true,
    get: function() {
        return staticGenerationBailout;
    }
}));
const _hooksservercontext = __webpack_require__(5815);
const _staticgenerationasyncstorage = __webpack_require__(1839);
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args);
        this.code = "NEXT_STATIC_GEN_BAILOUT";
    }
}
const staticGenerationBailout = (reason, opts)=>{
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {
        const { dynamic ="error" , link  } = opts || {};
        const suffix = link ? " See more info here: " + link : "";
        throw new StaticGenBailoutError('Page with `dynamic = "' + dynamic + "\"` couldn't be rendered statically because it used `" + reason + "`." + suffix);
    }
    if (staticGenerationStore) {
        staticGenerationStore.revalidate = 0;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(reason);
        staticGenerationStore.dynamicUsageDescription = reason;
        staticGenerationStore.dynamicUsageStack = err.stack;
        throw err;
    }
    return false;
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map


/***/ }),

/***/ 3785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
const { createProxy  } = __webpack_require__(5985);
module.exports = createProxy("/home/runner/work/movie42.github.io/movie42.github.io/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js");
 //# sourceMappingURL=static-generation-searchparams-bailout-provider.js.map


/***/ }),

/***/ 4997:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react-dom-server-rendering-stub.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var d = {
    usingClientEntryPoint: !1,
    Events: null,
    Dispatcher: {
        current: null
    }
};
function e(c) {
    for(var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, a = 1; a < arguments.length; a++)b += "&args[]=" + encodeURIComponent(arguments[a]);
    return "Minified React error #" + c + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var f = d.Dispatcher;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = d;
exports.createPortal = function() {
    throw Error(e(448));
};
exports.experimental_useFormStatus = function() {
    throw Error(e(248));
};
exports.flushSync = function() {
    throw Error(e(449));
};
exports.preconnect = function(c, b) {
    var a = f.current;
    a && a.preconnect(c, b);
};
exports.prefetchDNS = function(c) {
    var b = f.current;
    b && b.prefetchDNS(c);
};
exports.preinit = function(c, b) {
    var a = f.current;
    a && a.preinit(c, b);
};
exports.preload = function(c, b) {
    var a = f.current;
    a && a.preload(c, b);
};
exports.version = "18.3.0-canary-16d053d59-20230506";


/***/ }),

/***/ 3592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(4997);
} else {}


/***/ }),

/***/ 1336:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-server-dom-webpack-server.edge.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var aa = __webpack_require__(4212), ba = __webpack_require__(3592), l = null, m = 0;
function n(a, b) {
    if (0 !== b.length) if (512 < b.length) 0 < m && (a.enqueue(new Uint8Array(l.buffer, 0, m)), l = new Uint8Array(512), m = 0), a.enqueue(b);
    else {
        var d = l.length - m;
        d < b.length && (0 === d ? a.enqueue(l) : (l.set(b.subarray(0, d), m), a.enqueue(l), b = b.subarray(d)), l = new Uint8Array(512), m = 0);
        l.set(b, m);
        m += b.length;
    }
    return !0;
}
var p = new TextEncoder;
function ca(a, b) {
    "function" === typeof a.error ? a.error(b) : a.close();
}
var q = JSON.stringify;
function da(a, b, d) {
    a = q(d, a.toJSON);
    b = b.toString(16) + ":" + a + "\n";
    return p.encode(b);
}
function t(a, b, d) {
    a = q(d);
    b = b.toString(16) + ":" + a + "\n";
    return p.encode(b);
}
var u = Symbol.for("react.client.reference"), ea = Symbol.for("react.server.reference"), ka = {
    prefetchDNS: fa,
    preconnect: ha,
    preload: ia,
    preinit: ja
};
function fa(a, b) {
    if ("string" === typeof a) {
        var d = v();
        if (d) {
            var c = d.hints, e = "D" + a;
            c.has(e) || (c.add(e), b ? A(d, "D", [
                a,
                b
            ]) : A(d, "D", a), B(d));
        }
    }
}
function ha(a, b) {
    if ("string" === typeof a) {
        var d = v();
        if (d) {
            var c = d.hints, e = null == b || "string" !== typeof b.crossOrigin ? null : "use-credentials" === b.crossOrigin ? "use-credentials" : "";
            e = "C" + (null === e ? "null" : e) + "|" + a;
            c.has(e) || (c.add(e), b ? A(d, "C", [
                a,
                b
            ]) : A(d, "C", a), B(d));
        }
    }
}
function ia(a, b) {
    if ("string" === typeof a) {
        var d = v();
        if (d) {
            var c = d.hints, e = "L" + a;
            c.has(e) || (c.add(e), A(d, "L", [
                a,
                b
            ]), B(d));
        }
    }
}
function ja(a, b) {
    if ("string" === typeof a) {
        var d = v();
        if (d) {
            var c = d.hints, e = "I" + a;
            c.has(e) || (c.add(e), A(d, "I", [
                a,
                b
            ]), B(d));
        }
    }
}
var la = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Dispatcher, C = "function" === typeof AsyncLocalStorage, na = C ? new AsyncLocalStorage : null, D = Symbol.for("react.element"), oa = Symbol.for("react.fragment"), pa = Symbol.for("react.provider"), qa = Symbol.for("react.server_context"), ra = Symbol.for("react.forward_ref"), sa = Symbol.for("react.suspense"), ta = Symbol.for("react.suspense_list"), ua = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), va = Symbol.for("react.default_value"), wa = Symbol.for("react.memo_cache_sentinel"), xa = Symbol.iterator, F = null;
function G(a, b) {
    if (a !== b) {
        a.context._currentValue = a.parentValue;
        a = a.parent;
        var d = b.parent;
        if (null === a) {
            if (null !== d) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
            if (null === d) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
            G(a, d);
            b.context._currentValue = b.value;
        }
    }
}
function ya(a) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    null !== a && ya(a);
}
function za(a) {
    var b = a.parent;
    null !== b && za(b);
    a.context._currentValue = a.value;
}
function Aa(a, b) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === b.depth ? G(a, b) : Aa(a, b);
}
function Ba(a, b) {
    var d = b.parent;
    if (null === d) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === d.depth ? G(a, d) : Ba(a, d);
    b.context._currentValue = b.value;
}
function H(a) {
    var b = F;
    b !== a && (null === b ? za(a) : null === a ? ya(b) : b.depth === a.depth ? G(b, a) : b.depth > a.depth ? Aa(b, a) : Ba(b, a), F = a);
}
function Ca(a, b) {
    var d = a._currentValue;
    a._currentValue = b;
    var c = F;
    return F = a = {
        parent: c,
        depth: null === c ? 0 : c.depth + 1,
        context: a,
        parentValue: d,
        value: b
    };
}
var Da = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`");
function Ea() {}
function Fa(a, b, d) {
    d = a[d];
    void 0 === d ? a.push(b) : d !== b && (b.then(Ea, Ea), b = d);
    switch(b.status){
        case "fulfilled":
            return b.value;
        case "rejected":
            throw b.reason;
        default:
            if ("string" !== typeof b.status) switch(a = b, a.status = "pending", a.then(function(c) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "fulfilled";
                    e.value = c;
                }
            }, function(c) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "rejected";
                    e.reason = c;
                }
            }), b.status){
                case "fulfilled":
                    return b.value;
                case "rejected":
                    throw b.reason;
            }
            I = b;
            throw Da;
    }
}
var I = null;
function Ga() {
    if (null === I) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
    var a = I;
    I = null;
    return a;
}
var J = null, K = 0, L = null;
function Ha() {
    var a = L;
    L = null;
    return a;
}
function Ia(a) {
    return a._currentValue;
}
var Ma = {
    useMemo: function(a) {
        return a();
    },
    useCallback: function(a) {
        return a;
    },
    useDebugValue: function() {},
    useDeferredValue: M,
    useTransition: M,
    readContext: Ia,
    useContext: Ia,
    useReducer: M,
    useRef: M,
    useState: M,
    useInsertionEffect: M,
    useLayoutEffect: M,
    useImperativeHandle: M,
    useEffect: M,
    useId: Ja,
    useMutableSource: M,
    useSyncExternalStore: M,
    useCacheRefresh: function() {
        return Ka;
    },
    useMemoCache: function(a) {
        for(var b = Array(a), d = 0; d < a; d++)b[d] = wa;
        return b;
    },
    use: La
};
function M() {
    throw Error("This Hook is not supported in Server Components.");
}
function Ka() {
    throw Error("Refreshing the cache is not supported in Server Components.");
}
function Ja() {
    if (null === J) throw Error("useId can only be used while React is rendering");
    var a = J.identifierCount++;
    return ":" + J.identifierPrefix + "S" + a.toString(32) + ":";
}
function La(a) {
    if (null !== a && "object" === typeof a || "function" === typeof a) {
        if ("function" === typeof a.then) {
            var b = K;
            K += 1;
            null === L && (L = []);
            return Fa(L, a, b);
        }
        if (a.$$typeof === qa) return a._currentValue;
    }
    throw Error("An unsupported type was passed to use(): " + String(a));
}
function Na() {
    return (new AbortController).signal;
}
function Oa() {
    var a = v();
    return a ? a.cache : new Map;
}
var Pa = {
    getCacheSignal: function() {
        var a = Oa(), b = a.get(Na);
        void 0 === b && (b = Na(), a.set(Na, b));
        return b;
    },
    getCacheForType: function(a) {
        var b = Oa(), d = b.get(a);
        void 0 === d && (d = a(), b.set(a, d));
        return d;
    }
}, Qa = Array.isArray;
function Ra(a) {
    return Object.prototype.toString.call(a).replace(/^\[object (.*)\]$/, function(b, d) {
        return d;
    });
}
function Sa(a) {
    switch(typeof a){
        case "string":
            return JSON.stringify(10 >= a.length ? a : a.slice(0, 10) + "...");
        case "object":
            if (Qa(a)) return "[...]";
            a = Ra(a);
            return "Object" === a ? "{...}" : a;
        case "function":
            return "function";
        default:
            return String(a);
    }
}
function N(a) {
    if ("string" === typeof a) return a;
    switch(a){
        case sa:
            return "Suspense";
        case ta:
            return "SuspenseList";
    }
    if ("object" === typeof a) switch(a.$$typeof){
        case ra:
            return N(a.render);
        case ua:
            return N(a.type);
        case E:
            var b = a._payload;
            a = a._init;
            try {
                return N(a(b));
            } catch (d) {}
    }
    return "";
}
function O(a, b) {
    var d = Ra(a);
    if ("Object" !== d && "Array" !== d) return d;
    d = -1;
    var c = 0;
    if (Qa(a)) {
        var e = "[";
        for(var f = 0; f < a.length; f++){
            0 < f && (e += ", ");
            var g = a[f];
            g = "object" === typeof g && null !== g ? O(g) : Sa(g);
            "" + f === b ? (d = e.length, c = g.length, e += g) : e = 10 > g.length && 40 > e.length + g.length ? e + g : e + "...";
        }
        e += "]";
    } else if (a.$$typeof === D) e = "<" + N(a.type) + "/>";
    else {
        e = "{";
        f = Object.keys(a);
        for(g = 0; g < f.length; g++){
            0 < g && (e += ", ");
            var h = f[g], k = JSON.stringify(h);
            e += ('"' + h + '"' === k ? h : k) + ": ";
            k = a[h];
            k = "object" === typeof k && null !== k ? O(k) : Sa(k);
            h === b ? (d = e.length, c = k.length, e += k) : e = 10 > k.length && 40 > e.length + k.length ? e + k : e + "...";
        }
        e += "}";
    }
    return void 0 === b ? e : -1 < d && 0 < c ? (a = " ".repeat(d) + "^".repeat(c), "\n  " + e + "\n  " + a) : "\n  " + e;
}
var Ta = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ua = Ta.ContextRegistry, Va = Ta.ReactCurrentDispatcher, Wa = Ta.ReactCurrentCache;
function Xa(a) {
    console.error(a);
}
function Ya(a, b, d, c, e) {
    if (null !== Wa.current && Wa.current !== Pa) throw Error("Currently React only supports one RSC renderer at a time.");
    la.current = ka;
    Wa.current = Pa;
    var f = new Set, g = [], h = new Set, k = {
        status: 0,
        flushScheduled: !1,
        fatalError: null,
        destination: null,
        bundlerConfig: b,
        cache: new Map,
        nextChunkId: 0,
        pendingChunks: 0,
        hints: h,
        abortableTasks: f,
        pingedTasks: g,
        completedImportChunks: [],
        completedHintChunks: [],
        completedJSONChunks: [],
        completedErrorChunks: [],
        writtenSymbols: new Map,
        writtenClientReferences: new Map,
        writtenServerReferences: new Map,
        writtenProviders: new Map,
        identifierPrefix: e || "",
        identifierCount: 1,
        onError: void 0 === d ? Xa : d,
        toJSON: function(r, w) {
            return Za(k, this, r, w);
        }
    };
    k.pendingChunks++;
    b = $a(c);
    a = ab(k, a, b, f);
    g.push(a);
    return k;
}
var P = null;
function v() {
    if (P) return P;
    if (C) {
        var a = na.getStore();
        if (a) return a;
    }
    return null;
}
var bb = {};
function cb(a, b) {
    a.pendingChunks++;
    var d = ab(a, null, F, a.abortableTasks);
    switch(b.status){
        case "fulfilled":
            return d.model = b.value, db(a, d), d.id;
        case "rejected":
            var c = Q(a, b.reason);
            R(a, d.id, c);
            return d.id;
        default:
            "string" !== typeof b.status && (b.status = "pending", b.then(function(e) {
                "pending" === b.status && (b.status = "fulfilled", b.value = e);
            }, function(e) {
                "pending" === b.status && (b.status = "rejected", b.reason = e);
            }));
    }
    b.then(function(e) {
        d.model = e;
        db(a, d);
    }, function(e) {
        d.status = 4;
        e = Q(a, e);
        R(a, d.id, e);
        null !== a.destination && S(a, a.destination);
    });
    return d.id;
}
function eb(a) {
    if ("fulfilled" === a.status) return a.value;
    if ("rejected" === a.status) throw a.reason;
    throw a;
}
function fb(a) {
    switch(a.status){
        case "fulfilled":
        case "rejected":
            break;
        default:
            "string" !== typeof a.status && (a.status = "pending", a.then(function(b) {
                "pending" === a.status && (a.status = "fulfilled", a.value = b);
            }, function(b) {
                "pending" === a.status && (a.status = "rejected", a.reason = b);
            }));
    }
    return {
        $$typeof: E,
        _payload: a,
        _init: eb
    };
}
function T(a, b, d, c, e, f) {
    if (null !== c && void 0 !== c) throw Error("Refs cannot be used in Server Components, nor passed to Client Components.");
    if ("function" === typeof b) {
        if (b.$$typeof === u) return [
            D,
            b,
            d,
            e
        ];
        K = 0;
        L = f;
        e = b(e);
        return "object" === typeof e && null !== e && "function" === typeof e.then ? "fulfilled" === e.status ? e.value : fb(e) : e;
    }
    if ("string" === typeof b) return [
        D,
        b,
        d,
        e
    ];
    if ("symbol" === typeof b) return b === oa ? e.children : [
        D,
        b,
        d,
        e
    ];
    if (null != b && "object" === typeof b) {
        if (b.$$typeof === u) return [
            D,
            b,
            d,
            e
        ];
        switch(b.$$typeof){
            case E:
                var g = b._init;
                b = g(b._payload);
                return T(a, b, d, c, e, f);
            case ra:
                return a = b.render, K = 0, L = f, a(e, void 0);
            case ua:
                return T(a, b.type, d, c, e, f);
            case pa:
                return Ca(b._context, e.value), [
                    D,
                    b,
                    d,
                    {
                        value: e.value,
                        children: e.children,
                        __pop: bb
                    }
                ];
        }
    }
    throw Error("Unsupported Server Component type: " + Sa(b));
}
function db(a, b) {
    var d = a.pingedTasks;
    d.push(b);
    1 === d.length && (a.flushScheduled = null !== a.destination, setTimeout(function() {
        return gb(a);
    }, 0));
}
function ab(a, b, d, c) {
    var e = {
        id: a.nextChunkId++,
        status: 0,
        model: b,
        context: d,
        ping: function() {
            return db(a, e);
        },
        thenableState: null
    };
    c.add(e);
    return e;
}
function hb(a, b, d, c) {
    var e = c.$$async ? c.$$id + "#async" : c.$$id, f = a.writtenClientReferences, g = f.get(e);
    if (void 0 !== g) return b[0] === D && "1" === d ? "$L" + g.toString(16) : "$" + g.toString(16);
    try {
        var h = a.bundlerConfig, k = c.$$id;
        g = "";
        var r = h[k];
        if (r) g = r.name;
        else {
            var w = k.lastIndexOf("#");
            -1 !== w && (g = k.slice(w + 1), r = h[k.slice(0, w)]);
            if (!r) throw Error('Could not find the module "' + k + '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.');
        }
        var x = {
            id: r.id,
            chunks: r.chunks,
            name: g,
            async: !!c.$$async
        };
        a.pendingChunks++;
        var y = a.nextChunkId++, ma = q(x), z = y.toString(16) + ":I" + ma + "\n";
        var vb = p.encode(z);
        a.completedImportChunks.push(vb);
        f.set(e, y);
        return b[0] === D && "1" === d ? "$L" + y.toString(16) : "$" + y.toString(16);
    } catch (wb) {
        return a.pendingChunks++, b = a.nextChunkId++, d = Q(a, wb), R(a, b, d), "$" + b.toString(16);
    }
}
function Za(a, b, d, c) {
    switch(c){
        case D:
            return "$";
    }
    for(; "object" === typeof c && null !== c && (c.$$typeof === D || c.$$typeof === E);)try {
        switch(c.$$typeof){
            case D:
                var e = c;
                c = T(a, e.type, e.key, e.ref, e.props, null);
                break;
            case E:
                var f = c._init;
                c = f(c._payload);
        }
    } catch (g) {
        d = g === Da ? Ga() : g;
        if ("object" === typeof d && null !== d && "function" === typeof d.then) return a.pendingChunks++, a = ab(a, c, F, a.abortableTasks), c = a.ping, d.then(c, c), a.thenableState = Ha(), "$L" + a.id.toString(16);
        a.pendingChunks++;
        c = a.nextChunkId++;
        d = Q(a, d);
        R(a, c, d);
        return "$L" + c.toString(16);
    }
    if (null === c) return null;
    if ("object" === typeof c) {
        if (c.$$typeof === u) return hb(a, b, d, c);
        if ("function" === typeof c.then) return "$@" + cb(a, c).toString(16);
        if (c.$$typeof === pa) return c = c._context._globalName, b = a.writtenProviders, d = b.get(d), void 0 === d && (a.pendingChunks++, d = a.nextChunkId++, b.set(c, d), c = t(a, d, "$P" + c), a.completedJSONChunks.push(c)), "$" + d.toString(16);
        if (c === bb) {
            a = F;
            if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
            c = a.parentValue;
            a.context._currentValue = c === va ? a.context._defaultValue : c;
            F = a.parent;
            return;
        }
        return !Qa(c) && (null === c || "object" !== typeof c ? a = null : (a = xa && c[xa] || c["@@iterator"], a = "function" === typeof a ? a : null), a) ? Array.from(c) : c;
    }
    if ("string" === typeof c) {
        if ("Z" === c[c.length - 1] && b[d] instanceof Date) return "$D" + c;
        a = "$" === c[0] ? "$" + c : c;
        return a;
    }
    if ("boolean" === typeof c) return c;
    if ("number" === typeof c) return a = c, Number.isFinite(a) ? 0 === a && -Infinity === 1 / a ? "$-0" : a : Infinity === a ? "$Infinity" : -Infinity === a ? "$-Infinity" : "$NaN";
    if ("undefined" === typeof c) return "$undefined";
    if ("function" === typeof c) {
        if (c.$$typeof === u) return hb(a, b, d, c);
        if (c.$$typeof === ea) return d = a.writtenServerReferences, b = d.get(c), void 0 !== b ? a = "$F" + b.toString(16) : (b = c.$$bound, e = {
            id: c.$$id,
            bound: b ? Promise.resolve(b) : null
        }, a.pendingChunks++, b = a.nextChunkId++, e = da(a, b, e), a.completedJSONChunks.push(e), d.set(c, b), a = "$F" + b.toString(16)), a;
        if (/^on[A-Z]/.test(d)) throw Error("Event handlers cannot be passed to Client Component props." + O(b, d) + "\nIf you need interactivity, consider converting part of this to a Client Component.");
        throw Error('Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server".' + O(b, d));
    }
    if ("symbol" === typeof c) {
        e = a.writtenSymbols;
        f = e.get(c);
        if (void 0 !== f) return "$" + f.toString(16);
        f = c.description;
        if (Symbol.for(f) !== c) throw Error("Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" + (c.description + ") cannot be found among global symbols.") + O(b, d));
        a.pendingChunks++;
        d = a.nextChunkId++;
        b = t(a, d, "$S" + f);
        a.completedImportChunks.push(b);
        e.set(c, d);
        return "$" + d.toString(16);
    }
    if ("bigint" === typeof c) return "$n" + c.toString(10);
    throw Error("Type " + typeof c + " is not supported in Client Component props." + O(b, d));
}
function Q(a, b) {
    a = a.onError;
    b = a(b);
    if (null != b && "string" !== typeof b) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b || "";
}
function ib(a, b) {
    null !== a.destination ? (a.status = 2, ca(a.destination, b)) : (a.status = 1, a.fatalError = b);
}
function R(a, b, d) {
    d = {
        digest: d
    };
    b = b.toString(16) + ":E" + q(d) + "\n";
    b = p.encode(b);
    a.completedErrorChunks.push(b);
}
function A(a, b, d) {
    var c = a.nextChunkId++;
    d = q(d);
    b = "H" + b;
    c = c.toString(16) + ":" + b;
    c = p.encode(c + d + "\n");
    a.completedHintChunks.push(c);
}
function gb(a) {
    var b = Va.current;
    Va.current = Ma;
    var d = P;
    J = P = a;
    try {
        var c = a.pingedTasks;
        a.pingedTasks = [];
        for(var e = 0; e < c.length; e++){
            var f = c[e];
            var g = a;
            if (0 === f.status) {
                H(f.context);
                try {
                    var h = f.model;
                    if ("object" === typeof h && null !== h && h.$$typeof === D) {
                        var k = h, r = f.thenableState;
                        f.model = h;
                        h = T(g, k.type, k.key, k.ref, k.props, r);
                        for(f.thenableState = null; "object" === typeof h && null !== h && h.$$typeof === D;)k = h, f.model = h, h = T(g, k.type, k.key, k.ref, k.props, null);
                    }
                    var w = da(g, f.id, h);
                    g.completedJSONChunks.push(w);
                    g.abortableTasks.delete(f);
                    f.status = 1;
                } catch (z) {
                    var x = z === Da ? Ga() : z;
                    if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                        var y = f.ping;
                        x.then(y, y);
                        f.thenableState = Ha();
                    } else {
                        g.abortableTasks.delete(f);
                        f.status = 4;
                        var ma = Q(g, x);
                        R(g, f.id, ma);
                    }
                }
            }
        }
        null !== a.destination && S(a, a.destination);
    } catch (z) {
        Q(a, z), ib(a, z);
    } finally{
        Va.current = b, J = null, P = d;
    }
}
function S(a, b) {
    l = new Uint8Array(512);
    m = 0;
    try {
        for(var d = a.completedImportChunks, c = 0; c < d.length; c++)a.pendingChunks--, n(b, d[c]);
        d.splice(0, c);
        var e = a.completedHintChunks;
        for(c = 0; c < e.length; c++)n(b, e[c]);
        e.splice(0, c);
        var f = a.completedJSONChunks;
        for(c = 0; c < f.length; c++)a.pendingChunks--, n(b, f[c]);
        f.splice(0, c);
        var g = a.completedErrorChunks;
        for(c = 0; c < g.length; c++)a.pendingChunks--, n(b, g[c]);
        g.splice(0, c);
    } finally{
        a.flushScheduled = !1, l && 0 < m && (b.enqueue(new Uint8Array(l.buffer, 0, m)), l = null, m = 0);
    }
    0 === a.pendingChunks && b.close();
}
function jb(a) {
    a.flushScheduled = null !== a.destination;
    C ? setTimeout(function() {
        return na.run(a, gb, a);
    }, 0) : setTimeout(function() {
        return gb(a);
    }, 0);
}
function B(a) {
    if (!1 === a.flushScheduled && 0 === a.pingedTasks.length && null !== a.destination) {
        var b = a.destination;
        a.flushScheduled = !0;
        setTimeout(function() {
            return S(a, b);
        }, 0);
    }
}
function kb(a, b) {
    try {
        var d = a.abortableTasks;
        if (0 < d.size) {
            var c = Q(a, void 0 === b ? Error("The render was aborted by the server without a reason.") : b);
            a.pendingChunks++;
            var e = a.nextChunkId++;
            R(a, e, c);
            d.forEach(function(f) {
                f.status = 3;
                var g = "$" + e.toString(16);
                f = t(a, f.id, g);
                a.completedErrorChunks.push(f);
            });
            d.clear();
        }
        null !== a.destination && S(a, a.destination);
    } catch (f) {
        Q(a, f), ib(a, f);
    }
}
function $a(a) {
    if (a) {
        var b = F;
        H(null);
        for(var d = 0; d < a.length; d++){
            var c = a[d], e = c[0];
            c = c[1];
            Ua[e] || (Ua[e] = aa.createServerContext(e, va));
            Ca(Ua[e], c);
        }
        a = F;
        H(b);
        return a;
    }
    return null;
}
function lb(a, b) {
    var d = "", c = a[b];
    if (c) d = c.name;
    else {
        var e = b.lastIndexOf("#");
        -1 !== e && (d = b.slice(e + 1), c = a[b.slice(0, e)]);
        if (!c) throw Error('Could not find the module "' + b + '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.');
    }
    return {
        id: c.id,
        chunks: c.chunks,
        name: d,
        async: !1
    };
}
var U = new Map, mb = new Map;
function nb() {}
function ob(a) {
    for(var b = a.chunks, d = [], c = 0; c < b.length; c++){
        var e = b[c], f = U.get(e);
        if (void 0 === f) {
            f = globalThis.__next_chunk_load__(e);
            d.push(f);
            var g = U.set.bind(U, e, null);
            f.then(g, nb);
            U.set(e, f);
        } else null !== f && d.push(f);
    }
    if (a.async) {
        if (b = mb.get(a.id)) return "fulfilled" === b.status ? null : b;
        var h = Promise.all(d).then(function() {
            return globalThis.__next_require__(a.id);
        });
        h.then(function(k) {
            h.status = "fulfilled";
            h.value = k;
        }, function(k) {
            h.status = "rejected";
            h.reason = k;
        });
        mb.set(a.id, h);
        return h;
    }
    return 0 < d.length ? Promise.all(d) : null;
}
function V(a) {
    if (a.async) {
        var b = mb.get(a.id);
        if ("fulfilled" === b.status) b = b.value;
        else throw b.reason;
    } else b = globalThis.__next_require__(a.id);
    return "*" === a.name ? b : "" === a.name ? b.__esModule ? b.default : b : b[a.name];
}
function W(a, b, d, c) {
    this.status = a;
    this.value = b;
    this.reason = d;
    this._response = c;
}
W.prototype = Object.create(Promise.prototype);
W.prototype.then = function(a, b) {
    switch(this.status){
        case "resolved_model":
            pb(this);
    }
    switch(this.status){
        case "fulfilled":
            a(this.value);
            break;
        case "pending":
        case "blocked":
            a && (null === this.value && (this.value = []), this.value.push(a));
            b && (null === this.reason && (this.reason = []), this.reason.push(b));
            break;
        default:
            b(this.reason);
    }
};
function qb(a, b) {
    for(var d = 0; d < a.length; d++)(0, a[d])(b);
}
function rb(a, b) {
    if ("pending" === a.status || "blocked" === a.status) {
        var d = a.reason;
        a.status = "rejected";
        a.reason = b;
        null !== d && qb(d, b);
    }
}
function sb(a, b, d, c, e, f) {
    var g = lb(a._bundlerConfig, b);
    a = ob(g);
    if (d) d = Promise.all([
        d,
        a
    ]).then(function(h) {
        h = h[0];
        var k = V(g);
        return k.bind.apply(k, [
            null
        ].concat(h));
    });
    else if (a) d = Promise.resolve(a).then(function() {
        return V(g);
    });
    else return V(g);
    d.then(tb(c, e, f), ub(c));
    return null;
}
var X = null, Y = null;
function pb(a) {
    var b = X, d = Y;
    X = a;
    Y = null;
    try {
        var c = JSON.parse(a.value, a._response._fromJSON);
        null !== Y && 0 < Y.deps ? (Y.value = c, a.status = "blocked", a.value = null, a.reason = null) : (a.status = "fulfilled", a.value = c);
    } catch (e) {
        a.status = "rejected", a.reason = e;
    } finally{
        X = b, Y = d;
    }
}
function xb(a, b) {
    a._chunks.forEach(function(d) {
        "pending" === d.status && rb(d, b);
    });
}
function Z(a, b) {
    var d = a._chunks, c = d.get(b);
    c || (c = a._formData.get(a._prefix + b), c = null != c ? new W("resolved_model", c, null, a) : new W("pending", null, null, a), d.set(b, c));
    return c;
}
function tb(a, b, d) {
    if (Y) {
        var c = Y;
        c.deps++;
    } else c = Y = {
        deps: 1,
        value: null
    };
    return function(e) {
        b[d] = e;
        c.deps--;
        0 === c.deps && "blocked" === a.status && (e = a.value, a.status = "fulfilled", a.value = c.value, null !== e && qb(e, c.value));
    };
}
function ub(a) {
    return function(b) {
        return rb(a, b);
    };
}
function yb(a, b, d, c) {
    if ("$" === c[0]) switch(c[1]){
        case "$":
            return c.slice(1);
        case "@":
            return b = parseInt(c.slice(2), 16), Z(a, b);
        case "S":
            return Symbol.for(c.slice(2));
        case "F":
            c = parseInt(c.slice(2), 16);
            c = Z(a, c);
            "resolved_model" === c.status && pb(c);
            if ("fulfilled" !== c.status) throw c.reason;
            c = c.value;
            return sb(a, c.id, c.bound, X, b, d);
        case "K":
            b = c.slice(2);
            var e = a._prefix + b + "_", f = new FormData;
            a._formData.forEach(function(g, h) {
                h.startsWith(e) && f.append(h.slice(e.length), g);
            });
            return f;
        case "I":
            return Infinity;
        case "-":
            return "$-0" === c ? -0 : -Infinity;
        case "N":
            return NaN;
        case "u":
            return;
        case "D":
            return new Date(Date.parse(c.slice(2)));
        case "n":
            return BigInt(c.slice(2));
        default:
            c = parseInt(c.slice(1), 16);
            a = Z(a, c);
            switch(a.status){
                case "resolved_model":
                    pb(a);
            }
            switch(a.status){
                case "fulfilled":
                    return a.value;
                case "pending":
                case "blocked":
                    return c = X, a.then(tb(c, b, d), ub(c)), null;
                default:
                    throw a.reason;
            }
    }
    return c;
}
function zb(a, b) {
    var d = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new FormData, c = new Map, e = {
        _bundlerConfig: a,
        _prefix: b,
        _formData: d,
        _chunks: c,
        _fromJSON: function(f, g) {
            return "string" === typeof g ? yb(e, this, f, g) : g;
        }
    };
    return e;
}
function Ab(a) {
    xb(a, Error("Connection closed."));
}
function Bb(a, b, d) {
    var c = lb(a, b);
    a = ob(c);
    return d ? Promise.all([
        d,
        a
    ]).then(function(e) {
        e = e[0];
        var f = V(c);
        return f.bind.apply(f, [
            null
        ].concat(e));
    }) : a ? Promise.resolve(a).then(function() {
        return V(c);
    }) : Promise.resolve(V(c));
}
exports.decodeAction = function(a, b) {
    var d = new FormData, c = null;
    a.forEach(function(e, f) {
        if (f.startsWith("$ACTION_")) if (f.startsWith("$ACTION_REF_")) {
            e = "$ACTION_" + f.slice(12) + ":";
            e = zb(b, e, a);
            Ab(e);
            e = Z(e, 0);
            e.then(function() {});
            if ("fulfilled" !== e.status) throw e.reason;
            e = e.value;
            c = Bb(b, e.id, e.bound);
        } else f.startsWith("$ACTION_ID_") && (e = f.slice(11), c = Bb(b, e, null));
        else d.append(f, e);
    });
    return null === c ? null : c.then(function(e) {
        return e.bind(null, d);
    });
};
exports.decodeReply = function(a, b) {
    if ("string" === typeof a) {
        var d = new FormData;
        d.append("0", a);
        a = d;
    }
    a = zb(b, "", a);
    Ab(a);
    return Z(a, 0);
};
exports.renderToReadableStream = function(a, b, d) {
    var c = Ya(a, b, d ? d.onError : void 0, d ? d.context : void 0, d ? d.identifierPrefix : void 0);
    if (d && d.signal) {
        var e = d.signal;
        if (e.aborted) kb(c, e.reason);
        else {
            var f = function() {
                kb(c, e.reason);
                e.removeEventListener("abort", f);
            };
            e.addEventListener("abort", f);
        }
    }
    return new ReadableStream({
        type: "bytes",
        start: function() {
            jb(c);
        },
        pull: function(g) {
            if (1 === c.status) c.status = 2, ca(g, c.fatalError);
            else if (2 !== c.status && null === c.destination) {
                c.destination = g;
                try {
                    S(c, g);
                } catch (h) {
                    Q(c, h), ib(c, h);
                }
            }
        },
        cancel: function() {}
    }, {
        highWaterMark: 0
    });
};


/***/ }),

/***/ 6370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(1336);
} else {}


/***/ }),

/***/ 9615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.shared-subset.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var m = Object.assign, n = {
    current: null
};
function p() {
    return new Map;
}
if ("function" === typeof fetch) {
    var q = fetch, r = function(a, b) {
        var d = n.current;
        if (!d || b && b.signal && b.signal !== d.getCacheSignal()) return q(a, b);
        if ("string" !== typeof a || b) {
            var c = "string" === typeof a || a instanceof URL ? new Request(a, b) : a;
            if ("GET" !== c.method && "HEAD" !== c.method || c.keepalive) return q(a, b);
            var e = JSON.stringify([
                c.method,
                Array.from(c.headers.entries()),
                c.mode,
                c.redirect,
                c.credentials,
                c.referrer,
                c.referrerPolicy,
                c.integrity
            ]);
            c = c.url;
        } else e = '["GET",[],null,"follow",null,null,null,null]', c = a;
        var f = d.getCacheForType(p);
        d = f.get(c);
        if (void 0 === d) a = q(a, b), f.set(c, [
            e,
            a
        ]);
        else {
            c = 0;
            for(f = d.length; c < f; c += 2){
                var h = d[c + 1];
                if (d[c] === e) return a = h, a.then(function(g) {
                    return g.clone();
                });
            }
            a = q(a, b);
            d.push(e, a);
        }
        return a.then(function(g) {
            return g.clone();
        });
    };
    m(r, q);
    try {
        fetch = r;
    } catch (a) {
        try {
            globalThis.fetch = r;
        } catch (b) {
            console.warn("React was unable to patch the fetch() function in this environment. Suspensey APIs might not work correctly as a result.");
        }
    }
}
var t = Symbol.for("react.element"), u = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), y = Symbol.for("react.provider"), z = Symbol.for("react.server_context"), A = Symbol.for("react.forward_ref"), B = Symbol.for("react.suspense"), C = Symbol.for("react.memo"), aa = Symbol.for("react.lazy"), D = Symbol.for("react.default_value"), E = Symbol.iterator;
function ba(a) {
    if (null === a || "object" !== typeof a) return null;
    a = E && a[E] || a["@@iterator"];
    return "function" === typeof a ? a : null;
}
function F(a) {
    for(var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 1; d < arguments.length; d++)b += "&args[]=" + encodeURIComponent(arguments[d]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var G = {
    isMounted: function() {
        return !1;
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}, H = {};
function I(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = H;
    this.updater = d || G;
}
I.prototype.isReactComponent = {};
I.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(F(85));
    this.updater.enqueueSetState(this, a, b, "setState");
};
I.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function J() {}
J.prototype = I.prototype;
function K(a, b, d) {
    this.props = a;
    this.context = b;
    this.refs = H;
    this.updater = d || G;
}
var L = K.prototype = new J;
L.constructor = K;
m(L, I.prototype);
L.isPureReactComponent = !0;
var M = Array.isArray, N = Object.prototype.hasOwnProperty, O = {
    current: null
}, P = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function ca(a, b) {
    return {
        $$typeof: t,
        type: a.type,
        key: b,
        ref: a.ref,
        props: a.props,
        _owner: a._owner
    };
}
function Q(a) {
    return "object" === typeof a && null !== a && a.$$typeof === t;
}
function escape(a) {
    var b = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function(d) {
        return b[d];
    });
}
var R = /\/+/g;
function S(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function T(a, b, d, c, e) {
    var f = typeof a;
    if ("undefined" === f || "boolean" === f) a = null;
    var h = !1;
    if (null === a) h = !0;
    else switch(f){
        case "string":
        case "number":
            h = !0;
            break;
        case "object":
            switch(a.$$typeof){
                case t:
                case u:
                    h = !0;
            }
    }
    if (h) return h = a, e = e(h), a = "" === c ? "." + S(h, 0) : c, M(e) ? (d = "", null != a && (d = a.replace(R, "$&/") + "/"), T(e, b, d, "", function(l) {
        return l;
    })) : null != e && (Q(e) && (e = ca(e, d + (!e.key || h && h.key === e.key ? "" : ("" + e.key).replace(R, "$&/") + "/") + a)), b.push(e)), 1;
    h = 0;
    c = "" === c ? "." : c + ":";
    if (M(a)) for(var g = 0; g < a.length; g++){
        f = a[g];
        var k = c + S(f, g);
        h += T(f, b, d, k, e);
    }
    else if (k = ba(a), "function" === typeof k) for(a = k.call(a), g = 0; !(f = a.next()).done;)f = f.value, k = c + S(f, g++), h += T(f, b, d, k, e);
    else if ("object" === f) throw b = String(a), Error(F(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
    return h;
}
function U(a, b, d) {
    if (null == a) return a;
    var c = [], e = 0;
    T(a, c, "", "", function(f) {
        return b.call(d, f, e++);
    });
    return c;
}
function da(a) {
    if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(d) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = d;
        }, function(d) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = d;
        });
        -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
}
function ea() {
    return new WeakMap;
}
function V() {
    return {
        s: 0,
        v: void 0,
        o: null,
        p: null
    };
}
var W = {
    current: null
}, X = {
    transition: null
}, Y = {
    ReactCurrentDispatcher: W,
    ReactCurrentCache: n,
    ReactCurrentBatchConfig: X,
    ReactCurrentOwner: O,
    ContextRegistry: {}
}, Z = Y.ContextRegistry;
exports.Children = {
    map: U,
    forEach: function(a, b, d) {
        U(a, function() {
            b.apply(this, arguments);
        }, d);
    },
    count: function(a) {
        var b = 0;
        U(a, function() {
            b++;
        });
        return b;
    },
    toArray: function(a) {
        return U(a, function(b) {
            return b;
        }) || [];
    },
    only: function(a) {
        if (!Q(a)) throw Error(F(143));
        return a;
    }
};
exports.Fragment = v;
exports.Profiler = x;
exports.StrictMode = w;
exports.Suspense = B;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;
exports.cache = function(a) {
    return function() {
        var b = n.current;
        if (!b) return a.apply(null, arguments);
        var d = b.getCacheForType(ea);
        b = d.get(a);
        void 0 === b && (b = V(), d.set(a, b));
        d = 0;
        for(var c = arguments.length; d < c; d++){
            var e = arguments[d];
            if ("function" === typeof e || "object" === typeof e && null !== e) {
                var f = b.o;
                null === f && (b.o = f = new WeakMap);
                b = f.get(e);
                void 0 === b && (b = V(), f.set(e, b));
            } else f = b.p, null === f && (b.p = f = new Map), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
        }
        if (1 === b.s) return b.v;
        if (2 === b.s) throw b.v;
        try {
            var h = a.apply(null, arguments);
            d = b;
            d.s = 1;
            return d.v = h;
        } catch (g) {
            throw h = b, h.s = 2, h.v = g, g;
        }
    };
};
exports.cloneElement = function(a, b, d) {
    if (null === a || void 0 === a) throw Error(F(267, a));
    var c = m({}, a.props), e = a.key, f = a.ref, h = a._owner;
    if (null != b) {
        void 0 !== b.ref && (f = b.ref, h = O.current);
        void 0 !== b.key && (e = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for(k in b)N.call(b, k) && !P.hasOwnProperty(k) && (c[k] = void 0 === b[k] && void 0 !== g ? g[k] : b[k]);
    }
    var k = arguments.length - 2;
    if (1 === k) c.children = d;
    else if (1 < k) {
        g = Array(k);
        for(var l = 0; l < k; l++)g[l] = arguments[l + 2];
        c.children = g;
    }
    return {
        $$typeof: t,
        type: a.type,
        key: e,
        ref: f,
        props: c,
        _owner: h
    };
};
exports.createElement = function(a, b, d) {
    var c, e = {}, f = null, h = null;
    if (null != b) for(c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (f = "" + b.key), b)N.call(b, c) && !P.hasOwnProperty(c) && (e[c] = b[c]);
    var g = arguments.length - 2;
    if (1 === g) e.children = d;
    else if (1 < g) {
        for(var k = Array(g), l = 0; l < g; l++)k[l] = arguments[l + 2];
        e.children = k;
    }
    if (a && a.defaultProps) for(c in g = a.defaultProps, g)void 0 === e[c] && (e[c] = g[c]);
    return {
        $$typeof: t,
        type: a,
        key: f,
        ref: h,
        props: e,
        _owner: O.current
    };
};
exports.createRef = function() {
    return {
        current: null
    };
};
exports.createServerContext = function(a, b) {
    var d = !0;
    if (!Z[a]) {
        d = !1;
        var c = {
            $$typeof: z,
            _currentValue: b,
            _currentValue2: b,
            _defaultValue: b,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _globalName: a
        };
        c.Provider = {
            $$typeof: y,
            _context: c
        };
        Z[a] = c;
    }
    c = Z[a];
    if (c._defaultValue === D) c._defaultValue = b, c._currentValue === D && (c._currentValue = b), c._currentValue2 === D && (c._currentValue2 = b);
    else if (d) throw Error(F(429, a));
    return c;
};
exports.forwardRef = function(a) {
    return {
        $$typeof: A,
        render: a
    };
};
exports.isValidElement = Q;
exports.lazy = function(a) {
    return {
        $$typeof: aa,
        _payload: {
            _status: -1,
            _result: a
        },
        _init: da
    };
};
exports.memo = function(a, b) {
    return {
        $$typeof: C,
        type: a,
        compare: void 0 === b ? null : b
    };
};
exports.startTransition = function(a) {
    var b = X.transition;
    X.transition = {};
    try {
        a();
    } finally{
        X.transition = b;
    }
};
exports.use = function(a) {
    return W.current.use(a);
};
exports.useCallback = function(a, b) {
    return W.current.useCallback(a, b);
};
exports.useContext = function(a) {
    return W.current.useContext(a);
};
exports.useDebugValue = function() {};
exports.useId = function() {
    return W.current.useId();
};
exports.useMemo = function(a, b) {
    return W.current.useMemo(a, b);
};
exports.version = "18.3.0-canary-16d053d59-20230506";


/***/ }),

/***/ 4212:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(9615);
} else {}


/***/ }),

/***/ 515:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    preloadStyle: function() {
        return preloadStyle;
    },
    preloadFont: function() {
        return preloadFont;
    },
    preconnect: function() {
        return preconnect;
    }
});
const _reactdom = /*#__PURE__*/ _interop_require_default(__webpack_require__(3592));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const stylePreloadOptions = {
    as: "style"
};
function preloadStyle(href) {
    _reactdom.default.preload(href, stylePreloadOptions);
}
function preloadFont(href, type) {
    _reactdom.default.preload(href, {
        as: "font",
        type
    });
}
function preconnect(href, crossOrigin) {
    if (typeof crossOrigin === "string") {
        _reactdom.default.preconnect(href, {
            crossOrigin
        });
    } else {
        _reactdom.default.preconnect(href);
    }
} //# sourceMappingURL=preloads.js.map


/***/ }),

/***/ 4689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var typeOf = __webpack_require__(9157);
var extend = __webpack_require__(8706);
/**
 * Parse sections in `input` with the given `options`.
 *
 * ```js
 * var sections = require('{%= name %}');
 * var result = sections(input, options);
 * // { content: 'Content before sections', sections: [] }
 * ```
 * @param {String|Buffer|Object} `input` If input is an object, it's `content` property must be a string or buffer.
 * @param {Object} options
 * @return {Object} Returns an object with a `content` string and an array of `sections` objects.
 * @api public
 */ module.exports = function(input, options) {
    if (typeof options === "function") {
        options = {
            parse: options
        };
    }
    var file = toObject(input);
    var defaults = {
        section_delimiter: "---",
        parse: identity
    };
    var opts = extend({}, defaults, options);
    var delim = opts.section_delimiter;
    var lines = file.content.split(/\r?\n/);
    var sections = null;
    var section = createSection();
    var content = [];
    var stack = [];
    function initSections(val) {
        file.content = val;
        sections = [];
        content = [];
    }
    function closeSection(val) {
        if (stack.length) {
            section.key = getKey(stack[0], delim);
            section.content = val;
            opts.parse(section, sections);
            sections.push(section);
            section = createSection();
            content = [];
            stack = [];
        }
    }
    for(var i = 0; i < lines.length; i++){
        var line = lines[i];
        var len = stack.length;
        var ln = line.trim();
        if (isDelimiter(ln, delim)) {
            if (ln.length === 3 && i !== 0) {
                if (len === 0 || len === 2) {
                    content.push(line);
                    continue;
                }
                stack.push(ln);
                section.data = content.join("\n");
                content = [];
                continue;
            }
            if (sections === null) {
                initSections(content.join("\n"));
            }
            if (len === 2) {
                closeSection(content.join("\n"));
            }
            stack.push(ln);
            continue;
        }
        content.push(line);
    }
    if (sections === null) {
        initSections(content.join("\n"));
    } else {
        closeSection(content.join("\n"));
    }
    file.sections = sections;
    return file;
};
function isDelimiter(line, delim) {
    if (line.slice(0, delim.length) !== delim) {
        return false;
    }
    if (line.charAt(delim.length + 1) === delim.slice(-1)) {
        return false;
    }
    return true;
}
function toObject(input) {
    if (typeOf(input) !== "object") {
        input = {
            content: input
        };
    }
    if (typeof input.content !== "string" && !isBuffer(input.content)) {
        throw new TypeError("expected a buffer or string");
    }
    input.content = input.content.toString();
    input.sections = [];
    return input;
}
function getKey(val, delim) {
    return val ? val.slice(delim.length).trim() : "";
}
function createSection() {
    return {
        key: "",
        data: "",
        content: ""
    };
}
function identity(val) {
    return val;
}
function isBuffer(val) {
    if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
    }
    return false;
}


/***/ }),

/***/ 5578:
/***/ ((module) => {

"use strict";
/*!
 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */ 
module.exports = function(str) {
    if (typeof str === "string" && str.charAt(0) === "\uFEFF") {
        return str.slice(1);
    }
    return str;
};


/***/ }),

/***/ 7797:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "actionAsyncStorage", ({
    enumerable: true,
    get: function() {
        return actionAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(211);
const actionAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=action-async-storage.js.map


/***/ }),

/***/ 211:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createAsyncLocalStorage", ({
    enumerable: true,
    get: function() {
        return createAsyncLocalStorage;
    }
}));
class FakeAsyncLocalStorage {
    disable() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    getStore() {
        // This fake implementation of AsyncLocalStorage always returns `undefined`.
        return undefined;
    }
    run() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    exit() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    enterWith() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
}
function createAsyncLocalStorage() {
    if (globalThis.AsyncLocalStorage) {
        return new globalThis.AsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=async-local-storage.js.map


/***/ }),

/***/ 8214:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "requestAsyncStorage", ({
    enumerable: true,
    get: function() {
        return requestAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(211);
const requestAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=request-async-storage.js.map


/***/ }),

/***/ 1839:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "staticGenerationAsyncStorage", ({
    enumerable: true,
    get: function() {
        return staticGenerationAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(211);
const staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-async-storage.js.map


/***/ }),

/***/ 9483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(4592)


/***/ }),

/***/ 9438:
/***/ ((module) => {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),

/***/ 3103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
__webpack_unused_export__ = ({value:!0});var e=__webpack_require__(3265),t=__webpack_require__(8038),n=__webpack_require__(9438),r=__webpack_require__(3531),o=__webpack_require__(9160);function s(e){return e&&e.__esModule?e:{default:e}}var i=/*#__PURE__*/s(t),a=/*#__PURE__*/s(n),c=/*#__PURE__*/s(o),l="undefined"!=typeof process&&void 0!==process.env&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",u=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==process.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env&&void 0!==process.env.SC_DISABLE_SPEEDY&&""!==process.env.SC_DISABLE_SPEEDY?"false"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:"production"!=="production"),p={},d=/invalid hook call/i,h=new Set,f=function(n,r){if(false){ var a, o, s, i; }},y=Object.freeze([]),m=Object.freeze({});function v(e,t,n){return void 0===n&&(n=m),e.theme!==n.theme&&e.theme||t||n.theme}var g=new Set(["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","use","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"]),S=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,_=/(^-|-$)/g;function w(e){return e.replace(S,"-").replace(_,"")}var b=/(a)(d)/gi,E=function(e){return String.fromCharCode(e+(e>25?39:97))};function N(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=E(t%52)+n;return(E(t%52)+n).replace(b,"$1-$2")}var P,C=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},A=function(e){return C(5381,e)};function I(e){return N(A(e)>>>0)}function O(e){return false||e.displayName||e.name||"Component"}function x(e){return"string"==typeof e&&( true||0)}var T="function"==typeof Symbol&&Symbol.for,R=T?Symbol.for("react.memo"):60115,D=T?Symbol.for("react.forward_ref"):60112,j={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},k={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},V={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},M=((P={})[D]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},P[R]=V,P);function F(e){return("type"in(t=e)&&t.type.$$typeof)===R?V:"$$typeof"in e?M[e.$$typeof]:j;var t}var $=Object.defineProperty,B=Object.getOwnPropertyNames,z=Object.getOwnPropertySymbols,G=Object.getOwnPropertyDescriptor,L=Object.getPrototypeOf,q=Object.prototype;function Y(e,t,n){if("string"!=typeof t){if(q){var r=L(t);r&&r!==q&&Y(e,r,n)}var o=B(t);z&&(o=o.concat(z(t)));for(var s=F(e),i=F(t),a=0;a<o.length;++a){var c=o[a];if(!(c in k||n&&n[c]||i&&c in i||s&&c in s)){var l=G(t,c);try{$(e,c,l)}catch(e){}}}}return e}function W(e){return"function"==typeof e}function H(e){return"object"==typeof e&&"styledComponentId"in e}function U(e,t){return e&&t?"".concat(e," ").concat(t):e||t||""}function J(e,t){if(0===e.length)return"";for(var n=e[0],r=1;r<e.length;r++)n+=t?t+e[r]:e[r];return n}function X(e){return null!==e&&"object"==typeof e&&e.constructor.name===Object.name&&!("props"in e&&e.$$typeof)}function Z(e,t,n){if(void 0===n&&(n=!1),!n&&!X(e)&&!Array.isArray(e))return t;if(Array.isArray(t))for(var r=0;r<t.length;r++)e[r]=Z(e[r],t[r]);else if(X(t))for(var r in t)e[r]=Z(e[r],t[r]);return e}var K= false?0:{};function Q(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var n=e[0],r=[],o=1,s=e.length;o<s;o+=1)r.push(e[o]);return r.forEach(function(e){n=n.replace(/%[a-z]/,e)}),n}function ee(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];return true?new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t," for more information.").concat(n.length>0?" Args: ".concat(n.join(", ")):"")):0}var te=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}return e.prototype.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},e.prototype.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)if((o<<=1)<0)throw ee(16,"".concat(e));this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0}for(var i=this.indexOfGroup(e+1),a=(s=0,t.length);s<a;s++)this.tag.insertRule(i,t[s])&&(this.groupSizes[e]++,i++)},e.prototype.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n)}},e.prototype.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+="".concat(this.tag.getRule(s)).concat("/*!sc*/\n");return t},e}(),ne=new Map,re=new Map,oe=1,se=function(e){if(ne.has(e))return ne.get(e);for(;re.has(oe);)oe++;var t=oe++;if(false){}return ne.set(e,t),re.set(t,e),t},ie=("style[".concat(l,"][").concat("data-styled-version",'="').concat("6.0.0-rc.2",'"]'),new RegExp("^".concat(l,'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),function(e){for(var t=e.getTag(),n=t.length,r="",o=function(n){var o=function(e){return re.get(e)}(n);if(void 0===o)return"continue";var s=e.names.get(o),i=t.getGroup(n);if(void 0===s||0===i.length)return"continue";var a="".concat(l,".g").concat(n,'[id="').concat(o,'"]'),c="";void 0!==s&&s.forEach(function(e){e.length>0&&(c+="".concat(e,","))}),r+="".concat(i).concat(a,'{content:"').concat(c,'"}').concat("/*!sc*/\n")},s=0;s<n;s++)o(s);return r});function ae(){return true?__webpack_require__.nc:0}var ce=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(l))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(l,"active"),r.setAttribute("data-styled-version","6.0.0-rc.2");var i=ae();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},le=function(){function e(e){this.element=ce(e),this.element.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}throw ee(17)}(this.element),this.length=0}return e.prototype.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},e.prototype.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},e.prototype.getRule=function(e){var t=this.sheet.cssRules[e];return t&&t.cssText?t.cssText:""},e}(),ue=function(){function e(e){this.element=ce(e),this.nodes=this.element.childNodes,this.length=0}return e.prototype.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t);return this.element.insertBefore(n,this.nodes[e]||null),this.length++,!0}return!1},e.prototype.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},e.prototype.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),pe=function(){function e(e){this.rules=[],this.length=0}return e.prototype.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},e.prototype.deleteRule=function(e){this.rules.splice(e,1),this.length--},e.prototype.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),de={isServer:!0,useCSSOMInjection:!u},he=function(){function t(t,n,r){void 0===t&&(t=m),void 0===n&&(n={}),this.options=e.__assign(e.__assign({},de),t),this.gs=n,this.names=new Map(r),this.server=!!t.isServer}return t.registerId=function(e){return se(e)},t.prototype.reconstructWithOptions=function(n,r){return void 0===r&&(r=!0),new t(e.__assign(e.__assign({},this.options),n),this.gs,r&&this.names||void 0)},t.prototype.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.prototype.getTag=function(){return this.tag||(this.tag=(e=function(e){var t=e.useCSSOMInjection,n=e.target;return e.isServer?new pe(n):t?new le(n):new ue(n)}(this.options),new te(e)));var e},t.prototype.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.prototype.registerName=function(e,t){if(se(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},t.prototype.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(se(e),n)},t.prototype.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},t.prototype.clearRules=function(e){this.getTag().clearGroup(se(e)),this.clearNames(e)},t.prototype.clearTag=function(){this.tag=void 0},t.prototype.toString=function(){return ie(this)},t}(),fe=/&/g,ye=/^\s*\/\/.*$/gm;function me(e,t){return e.map(function(e){return"rule"===e.type&&(e.value="".concat(t," ").concat(e.value),e.value=e.value.replaceAll(",",",".concat(t," ")),e.props=e.props.map(function(e){return"".concat(t," ").concat(e)})),Array.isArray(e.children)&&"@keyframes"!==e.type&&(e.children=me(e.children,t)),e})}function ve(e){var t,n,o,s=void 0===e?m:e,i=s.options,a=void 0===i?m:i,c=s.plugins,l=void 0===c?y:c,u=function(e,r,o){return o===n||o.startsWith(n)&&o.endsWith(n)&&o.replaceAll(n,"").length>0?".".concat(t):e},p=l.slice();a.prefix&&p.unshift(r.prefixer),p.push(function(e){e.type===r.RULESET&&e.value.includes("&")&&(e.props[0]=e.props[0].replace(fe,n).replace(o,u))},r.stringify);var d=function(e,s,i,c){void 0===s&&(s=""),void 0===i&&(i=""),void 0===c&&(c="&"),t=c,n=s,o=new RegExp("\\".concat(n,"\\b"),"g");var l=e.replace(ye,""),u=r.compile(i||s?"".concat(i," ").concat(s," { ").concat(l," }"):l);return a.namespace&&(u=me(u,a.namespace)),function(e,t){for(var n=[],r=0,o=void 0;r<e.length;r+=1)(o=t(e[r],r,e,t))&&n.push(o);return n}(u,r.middleware(p))};return d.hash=l.length?l.reduce(function(e,t){return t.name||ee(15),C(e,t.name)},5381).toString():"",d}var ge=new he,Se=ve(),_e=i.default.createContext({shouldForwardProp:void 0,styleSheet:ge,stylis:Se}),we=_e.Consumer,be=i.default.createContext(void 0);function Ee(){return t.useContext(_e)}function Ne(e){var n=t.useState(e.stylisPlugins),r=n[0],o=n[1],s=Ee().styleSheet,c=t.useMemo(function(){var t=s;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t},[e.disableCSSOMInjection,e.sheet,e.target,s]),l=t.useMemo(function(){return ve({options:{namespace:e.namespace,prefix:e.enableVendorPrefixes},plugins:r})},[e.enableVendorPrefixes,e.namespace,r]);return t.useEffect(function(){a.default(r,e.stylisPlugins)||o(e.stylisPlugins)},[e.stylisPlugins]),i.default.createElement(_e.Provider,{value:{shouldForwardProp:e.shouldForwardProp,styleSheet:c,stylis:l}},i.default.createElement(be.Provider,{value:l},e.children))}var Pe=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=Se);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"))},this.toString=function(){throw ee(12,String(n.name))},this.name=e,this.id="sc-keyframes-".concat(e),this.rules=t}return e.prototype.getName=function(e){return void 0===e&&(e=Se),this.name+e.hash},e}(),Ce=function(e){return e>="A"&&e<="Z"};function Ae(e){for(var t="",n=0;n<e.length;n++){var r=e[n];if(1===n&&"-"===r&&"-"===e[0])return e;Ce(r)?t+="-"+r.toLowerCase():t+=r}return t.startsWith("ms-")?"-"+t:t}var Ie=function(e){return null==e||!1===e||""===e},Oe=function(t){var n,r,o=[];for(var s in t){var i=t[s];t.hasOwnProperty(s)&&!Ie(i)&&(Array.isArray(i)&&i.isCss||W(i)?o.push("".concat(Ae(s),":"),i,";"):X(i)?o.push.apply(o,e.__spreadArray(e.__spreadArray(["".concat(s," {")],Oe(i),!1),["}"],!1)):o.push("".concat(Ae(s),": ").concat((n=s,null==(r=i)||"boolean"==typeof r||""===r?"":"number"!=typeof r||0===r||n in c.default||n.startsWith("--")?String(r).trim():"".concat(r,"px")),";")))}return o};function xe(e,t,n,r){if(Ie(e))return[];if(H(e))return[".".concat(e.styledComponentId)];if(W(e)){if(!W(s=e)||s.prototype&&s.prototype.isReactComponent||!t)return[e];var o=e(t);return true||0,xe(o,t,n,r)}var s;return e instanceof Pe?n?(e.inject(n,r),[e.getName(r)]):[e]:X(e)?Oe(e):Array.isArray(e)?e.flatMap(function(e){return xe(e,t,n,r)}):[e.toString()]}function Te(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(W(n)&&!H(n))return!1}return!0}var Re=A("6.0.0-rc.2"),De=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic= true&&(void 0===n||n.isStatic)&&Te(e),this.componentId=t,this.baseHash=C(Re,t),this.baseStyle=n,he.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.baseStyle?this.baseStyle.generateAndInjectStyles(e,t,n):"";if(this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(this.componentId,this.staticRulesId))r=U(r,this.staticRulesId);else{var o=J(xe(this.rules,e,t,n)),s=N(C(this.baseHash,o)>>>0);if(!t.hasNameForId(this.componentId,s)){var i=n(o,".".concat(s),void 0,this.componentId);t.insertRules(this.componentId,s,i)}r=U(r,s),this.staticRulesId=s}else{for(var a=C(this.baseHash,n.hash),c="",l=0;l<this.rules.length;l++){var u=this.rules[l];if("string"==typeof u)c+=u, false&&(0);else if(u){var p=J(xe(u,e,t,n));a=C(a,p),c+=p}}if(c){var d=N(a>>>0);t.hasNameForId(this.componentId,d)||t.insertRules(this.componentId,d,n(c,".".concat(d),void 0,this.componentId)),r=U(r,d)}}return r},e}(),je=i.default.createContext(void 0),ke=je.Consumer;function Ve(){return t.useContext(je)}var Me={};function Fe(n,r,o){var s=H(n),a=n,c=!x(n),l=r.attrs,u=void 0===l?y:l,p=r.componentId,d=void 0===p?function(e,t){var n="string"!=typeof e?"sc":w(e);Me[n]=(Me[n]||0)+1;var r="".concat(n,"-").concat(I("6.0.0-rc.2"+n+Me[n]));return t?"".concat(t,"-").concat(r):r}(r.displayName,r.parentComponentId):p,h=r.displayName,S=void 0===h?function(e){return x(e)?"styled.".concat(e):"Styled(".concat(O(e),")")}(n):h,_=r.displayName&&r.componentId?"".concat(w(r.displayName),"-").concat(r.componentId):r.componentId||d,b=s&&a.attrs?a.attrs.concat(u).filter(Boolean):u,E=r.shouldForwardProp;if(s&&a.shouldForwardProp){var N=a.shouldForwardProp;if(r.shouldForwardProp){var P=r.shouldForwardProp;E=function(e,t){return N(e,t)&&P(e,t)}}else E=N}var C=new De(o,_,s?a.componentStyle:void 0),A=C.isStatic&&0===u.length;function T(n,r){return function(n,r,o,s){var i=n.attrs,a=n.componentStyle,c=n.defaultProps,l=n.foldedComponentIds,u=n.styledComponentId,p=n.target,d=Ve(),h=Ee(),f=n.shouldForwardProp||h.shouldForwardProp; false&&0;var y=function(t,n,r){for(var o,s=e.__assign(e.__assign({},n),{className:void 0,theme:r}),i=0;i<t.length;i+=1){var a=W(o=t[i])?o(s):o;for(var c in a)s[c]="className"===c?U(s[c],a[c]):"style"===c?e.__assign(e.__assign({},s[c]),a[c]):a[c]}return n.className&&(s.className=U(s.className,n.className)),s}(i,r,v(r,d,c)||m),S=y.as||p,_={};for(var w in y)void 0===y[w]||"$"===w[0]||"as"===w||"theme"===w||("forwardedAs"===w?_.as=y.forwardedAs:f&&!f(w,S)||(_[w]=y[w]));var b=function(e,n,r){var o=Ee(),s=e.generateAndInjectStyles(n?m:r,o.styleSheet,o.stylis);return false&&0,s}(a,s,y); false&&0;var E=U(l,u);return b&&(E+=" "+b),y.className&&(E+=" "+y.className),_[x(S)&&!g.has(S)?"class":"className"]=E,_.ref=o,t.createElement(S,_)}(R,n,r,A)}T.displayName=S;var R=i.default.forwardRef(T);return R.attrs=b,R.componentStyle=C,R.displayName=S,R.shouldForwardProp=E,R.foldedComponentIds=s?U(a.foldedComponentIds,a.styledComponentId):"",R.styledComponentId=_,R.target=s?a.target:n,Object.defineProperty(R,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(e){this._foldedDefaultProps=s?function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var r=0,o=t;r<o.length;r++)Z(e,o[r],!0);return e}({},a.defaultProps,e):e}}), false&&(0),Object.defineProperty(R,"toString",{value:function(){return".".concat(R.styledComponentId)}}),c&&Y(R,n,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0}),R}function $e(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n}var Be=function(e){return Object.assign(e,{isCss:!0})};function ze(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];if(W(t)||X(t)){var o=t;return Be(xe($e(y,e.__spreadArray([o],n,!0))))}var s=t;return 0===n.length&&1===s.length&&"string"==typeof s[0]?xe(s):Be(xe($e(s,n)))}function Ge(t,n,r){if(void 0===r&&(r=m),!n)throw ee(1,n);var o=function(o){for(var s=[],i=1;i<arguments.length;i++)s[i-1]=arguments[i];return t(n,r,ze.apply(void 0,e.__spreadArray([o],s,!1)))};return o.attrs=function(o){return Ge(t,n,e.__assign(e.__assign({},r),{attrs:Array.prototype.concat(r.attrs,o).filter(Boolean)}))},o.withConfig=function(o){return Ge(t,n,e.__assign(e.__assign({},r),o))},o}var Le=function(e){return Ge(Fe,e)},qe=Le;g.forEach(function(e){qe[e]=Le(e)});var Ye=function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=Te(e),he.registerId(this.componentId+1)}return e.prototype.createStyles=function(e,t,n,r){var o=r(J(xe(this.rules,t,n,r)),""),s=this.componentId+e;n.insertRules(s,s,o)},e.prototype.removeStyles=function(e,t){t.clearRules(this.componentId+e)},e.prototype.renderStyles=function(e,t,n,r){e>2&&he.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)},e}(),We=/^\s*<\/[a-z]/i,He=function(){function t(){var t=this;this._emitSheetCSS=function(){var e=t.instance.toString(),n=ae(),r=J([n&&'nonce="'.concat(n,'"'),"".concat(l,'="true"'),"".concat("data-styled-version",'="').concat("6.0.0-rc.2",'"')].filter(Boolean)," ");return"<style ".concat(r,">").concat(e,"</style>")},this.getStyleTags=function(){if(t.sealed)throw ee(2);return t._emitSheetCSS()},this.getStyleElement=function(){var n;if(t.sealed)throw ee(2);var r=((n={})[l]="",n["data-styled-version"]="6.0.0-rc.2",n.dangerouslySetInnerHTML={__html:t.instance.toString()},n),o=ae();return o&&(r.nonce=o),[i.default.createElement("style",e.__assign({},r,{key:"sc-0-0"}))]},this.seal=function(){t.sealed=!0},this.instance=new he({isServer:!0}),this.sealed=!1}return t.prototype.collectStyles=function(e){if(this.sealed)throw ee(2);return i.default.createElement(Ne,{sheet:this.instance},e)},t.prototype.interleaveWithNodeStream=function(e){if(this.sealed)throw ee(2);this.seal();var t=(__webpack_require__(2781).Transform),n=e,r=this.instance,o=this._emitSheetCSS,s=new t({transform:function(e,t,n){var s=e.toString(),i=o();if(r.clearTag(),We.test(s)){var a=s.indexOf(">")+1,c=s.slice(0,a),l=s.slice(a);this.push(c+i+l)}else this.push(i+s);n()}});return n.on("error",function(e){s.emit("error",e)}),n.pipe(s)},t}(),Ue={StyleSheet:he,mainSheet:ge}; false&&0,"__sc-".concat(l,"__"), false&&0,exports.qH=He,__webpack_unused_export__=we,__webpack_unused_export__=_e,exports.LC=Ne,__webpack_unused_export__=ke,__webpack_unused_export__=je,__webpack_unused_export__=function(n){var r=Ve(),o=t.useMemo(function(){return function(t,n){if(!t)throw ee(14);if(W(t)){var r=t(n);if(false){}return r}if(Array.isArray(t)||"object"!=typeof t)throw ee(8);return n?e.__assign(e.__assign({},n),t):t}(n.theme,r)},[n.theme,r]);return n.children?i.default.createElement(je.Provider,{value:o},n.children):null},__webpack_unused_export__=Ue,__webpack_unused_export__=function(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];var o=ze.apply(void 0,e.__spreadArray([t],n,!1)),s="sc-global-".concat(I(JSON.stringify(o))),a=new Ye(o,s); false&&0;var c=function(e){var t=Ee(),n=Ve(),r=i.default.useRef(t.styleSheet.allocateGSInstance(s)).current;return false&&0, false&&0,t.styleSheet.server&&l(r,e,t.styleSheet,n,t.stylis),null};function l(t,n,r,o,s){if(a.isStatic)a.renderStyles(t,p,r,s);else{var i=e.__assign(e.__assign({},n),{theme:v(n,o,c.defaultProps)});a.renderStyles(t,i,r,s)}}return i.default.memo(c)},__webpack_unused_export__=ze,exports.ZP=qe,__webpack_unused_export__=H,__webpack_unused_export__=function(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r]; false&&0;var o=J(ze.apply(void 0,e.__spreadArray([t],n,!1))),s=I(o);return new Pe(s,o)},__webpack_unused_export__=qe,__webpack_unused_export__=Ve,__webpack_unused_export__="6.0.0-rc.2",__webpack_unused_export__=function(t){var n=i.default.forwardRef(function(n,r){var o=v(n,Ve(),t.defaultProps);return false&&0,i.default.createElement(t,e.__assign({},n,{theme:o,ref:r}))});return n.displayName="WithTheme(".concat(O(t),")"),Y(n,t)};
//# sourceMappingURL=styled-components.cjs.js.map


/***/ }),

/***/ 3265:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__esDecorate": () => (/* binding */ __esDecorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__propKey": () => (/* binding */ __propKey),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__runInitializers": () => (/* binding */ __runInitializers),
/* harmony export */   "__setFunctionName": () => (/* binding */ __setFunctionName),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
});


/***/ }),

/***/ 5967:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports._ = exports._interop_require_default = _interop_require_default;
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}


/***/ }),

/***/ 1113:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();

    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
exports._ = exports._interop_require_wildcard = _interop_require_wildcard;
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return { default: obj };

    var cache = _getRequireWildcardCache(nodeInterop);

    if (cache && cache.has(obj)) return cache.get(obj);

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }

    newObj.default = obj;

    if (cache) cache.set(obj, newObj);

    return newObj;
}


/***/ }),

/***/ 3531:
/***/ (function(__unused_webpack_module, exports) {

(function(e,r){ true?r(exports):0})(this,(function(e){"use strict";var r="-ms-";var a="-moz-";var c="-webkit-";var n="comm";var t="rule";var s="decl";var i="@page";var u="@media";var o="@import";var f="@charset";var l="@viewport";var p="@supports";var h="@document";var v="@namespace";var d="@keyframes";var b="@font-face";var w="@counter-style";var m="@font-feature-values";var g="@layer";var k=Math.abs;var $=String.fromCharCode;var x=Object.assign;function E(e,r){return M(e,0)^45?(((r<<2^M(e,0))<<2^M(e,1))<<2^M(e,2))<<2^M(e,3):0}function y(e){return e.trim()}function T(e,r){return(e=r.exec(e))?e[0]:e}function A(e,r,a){return e.replace(r,a)}function O(e,r){return e.indexOf(r)}function M(e,r){return e.charCodeAt(r)|0}function C(e,r,a){return e.slice(r,a)}function R(e){return e.length}function S(e){return e.length}function z(e,r){return r.push(e),e}function N(e,r){return e.map(r).join("")}e.line=1;e.column=1;e.length=0;e.position=0;e.character=0;e.characters="";function P(r,a,c,n,t,s,i){return{value:r,root:a,parent:c,type:n,props:t,children:s,line:e.line,column:e.column,length:i,return:""}}function j(e,r){return x(P("",null,null,"",null,null,0),e,{length:-e.length},r)}function U(){return e.character}function _(){e.character=e.position>0?M(e.characters,--e.position):0;if(e.column--,e.character===10)e.column=1,e.line--;return e.character}function F(){e.character=e.position<e.length?M(e.characters,e.position++):0;if(e.column++,e.character===10)e.column=1,e.line++;return e.character}function I(){return M(e.characters,e.position)}function L(){return e.position}function D(r,a){return C(e.characters,r,a)}function Y(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function K(r){return e.line=e.column=1,e.length=R(e.characters=r),e.position=0,[]}function V(r){return e.characters="",r}function W(r){return y(D(e.position-1,q(r===91?r+2:r===40?r+1:r)))}function B(e){return V(H(K(e)))}function G(r){while(e.character=I())if(e.character<33)F();else break;return Y(r)>2||Y(e.character)>3?"":" "}function H(r){while(F())switch(Y(e.character)){case 0:z(Q(e.position-1),r);break;case 2:z(W(e.character),r);break;default:z($(e.character),r)}return r}function Z(r,a){while(--a&&F())if(e.character<48||e.character>102||e.character>57&&e.character<65||e.character>70&&e.character<97)break;return D(r,L()+(a<6&&I()==32&&F()==32))}function q(r){while(F())switch(e.character){case r:return e.position;case 34:case 39:if(r!==34&&r!==39)q(e.character);break;case 40:if(r===41)q(r);break;case 92:F();break}return e.position}function J(r,a){while(F())if(r+e.character===47+10)break;else if(r+e.character===42+42&&I()===47)break;return"/*"+D(a,e.position-1)+"*"+$(r===47?r:F())}function Q(r){while(!Y(I()))F();return D(r,e.position)}function X(e){return V(ee("",null,null,null,[""],e=K(e),0,[0],e))}function ee(e,r,a,c,n,t,s,i,u){var o=0;var f=0;var l=s;var p=0;var h=0;var v=0;var d=1;var b=1;var w=1;var m=0;var g="";var k=n;var x=t;var E=c;var y=g;while(b)switch(v=m,m=F()){case 40:if(v!=108&&M(y,l-1)==58){if(O(y+=A(W(m),"&","&\f"),"&\f")!=-1)w=-1;break}case 34:case 39:case 91:y+=W(m);break;case 9:case 10:case 13:case 32:y+=G(v);break;case 92:y+=Z(L()-1,7);continue;case 47:switch(I()){case 42:case 47:z(ae(J(F(),L()),r,a),u);break;default:y+="/"}break;case 123*d:i[o++]=R(y)*w;case 125*d:case 59:case 0:switch(m){case 0:case 125:b=0;case 59+f:if(w==-1)y=A(y,/\f/g,"");if(h>0&&R(y)-l)z(h>32?ce(y+";",c,a,l-1):ce(A(y," ","")+";",c,a,l-2),u);break;case 59:y+=";";default:z(E=re(y,r,a,o,f,n,i,g,k=[],x=[],l),t);if(m===123)if(f===0)ee(y,r,E,E,k,t,l,i,x);else switch(p===99&&M(y,3)===110?100:p){case 100:case 108:case 109:case 115:ee(e,E,E,c&&z(re(e,E,E,0,0,n,i,g,n,k=[],l),x),n,x,l,i,c?k:x);break;default:ee(y,E,E,E,[""],x,0,i,x)}}o=f=h=0,d=w=1,g=y="",l=s;break;case 58:l=1+R(y),h=v;default:if(d<1)if(m==123)--d;else if(m==125&&d++==0&&_()==125)continue;switch(y+=$(m),m*d){case 38:w=f>0?1:(y+="\f",-1);break;case 44:i[o++]=(R(y)-1)*w,w=1;break;case 64:if(I()===45)y+=W(F());p=I(),f=l=R(g=y+=Q(L())),m++;break;case 45:if(v===45&&R(y)==2)d=0}}return t}function re(e,r,a,c,n,s,i,u,o,f,l){var p=n-1;var h=n===0?s:[""];var v=S(h);for(var d=0,b=0,w=0;d<c;++d)for(var m=0,g=C(e,p+1,p=k(b=i[d])),$=e;m<v;++m)if($=y(b>0?h[m]+" "+g:A(g,/&\f/g,h[m])))o[w++]=$;return P(e,r,a,n===0?t:u,o,f,l)}function ae(e,r,a){return P(e,r,a,n,$(U()),C(e,2,-2),0)}function ce(e,r,a,c){return P(e,r,a,s,C(e,0,c),C(e,c+1,-1),c)}function ne(e,n,t){switch(E(e,n)){case 5103:return c+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return c+e+e;case 4789:return a+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return c+e+a+e+r+e+e;case 5936:switch(M(e,n+11)){case 114:return c+e+r+A(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return c+e+r+A(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return c+e+r+A(e,/[svh]\w+-[tblr]{2}/,"lr")+e}case 6828:case 4268:case 2903:return c+e+r+e+e;case 6165:return c+e+r+"flex-"+e+e;case 5187:return c+e+A(e,/(\w+).+(:[^]+)/,c+"box-$1$2"+r+"flex-$1$2")+e;case 5443:return c+e+r+"flex-item-"+A(e,/flex-|-self/g,"")+(!T(e,/flex-|baseline/)?r+"grid-row-"+A(e,/flex-|-self/g,""):"")+e;case 4675:return c+e+r+"flex-line-pack"+A(e,/align-content|flex-|-self/g,"")+e;case 5548:return c+e+r+A(e,"shrink","negative")+e;case 5292:return c+e+r+A(e,"basis","preferred-size")+e;case 6060:return c+"box-"+A(e,"-grow","")+c+e+r+A(e,"grow","positive")+e;case 4554:return c+A(e,/([^-])(transform)/g,"$1"+c+"$2")+e;case 6187:return A(A(A(e,/(zoom-|grab)/,c+"$1"),/(image-set)/,c+"$1"),e,"")+e;case 5495:case 3959:return A(e,/(image-set\([^]*)/,c+"$1"+"$`$1");case 4968:return A(A(e,/(.+:)(flex-)?(.*)/,c+"box-pack:$3"+r+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+c+e+e;case 4200:if(!T(e,/flex-|baseline/))return r+"grid-column-align"+C(e,n)+e;break;case 2592:case 3360:return r+A(e,"template-","")+e;case 4384:case 3616:if(t&&t.some((function(e,r){return n=r,T(e.props,/grid-\w+-end/)}))){return~O(e+(t=t[n].value),"span")?e:r+A(e,"-start","")+e+r+"grid-row-span:"+(~O(t,"span")?T(t,/\d+/):+T(t,/\d+/)-+T(e,/\d+/))+";"}return r+A(e,"-start","")+e;case 4896:case 4128:return t&&t.some((function(e){return T(e.props,/grid-\w+-start/)}))?e:r+A(A(e,"-end","-span"),"span ","")+e;case 4095:case 3583:case 4068:case 2532:return A(e,/(.+)-inline(.+)/,c+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(R(e)-1-n>6)switch(M(e,n+1)){case 109:if(M(e,n+4)!==45)break;case 102:return A(e,/(.+:)(.+)-([^]+)/,"$1"+c+"$2-$3"+"$1"+a+(M(e,n+3)==108?"$3":"$2-$3"))+e;case 115:return~O(e,"stretch")?ne(A(e,"stretch","fill-available"),n,t)+e:e}break;case 5152:case 5920:return A(e,/(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,(function(a,c,n,t,s,i,u){return r+c+":"+n+u+(t?r+c+"-span:"+(s?i:+i-+n)+u:"")+e}));case 4949:if(M(e,n+6)===121)return A(e,":",":"+c)+e;break;case 6444:switch(M(e,M(e,14)===45?18:11)){case 120:return A(e,/(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,"$1"+c+(M(e,14)===45?"inline-":"")+"box$3"+"$1"+c+"$2$3"+"$1"+r+"$2box$3")+e;case 100:return A(e,":",":"+r)+e}break;case 5719:case 2647:case 2135:case 3927:case 2391:return A(e,"scroll-","scroll-snap-")+e}return e}function te(e,r){var a="";var c=S(e);for(var n=0;n<c;n++)a+=r(e[n],n,e,r)||"";return a}function se(e,r,a,c){switch(e.type){case g:if(e.children.length)break;case o:case s:return e.return=e.return||e.value;case n:return"";case d:return e.return=e.value+"{"+te(e.children,c)+"}";case t:e.value=e.props.join(",")}return R(a=te(e.children,c))?e.return=e.value+"{"+a+"}":""}function ie(e){var r=S(e);return function(a,c,n,t){var s="";for(var i=0;i<r;i++)s+=e[i](a,c,n,t)||"";return s}}function ue(e){return function(r){if(!r.root)if(r=r.return)e(r)}}function oe(e,n,i,u){if(e.length>-1)if(!e.return)switch(e.type){case s:e.return=ne(e.value,e.length,i);return;case d:return te([j(e,{value:A(e.value,"@","@"+c)})],u);case t:if(e.length)return N(e.props,(function(n){switch(T(n,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return te([j(e,{props:[A(n,/:(read-\w+)/,":"+a+"$1")]})],u);case"::placeholder":return te([j(e,{props:[A(n,/:(plac\w+)/,":"+c+"input-$1")]}),j(e,{props:[A(n,/:(plac\w+)/,":"+a+"$1")]}),j(e,{props:[A(n,/:(plac\w+)/,r+"input-$1")]})],u)}return""}))}}function fe(e){switch(e.type){case t:e.props=e.props.map((function(r){return N(B(r),(function(r,a,c){switch(M(r,0)){case 12:return C(r,1,R(r));case 0:case 40:case 43:case 62:case 126:return r;case 58:if(c[++a]==="global")c[a]="",c[++a]="\f"+C(c[a],a=1,-1);case 32:return a===1?"":r;default:switch(a){case 0:e=r;return S(c)>1?"":r;case a=S(c)-1:case 2:return a===2?r+e+e:r+e;default:return r}}}))}))}}e.CHARSET=f;e.COMMENT=n;e.COUNTER_STYLE=w;e.DECLARATION=s;e.DOCUMENT=h;e.FONT_FACE=b;e.FONT_FEATURE_VALUES=m;e.IMPORT=o;e.KEYFRAMES=d;e.LAYER=g;e.MEDIA=u;e.MOZ=a;e.MS=r;e.NAMESPACE=v;e.PAGE=i;e.RULESET=t;e.SUPPORTS=p;e.VIEWPORT=l;e.WEBKIT=c;e.abs=k;e.alloc=K;e.append=z;e.assign=x;e.caret=L;e.char=U;e.charat=M;e.combine=N;e.comment=ae;e.commenter=J;e.compile=X;e.copy=j;e.dealloc=V;e.declaration=ce;e.delimit=W;e.delimiter=q;e.escaping=Z;e.from=$;e.hash=E;e.identifier=Q;e.indexof=O;e.match=T;e.middleware=ie;e.namespace=fe;e.next=F;e.node=P;e.parse=ee;e.peek=I;e.prefix=ne;e.prefixer=oe;e.prev=_;e.replace=A;e.ruleset=re;e.rulesheet=ue;e.serialize=te;e.sizeof=S;e.slice=D;e.stringify=se;e.strlen=R;e.substr=C;e.token=Y;e.tokenize=B;e.tokenizer=H;e.trim=y;e.whitespace=G;Object.defineProperty(e,"__esModule",{value:true})}));
//# sourceMappingURL=stylis.js.map


/***/ }),

/***/ 4341:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z_": () => (/* binding */ sync)
});

// UNUSED EXPORTS: Glob, escape, glob, globIterate, globIterateSync, globStream, globStreamSync, globSync, hasMagic, iterate, iterateSync, stream, streamSync, unescape

// EXTERNAL MODULE: ./node_modules/brace-expansion/index.js
var brace_expansion = __webpack_require__(1076);
;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern)=>{
    if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
    }
}; //# sourceMappingURL=assert-valid-pattern.js.map

;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/brace-expressions.js
// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    "[:alnum:]": [
        "\\p{L}\\p{Nl}\\p{Nd}",
        true
    ],
    "[:alpha:]": [
        "\\p{L}\\p{Nl}",
        true
    ],
    "[:ascii:]": [
        "\\x" + "00-\\x" + "7f",
        false
    ],
    "[:blank:]": [
        "\\p{Zs}\\t",
        true
    ],
    "[:cntrl:]": [
        "\\p{Cc}",
        true
    ],
    "[:digit:]": [
        "\\p{Nd}",
        true
    ],
    "[:graph:]": [
        "\\p{Z}\\p{C}",
        true,
        true
    ],
    "[:lower:]": [
        "\\p{Ll}",
        true
    ],
    "[:print:]": [
        "\\p{C}",
        true
    ],
    "[:punct:]": [
        "\\p{P}",
        true
    ],
    "[:space:]": [
        "\\p{Z}\\t\\r\\n\\v\\f",
        true
    ],
    "[:upper:]": [
        "\\p{Lu}",
        true
    ],
    "[:word:]": [
        "\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}",
        true
    ],
    "[:xdigit:]": [
        "A-Fa-f0-9",
        false
    ]
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s)=>s.replace(/[[\]\\-]/g, "\\$&");
// escape all regexp magic characters
const regexpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
// everything has already been escaped, we just have to join
const rangesToString = (ranges)=>ranges.join("");
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position)=>{
    const pos = position;
    /* c8 ignore start */ if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
    }
    /* c8 ignore stop */ const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE: while(i < glob.length){
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === "]" && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === "\\") {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
        // escaped \ char, fall through and treat like normal char
        }
        if (c === "[" && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return [
                            "$.",
                            false,
                            glob.length - pos,
                            true
                        ];
                    }
                    i += cls.length;
                    if (neg) negs.push(unip);
                    else ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
            } else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = "";
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith("-]", i + 1)) {
            ranges.push(braceEscape(c + "-"));
            i += 2;
            continue;
        }
        if (glob.startsWith("-", i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return [
            "",
            false,
            0,
            false
        ];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return [
            "$.",
            false,
            glob.length - pos,
            true
        ];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [
            regexpEscape(r),
            false,
            endPos - pos,
            false
        ];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [
        comb,
        uflag,
        endPos - pos,
        true
    ];
}; //# sourceMappingURL=brace-expressions.js.map

;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/unescape.js
/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */ const unescape_unescape = (s, { windowsPathsNoEscape =false  } = {})=>{
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
}; //# sourceMappingURL=unescape.js.map

;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/ast.js
// parse a single path portion


const types = new Set([
    "!",
    "?",
    "+",
    "*",
    "@"
]);
const isExtglobType = (c)=>types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = "(?!\\.\\.?(?:$|/))";
const startNoDot = "(?!\\.)";
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set([
    "[",
    "."
]);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set([
    "..",
    "."
]);
const reSpecials = new Set("().*{}+?[]^$\\!");
const regExpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
// any single thing other than /
const qmark = "[^/]";
// * => any number of characters
const star = qmark + "*?";
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + "+?";
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    #root;
    #hasMagic;
    #uflag;
    #parts;
    #parent;
    #parentIndex;
    #negs;
    #filledNegs;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt;
    constructor(type, parent, options = {}){
        this.#uflag = false;
        this.#parts = [];
        this.#filledNegs = false;
        this.#emptyExt = false;
        this.type = type;
        // extglobs are inherently magical
        if (type) this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs) this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */ if (this.#hasMagic !== undefined) return this.#hasMagic;
        /* c8 ignore stop */ for (const p of this.#parts){
            if (typeof p === "string") continue;
            if (p.type || p.hasMagic) return this.#hasMagic = true;
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined) return this.#toString;
        if (!this.type) {
            return this.#toString = this.#parts.map((p)=>String(p)).join("");
        } else {
            return this.#toString = this.type + "(" + this.#parts.map((p)=>String(p)).join("|") + ")";
        }
    }
    #fillNegs() {
        /* c8 ignore start */ if (this !== this.#root) throw new Error("should only call on root");
        if (this.#filledNegs) return this;
        /* c8 ignore stop */ // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while(n = this.#negs.pop()){
            if (n.type !== "!") continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while(pp){
                for(let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++){
                    for (const part of n.#parts){
                        /* c8 ignore start */ if (typeof part === "string") {
                            throw new Error("string part in extglob AST??");
                        }
                        /* c8 ignore stop */ part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts){
            if (p === "") continue;
            /* c8 ignore start */ if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
                throw new Error("invalid part: " + p);
            }
            /* c8 ignore stop */ this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p)=>typeof p === "string" ? p : p.toJSON()) : [
            this.type,
            ...this.#parts.map((p)=>p.toJSON())
        ];
        if (this.isStart() && !this.type) ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this) return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart()) return false;
        if (this.#parentIndex === 0) return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for(let i = 0; i < this.#parentIndex; i++){
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === "!")) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this) return true;
        if (this.#parent?.type === "!") return true;
        if (!this.#parent?.isEnd()) return false;
        if (!this.type) return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */ const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */ return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === "string") this.push(part);
        else this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts){
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = "";
            while(i < str.length){
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === "\\") {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === "^" || c === "!") {
                            braceNeg = true;
                        }
                    } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                } else if (c === "[") {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
                    ast.push(acc);
                    acc = "";
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = "";
        while(i < str.length){
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === "\\") {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === "^" || c === "!") {
                        braceNeg = true;
                    }
                } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            } else if (c === "[") {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === "(") {
                part.push(acc);
                acc = "";
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === "|") {
                part.push(acc);
                acc = "";
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ")") {
                if (acc === "" && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = "";
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [
            str.substring(pos - 1)
        ];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */ if (this !== this.#root) return this.#root.toMMPattern();
        /* c8 ignore stop */ const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob
        });
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource() {
        if (this.#root === this) this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts.map((p)=>{
                const [re, _, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource();
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            }).join("");
            let start = "";
            if (this.isStart()) {
                if (typeof this.#parts[0] === "string") {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = // dots are allowed, and the pattern starts with [ or .
                        this.#options.dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                        src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                        src.startsWith("\\.\\.") && aps.has(src.charAt(4));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !this.#options.dot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = "";
            if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
                end = "(?:$|\\/)";
            }
            const final = start + src + end;
            return [
                final,
                unescape_unescape(src),
                this.#hasMagic = !!this.#hasMagic,
                this.#uflag
            ];
        }
        // some kind of extglob
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        const body = this.#parts.map((p)=>{
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */ if (typeof p === "string") {
                throw new Error("string type in extglob ast??");
            }
            /* c8 ignore stop */ // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource();
            this.#uflag = this.#uflag || uflag;
            return re;
        }).filter((p)=>!(this.isStart() && this.isEnd()) || !!p).join("|");
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [
                s
            ];
            this.type = null;
            this.#hasMagic = undefined;
            return [
                s,
                unescape_unescape(this.toString()),
                false,
                false
            ];
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
            final = (this.isStart() && !this.#options.dot ? startNoDot : "") + starNoEmpty;
        } else {
            const close = this.type === "!" ? "))" + (this.isStart() && !this.#options.dot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape_unescape(body),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
        ];
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for(let i = 0; i < glob.length; i++){
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? "\\" : "") + c;
                continue;
            }
            if (c === "\\") {
                if (i === glob.length - 1) {
                    re += "\\\\";
                } else {
                    escaping = true;
                }
                continue;
            }
            if (c === "[") {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === "*") {
                if (noEmpty && glob === "*") re += starNoEmpty;
                else re += star;
                hasMagic = true;
                continue;
            }
            if (c === "?") {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [
            re,
            unescape_unescape(glob),
            !!hasMagic,
            uflag
        ];
    }
} //# sourceMappingURL=ast.js.map

;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/escape.js
/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */ const escape_escape = (s, { windowsPathsNoEscape =false  } = {})=>{
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
}; //# sourceMappingURL=escape.js.map

;// CONCATENATED MODULE: ./node_modules/glob/node_modules/minimatch/dist/mjs/index.js





const minimatch = (p, pattern, options = {})=>{
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext)=>(f)=>!f.startsWith(".") && f.endsWith(ext);
const starDotExtTestDot = (ext)=>(f)=>f.endsWith(ext);
const starDotExtTestNocase = (ext)=>{
    ext = ext.toLowerCase();
    return (f)=>!f.startsWith(".") && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext)=>{
    ext = ext.toLowerCase();
    return (f)=>f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f)=>!f.startsWith(".") && f.includes(".");
const starDotStarTestDot = (f)=>f !== "." && f !== ".." && f.includes(".");
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f)=>f !== "." && f !== ".." && f.startsWith(".");
const starRE = /^\*+$/;
const starTest = (f)=>f.length !== 0 && !f.startsWith(".");
const starTestDot = (f)=>f.length !== 0 && f !== "." && f !== "..";
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = ""])=>{
    const noext = qmarksTestNoExt([
        $0
    ]);
    if (!ext) return noext;
    ext = ext.toLowerCase();
    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = ""])=>{
    const noext = qmarksTestNoExtDot([
        $0
    ]);
    if (!ext) return noext;
    ext = ext.toLowerCase();
    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = ""])=>{
    const noext = qmarksTestNoExtDot([
        $0
    ]);
    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = ""])=>{
    const noext = qmarksTestNoExt([
        $0
    ]);
    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0])=>{
    const len = $0.length;
    return (f)=>f.length === len && !f.startsWith(".");
};
const qmarksTestNoExtDot = ([$0])=>{
    const len = $0.length;
    return (f)=>f.length === len && f !== "." && f !== "..";
};
/* c8 ignore start */ const defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
const path = {
    win32: {
        sep: "\\"
    },
    posix: {
        sep: "/"
    }
};
/* c8 ignore stop */ const sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const mjs_qmark = "[^/]";
// * => any number of characters
const mjs_star = mjs_qmark + "*?";
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
const filter = (pattern, options = {})=>(p)=>minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {})=>Object.assign({}, a, b);
const defaults = (def)=>{
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}){
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */ constructor(type, parent, options = {}){
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */ static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),
        escape: (s, options = {})=>orig.escape(s, ext(def, options)),
        filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),
        defaults: (options)=>orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {})=>{
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [
            pattern
        ];
    }
    return brace_expansion(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {})=>{
    const mm = new Minimatch(pattern, options);
    list = list.filter((f)=>mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const mjs_regExpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Minimatch {
    constructor(pattern, options = {}){
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set){
            for (const part of pattern){
                if (typeof part !== "string") return true;
            }
        }
        return false;
    }
    debug(..._) {}
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [
            ...new Set(this.braceExpand())
        ];
        if (options.debug) {
            this.debug = (...args)=>console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __)=>{
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [
                        ...s.slice(0, 4),
                        ...s.slice(4).map((ss)=>this.parse(ss))
                    ];
                } else if (isDrive) {
                    return [
                        s[0],
                        ...s.slice(1).map((ss)=>this.parse(ss))
                    ];
                }
            }
            return s.map((ss)=>this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter((s)=>s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for(let i = 0; i < this.set.length; i++){
                const p = this.set[i];
                if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
                    p[2] = "?";
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for(let i = 0; i < globParts.length; i++){
                for(let j = 0; j < globParts[i].length; j++){
                    if (globParts[i][j] === "**") {
                        globParts[i][j] = "*";
                    }
                }
            }
        }
        const { optimizationLevel =1  } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        } else {
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts)=>{
            let gs = -1;
            while(-1 !== (gs = parts.indexOf("**", gs + 1))){
                let i = gs;
                while(parts[i + 1] === "**"){
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map((parts)=>{
            parts = parts.reduce((set, part)=>{
                const prev = set[set.length - 1];
                if (part === "**" && prev === "**") {
                    return set;
                }
                if (part === "..") {
                    if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [
                ""
            ] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for(let i = 1; i < parts.length - 1; i++){
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === "" && parts[0] === "") continue;
                    if (p === "." || p === "") {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while(-1 !== (dd = parts.indexOf("..", dd + 1))){
                const p = parts[dd - 1];
                if (p && p !== "." && p !== ".." && p !== "**") {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        }while (didSomething);
        return parts.length === 0 ? [
            ""
        ] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts){
                let gs = -1;
                while(-1 !== (gs = parts.indexOf("**", gs + 1))){
                    let gss = gs;
                    while(parts[gss + 1] === "**"){
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== "..") continue;
                    if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = "**";
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for(let i = 1; i < parts.length - 1; i++){
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === "" && parts[0] === "") continue;
                        if (p === "." || p === "") {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while(-1 !== (dd = parts.indexOf("..", dd + 1))){
                    const p = parts[dd - 1];
                    if (p && p !== "." && p !== ".." && p !== "**") {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === "**";
                        const splin = needDot ? [
                            "."
                        ] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0) parts.push("");
                        dd -= 2;
                    }
                }
            }
        }while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for(let i = 0; i < globParts.length - 1; i++){
            for(let j = i + 1; j < globParts.length; j++){
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (!matched) continue;
                globParts[i] = matched;
                globParts[j] = [];
            }
        }
        return globParts.filter((gs)=>gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while(ai < a.length && bi < b.length){
            if (a[ai] === b[bi]) {
                result.push(which === "b" ? b[bi] : a[ai]);
                ai++;
                bi++;
            } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
                if (which === "b") return false;
                which = "a";
                result.push(a[ai]);
                ai++;
                bi++;
            } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
                if (which === "a") return false;
                which = "b";
                result.push(b[bi]);
                ai++;
                bi++;
            } else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for(let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++){
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === "number" && typeof pdi === "number") {
                const [fd, pd] = [
                    file[fdi],
                    pattern[pdi]
                ];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    } else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel =1  } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, {
            file,
            pattern
        });
        this.debug("matchOne", file.length, pattern.length);
        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */ if (p === false) {
                return false;
            }
            /* c8 ignore stop */ if (p === GLOBSTAR) {
                this.debug("GLOBSTAR", [
                    pattern,
                    p,
                    f
                ]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug("** at the end");
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for(; fi < fl; fi++){
                        if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while(fr < fl){
                    var swallowee = file[fr];
                    this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug("globstar found match!", fr, fl, swallowee);
                        // found a match.
                        return true;
                    } else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                            this.debug("dot detected!", file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug("globstar swallow a segment, and continue");
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */ if (partial) {
                    // ran out of file
                    this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */ return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === "string") {
                hit = f === p;
                this.debug("string match", p, f, hit);
            } else {
                hit = p.test(f);
                this.debug("pattern match", p, f, hit);
            }
            if (!hit) return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        } else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        } else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === "";
        /* c8 ignore start */ } else {
            // should be unreachable.
            throw new Error("wtf?");
        }
    /* c8 ignore stop */ }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === "**") return GLOBSTAR;
        if (pattern === "") return "";
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
            fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
            fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
            fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        return fastTest ? Object.assign(re, {
            test: fastTest
        }) : re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? mjs_star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? [
            "i"
        ] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set.map((pattern)=>{
            const pp = pattern.map((p)=>{
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(""))flags.add(f);
                }
                return typeof p === "string" ? mjs_regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
            });
            pp.forEach((p, i)=>{
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
                    } else {
                        pp[i] = twoStar;
                    }
                } else if (next === undefined) {
                    pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
                } else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter((p)=>p !== GLOBSTAR).join("/");
        }).join("|");
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? [
            "(?:",
            ")"
        ] : [
            "",
            ""
        ];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = "^" + open + re + close + "$";
        // can match anything, as long as it's not this.
        if (this.negate) re = "^(?!" + re + ").+$";
        try {
            this.regexp = new RegExp(re, [
                ...flags
            ].join(""));
        /* c8 ignore start */ } catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */ return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return [
                "",
                ...p.split(/\/+/)
            ];
        } else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === "";
        }
        if (f === "/" && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split("\\").join("/");
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, "set", set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for(let i = ff.length - 2; !filename && i >= 0; i--){
                filename = ff[i];
            }
        }
        for(let i = 0; i < set.length; i++){
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [
                    filename
                ];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore start */ 


/* c8 ignore stop */ minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape_escape;
minimatch.unescape = unescape_unescape; //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/lru-cache/dist/mjs/index.js
/**
 * @module LRUCache
 */ const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = new Set();
/* c8 ignore start */ const PROCESS = typeof process === "object" && !!process ? process : {};
/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */ if (typeof AC === "undefined") {
    //@ts-ignore
    AS = class AbortSignal {
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
        constructor(){
            this._onabort = [];
            this.aborted = false;
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor(){
            this.signal = new AS();
            warnACPolyfill();
        }
        abort(reason) {
            if (this.signal.aborted) return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort){
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = ()=>{
        if (!printACPolyfillWarning) return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
}
/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);
const TYPE = Symbol("type");
const isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */ // This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */ class ZeroArray extends Array {
    constructor(size){
        super(size);
        this.fill(0);
    }
}
class Stack {
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls) return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls){
        /* c8 ignore start */ if (!Stack.#constructing) {
            throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        /* c8 ignore stop */ this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */ class LRUCache {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */ static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head () {
                return c.#head;
            },
            get tail () {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),
            moveToTail: (index)=>c.#moveToTail(index),
            indexes: (options)=>c.#indexes(options),
            rindexes: (options)=>c.#rindexes(options),
            isStale: (index)=>c.#isStale(index)
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */ get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */ get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */ get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */ get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */ get fetchMethod() {
        return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */ get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */ get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options){
        // conditionally set private methods related to TTL
        this.#updateItemAge = ()=>{};
        this.#statusTTL = ()=>{};
        this.#setItemTTL = ()=>{};
        /* c8 ignore stop */ this.#isStale = ()=>false;
        this.#removeItemSize = (_i)=>{};
        this.#addItemSize = (_i, _s, _st)=>{};
        this.#requireSize = (_k, _v, size, sizeCalculation)=>{
            if (size || sizeCalculation) {
                throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
            }
            return 0;
        };
        const { max =0 , ttl , ttlResolution =1 , ttlAutopurge , updateAgeOnGet , updateAgeOnHas , allowStale , dispose , disposeAfter , noDisposeOnSet , noUpdateTTL , maxSize =0 , maxEntrySize =0 , sizeCalculation , fetchMethod , noDeleteOnFetchRejection , noDeleteOnStaleGet , allowStaleOnFetchRejection , allowStaleOnFetchAbort , ignoreFetchAbort  } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
            }
            if (typeof this.sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation set to non-function");
            }
        }
        if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError("maxSize must be a positive integer if specified");
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError("maxEntrySize must be a positive integer if specified");
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError("ttl must be a positive integer if specified");
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
                emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
            }
        }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */ getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now())=>{
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(()=>{
                    if (this.#isStale(index)) {
                        this.delete(this.#keyList[index]);
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
        };
        this.#updateItemAge = (index)=>{
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index)=>{
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = ()=>{
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
            return n;
        };
        this.getRemainingTTL = (key)=>{
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (ttl === 0 || start === 0) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = (index)=>{
            return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
        };
    }
    #updateItemAge;
    #statusTTL;
    #setItemTTL;
    #isStale;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index)=>{
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation)=>{
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== "function") {
                        throw new TypeError("sizeCalculation must be a function");
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                    }
                } else {
                    throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status)=>{
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while(this.#calculatedSize > maxSize){
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize;
    #addItemSize;
    #requireSize;
    *#indexes({ allowStale =this.allowStale  } = {}) {
        if (this.#size) {
            for(let i = this.#tail; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                } else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale =this.allowStale  } = {}) {
        if (this.#size) {
            for(let i = this.#head; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                } else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */ *entries() {
        for (const i of this.#indexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */ *rentries() {
        for (const i of this.#rindexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */ *keys() {
        for (const i of this.#indexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */ *rkeys() {
        for (const i of this.#rindexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */ *values() {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */ *rvalues() {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */ find(fn, getOptions = {}) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */ forEach(fn, thisp = this) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */ rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */ purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({
            allowStale: true
        })){
            if (this.#isStale(i)) {
                this.delete(this.#keyList[i]);
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */ dump() {
        const arr = [];
        for (const i of this.#indexes({
            allowStale: true
        })){
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined) continue;
            const entry = {
                value
            };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([
                key,
                entry
            ]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */ load(arr) {
        this.clear();
        for (const [key, entry] of arr){
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */ set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl =this.ttl , start , noDisposeOnSet =this.noDisposeOnSet , sizeCalculation =this.sizeCalculation , status  } = setOptions;
        let { noUpdateTTL =this.noUpdateTTL  } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = "miss";
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.delete(k);
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = "add";
            noUpdateTTL = false;
        } else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error("replaced"));
                } else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, "set");
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([
                            oldVal,
                            k,
                            "set"
                        ]);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = "replace";
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = "update";
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */ pop() {
        try {
            while(this.#size){
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                } else if (val !== undefined) {
                    return val;
                }
            }
        } finally{
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while(task = dt?.shift()){
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, "evict");
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([
                    v,
                    k,
                    "evict"
                ]);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        } else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */ has(k, hasOptions = {}) {
        const { updateAgeOnHas =this.updateAgeOnHas , status  } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = "hit";
                    this.#statusTTL(status, index);
                }
                return true;
            } else if (status) {
                status.has = "stale";
                this.#statusTTL(status, index);
            }
        } else if (status) {
            status.has = "miss";
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */ peek(k, peekOptions = {}) {
        const { allowStale =this.allowStale  } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined && (allowStale || !this.#isStale(index))) {
            const v = this.#valList[index];
            // either stale and allowed, or forcing a refresh of non-stale value
            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal  } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener("abort", ()=>ac.abort(signal.reason), {
            signal: ac.signal
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context
        };
        const cb = (v, updateCache = false)=>{
            const { aborted  } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort) options.status.fetchAbortIgnored = true;
                } else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    } else {
                        this.delete(k);
                    }
                } else {
                    if (options.status) options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er)=>{
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er)=>{
            const { aborted  } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                } else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej)=>{
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then((v)=>res(v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener("abort", ()=>{
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res();
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = (v)=>cb(v, true);
                    }
                }
            });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, {
                ...fetchOpts.options,
                status: undefined
            });
            index = this.#keyMap.get(k);
        } else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod) return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
        const { // get options
        allowStale =this.allowStale , updateAgeOnGet =this.updateAgeOnGet , noDeleteOnStaleGet =this.noDeleteOnStaleGet , // set options
        ttl =this.ttl , noDisposeOnSet =this.noDisposeOnSet , size =0 , sizeCalculation =this.sizeCalculation , noUpdateTTL =this.noUpdateTTL , // fetch exclusive options
        noDeleteOnFetchRejection =this.noDeleteOnFetchRejection , allowStaleOnFetchRejection =this.allowStaleOnFetchRejection , ignoreFetchAbort =this.ignoreFetchAbort , allowStaleOnFetchAbort =this.allowStaleOnFetchAbort , context , forceRefresh =false , status , signal  } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status) status.fetch = "get";
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status) status.fetch = "miss";
            const p = this.#backgroundFetch(k, index, options, context);
            return p.__returned = p;
        } else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = "inflight";
                    if (stale) status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status) status.fetch = "hit";
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status) this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? "stale" : "refresh";
                if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */ get(k, getOptions = {}) {
        const { allowStale =this.allowStale , updateAgeOnGet =this.updateAgeOnGet , noDeleteOnStaleGet =this.noDeleteOnStaleGet , status  } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status) status.get = "stale";
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status && allowStale) status.returnedStale = true;
                    return allowStale ? value : undefined;
                } else {
                    if (status && allowStale && value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = "hit";
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        } else if (status) {
            status.get = "miss";
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            } else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */ delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.clear();
                } else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error("deleted"));
                    } else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, "delete");
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                v,
                                k,
                                "delete"
                            ]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    } else if (index === this.#head) {
                        this.#head = this.#next[index];
                    } else {
                        this.#next[this.#prev[index]] = this.#next[index];
                        this.#prev[this.#next[index]] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */ clear() {
        for (const index of this.#rindexes({
            allowStale: true
        })){
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
            } else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, "delete");
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([
                        v,
                        k,
                        "delete"
                    ]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
    }
} //# sourceMappingURL=index.js.map

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(1017);
// EXTERNAL MODULE: external "url"
var external_url_ = __webpack_require__(7310);
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(7147);
var external_fs_namespaceObject = /*#__PURE__*/__webpack_require__.t(external_fs_, 2);
// EXTERNAL MODULE: external "fs/promises"
var promises_ = __webpack_require__(3292);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(2361);
// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2781);
// EXTERNAL MODULE: external "string_decoder"
var external_string_decoder_ = __webpack_require__(1576);
;// CONCATENATED MODULE: ./node_modules/minipass/index.mjs

const proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
};



const SD = external_string_decoder_.StringDecoder;
const EOF = Symbol("EOF");
const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
const EMITTED_END = Symbol("emittedEnd");
const EMITTING_END = Symbol("emittingEnd");
const EMITTED_ERROR = Symbol("emittedError");
const CLOSED = Symbol("closed");
const READ = Symbol("read");
const FLUSH = Symbol("flush");
const FLUSHCHUNK = Symbol("flushChunk");
const ENCODING = Symbol("encoding");
const DECODER = Symbol("decoder");
const FLOWING = Symbol("flowing");
const PAUSED = Symbol("paused");
const RESUME = Symbol("resume");
const BUFFER = Symbol("buffer");
const PIPES = Symbol("pipes");
const BUFFERLENGTH = Symbol("bufferLength");
const BUFFERPUSH = Symbol("bufferPush");
const BUFFERSHIFT = Symbol("bufferShift");
const OBJECTMODE = Symbol("objectMode");
// internal event when stream is destroyed
const DESTROYED = Symbol("destroyed");
// internal event when stream has an error
const ERROR = Symbol("error");
const EMITDATA = Symbol("emitData");
const EMITEND = Symbol("emitEnd");
const EMITEND2 = Symbol("emitEnd2");
const ASYNC = Symbol("async");
const ABORT = Symbol("abort");
const ABORTED = Symbol("aborted");
const SIGNAL = Symbol("signal");
const defer = (fn)=>Promise.resolve().then(fn);
// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
const ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = (ev)=>ev === "end" || ev === "finish" || ev === "prefinish";
const isArrayBuffer = (b)=>b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
const isArrayBufferView = (b)=>!Buffer.isBuffer(b) && ArrayBuffer.isView(b);
class Pipe {
    constructor(src, dest, opts){
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = ()=>src[RESUME]();
        dest.on("drain", this.ondrain);
    }
    unpipe() {
        this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {}
    end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
    }
}
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts){
        super(src, dest, opts);
        this.proxyErrors = (er)=>dest.emit("error", er);
        src.on("error", this.proxyErrors);
    }
}
class Minipass extends external_stream_ {
    constructor(options){
        super();
        this[FLOWING] = false;
        // whether we're explicitly paused
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer") this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, "buffer", {
                get: ()=>this[BUFFER]
            });
        }
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, "pipes", {
                get: ()=>this[PIPES]
            });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
            this[SIGNAL].addEventListener("abort", ()=>this[ABORT]());
            if (this[SIGNAL].aborted) {
                this[ABORT]();
            }
        }
    }
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    get encoding() {
        return this[ENCODING];
    }
    set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map((chunk)=>this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
    }
    setEncoding(enc) {
        this.encoding = enc;
    }
    get objectMode() {
        return this[OBJECTMODE];
    }
    set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
        return this[ASYNC];
    }
    set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
    }
    get aborted() {
        return this[ABORTED];
    }
    set aborted(_) {}
    write(chunk, encoding, cb) {
        if (this[ABORTED]) return false;
        if (this[EOF]) throw new Error("write after end");
        if (this[DESTROYED]) {
            this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {
                code: "ERR_STREAM_DESTROYED"
            }));
            return true;
        }
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (!encoding) encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f)=>f();
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything else switches us into object mode
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") // use the setter so we throw if we have encoding set
            this.objectMode = true;
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            /* istanbul ignore if - maybe impossible? */ if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit("data", chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit("readable");
        if (cb) fn(cb);
        return this.flowing;
    }
    read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this[BUFFER] = [
                this[BUFFER].join("")
            ];
            else this[BUFFER] = [
                Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
            this[BUFFER][0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === "function") cb = chunk, chunk = null;
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit("drain");
    }
    resume() {
        return this[RESUME]();
    }
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
    }
    get destroyed() {
        return this[DESTROYED];
    }
    get flowing() {
        return this[FLOWING];
    }
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
        else this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain) {
        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
    }
    pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end) dest.end();
        } else {
            this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC]) defer(()=>this[RESUME]());
            else this[RESUME]();
        }
        return dest;
    }
    unpipe(dest) {
        const p = this[PIPES].find((p)=>p.dest === dest);
        if (p) {
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    addListener(ev, fn) {
        return this.on(ev, fn);
    }
    on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing) this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0) super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(()=>fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
        }
    }
    emit(ev, data, ...extra) {
        // error and close are only events allowed after calling destroy()
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) return;
        else if (ev === "data") {
            return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(()=>this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
            return this[EMITEND]();
        } else if (ev === "close") {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
        } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]){
            if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(()=>this[EMITEND2]());
        else this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]){
                    p.dest.write(data);
                }
                super.emit("data", data);
            }
        }
        for (const p of this[PIPES]){
            p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
    }
    // const all = await stream.collect()
    collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on("data", (c)=>{
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(()=>buf);
    }
    // const data = await stream.concat()
    concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf)=>this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
        return new Promise((resolve, reject)=>{
            this.on(DESTROYED, ()=>reject(new Error("stream destroyed")));
            this.on("error", (er)=>reject(er));
            this.on("end", ()=>resolve());
        });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
        let stopped = false;
        const stop = ()=>{
            this.pause();
            stopped = true;
            return Promise.resolve({
                done: true
            });
        };
        const next = ()=>{
            if (stopped) return stop();
            const res = this.read();
            if (res !== null) return Promise.resolve({
                done: false,
                value: res
            });
            if (this[EOF]) return stop();
            let resolve = null;
            let reject = null;
            const onerr = (er)=>{
                this.removeListener("data", ondata);
                this.removeListener("end", onend);
                this.removeListener(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value)=>{
                this.removeListener("error", onerr);
                this.removeListener("end", onend);
                this.removeListener(DESTROYED, ondestroy);
                this.pause();
                resolve({
                    value: value,
                    done: !!this[EOF]
                });
            };
            const onend = ()=>{
                this.removeListener("error", onerr);
                this.removeListener("data", ondata);
                this.removeListener(DESTROYED, ondestroy);
                stop();
                resolve({
                    done: true
                });
            };
            const ondestroy = ()=>onerr(new Error("stream destroyed"));
            return new Promise((res, rej)=>{
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once("error", onerr);
                this.once("end", onend);
                this.once("data", ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [ASYNCITERATOR] () {
                return this;
            }
        };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
        let stopped = false;
        const stop = ()=>{
            this.pause();
            this.removeListener(ERROR, stop);
            this.removeListener(DESTROYED, stop);
            this.removeListener("end", stop);
            stopped = true;
            return {
                done: true
            };
        };
        const next = ()=>{
            if (stopped) return stop();
            const value = this.read();
            return value === null ? stop() : {
                value
            };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [ITERATOR] () {
                return this;
            }
        };
    }
    destroy(er) {
        if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED]) this.close();
        if (er) this.emit("error", er);
        else this.emit(DESTROYED);
        return this;
    }
    static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof external_stream_ || s instanceof external_events_ && // readable
        (typeof s.pipe === "function" || // writable
        typeof s.write === "function" && typeof s.end === "function"));
    }
}

;// CONCATENATED MODULE: ./node_modules/path-scurry/dist/mjs/index.js





const realpathSync = external_fs_.realpathSync.native;
// TODO: test perf of fs/promises realpath vs realpathCB,
// since the promises one uses realpath.native


const defaultFS = {
    lstatSync: external_fs_.lstatSync,
    readdir: external_fs_.readdir,
    readdirSync: external_fs_.readdirSync,
    readlinkSync: external_fs_.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises_.lstat,
        readdir: promises_.readdir,
        readlink: promises_.readlink,
        realpath: promises_.realpath
    }
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption)=>!fsOption || fsOption === defaultFS || fsOption === external_fs_namespaceObject ? defaultFS : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...fsOption.promises || {}
        }
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath)=>rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 1;
const IFCHR = 2;
const IFDIR = 4;
const IFBLK = 6;
const IFREG = 8;
const IFLNK = 10;
const IFSOCK = 12;
const IFMT = 15;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 16;
// set after a successful lstat()
const LSTAT_CALLED = 32;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 64;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 128;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 256;
// set if we know realpath() will fail
const ENOREALPATH = 512;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 1023;
const entToType = (s)=>s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s)=>{
    const c = normalizeCache.get(s);
    if (c) return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s)=>{
    const c = normalizeNocaseCache.get(s);
    if (c) return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */ class ResolveCache extends LRUCache {
    constructor(){
        super({
            max: 256
        });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */ class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024){
        super({
            maxSize,
            // parent + children
            sizeCalculation: (a)=>a.length + 1
        });
    }
}
const setAsCwd = Symbol("PathScurry setAsCwd");
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */ class PathBase {
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */ get path() {
        return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){
        this.#onReaddirCB = [];
        this.#readdirCBInFlight = false;
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        } else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */ depth() {
        if (this.#depth !== undefined) return this.#depth;
        if (!this.parent) return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
    }
    /**
     * @internal
     */ childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */ resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts){
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */ children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], {
            provisional: 0
        });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */ child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
            return this;
        }
        if (pathPart === "..") {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children){
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */ relative() {
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */ relativePosix() {
        if (this.sep === "/") return this.relative();
        if (this.#relativePosix !== undefined) return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */ fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return this.#fullpath = fp;
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */ fullpathPosix() {
        if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;
        if (this.sep === "/") return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, "/");
            if (/^[a-z]:\//i.test(p)) {
                return this.#fullpathPosix = `//?/${p}`;
            } else {
                return this.#fullpathPosix = p;
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */ isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    /**
     * Is the Path a regular file?
     */ isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */ isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */ isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */ isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */ isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */ isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */ isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */ lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */ readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */ realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */ readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */ canReadlink() {
        if (this.#linkTarget) return true;
        if (!this.parent) return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */ calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */ isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */ isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */ async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */ try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = this.parent.resolve(read);
            if (linkTarget) {
                return this.#linkTarget = linkTarget;
            }
        } catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */ readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */ try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.resolve(read);
            if (linkTarget) {
                return this.#linkTarget = linkTarget;
            }
        } catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for(let p = children.provisional; p < children.length; p++){
            children[p].#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT) return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children){
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */ if (this.#type & ENOTDIR) return;
        /* c8 ignore stop */ let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === "ENOTDIR" || code === "EPERM") {
            this.#markENOTDIR();
        } else if (code === "ENOENT") {
            this.#markENOENT();
        } else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = "") {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */ if (code === "ENOTDIR") {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        } else if (code === "ENOENT") {
            /* c8 ignore stop */ this.#markENOENT();
        }
    }
    #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT") ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === "EINVAL" || code === "UNKNOWN") {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */ if (code === "ENOTDIR" && this.parent) {
            this.parent.#markENOTDIR();
        }
    /* c8 ignore stop */ }
    #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, {
            parent: this
        });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for(let p = c.provisional; p < c.length; p++){
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name) p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1) c.pop();
            else c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */ async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            } catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */ lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            } catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime , atimeMs , birthtime , birthtimeMs , blksize , blocks , ctime , ctimeMs , dev , gid , ino , mode , mtime , mtimeMs , nlink , rdev , size , uid  } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB;
    #readdirCBInFlight;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb)=>cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */ readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo) cb(null, []);
            else queueMicrotask(()=>cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo) cb(null, c);
            else queueMicrotask(()=>cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, {
            withFileTypes: true
        }, (er, entries)=>{
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            } else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries){
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */ async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        } else {
            /* c8 ignore start */ let resolve = ()=>{};
            /* c8 ignore stop */ this.#asyncReaddirInFlight = new Promise((res)=>resolve = res);
            try {
                for (const e of (await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true
                }))){
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            } catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */ readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true
            })){
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD) return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */ if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */ return true;
    }
    shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */ async realpath() {
        if (this.#realpath) return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return this.#realpath = this.resolve(rp);
        } catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */ realpathSync() {
        if (this.#realpath) return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return this.#realpath = this.resolve(rp);
        } catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */ [setAsCwd](oldCwd) {
        if (oldCwd === this) return;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while(p && p.parent){
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join("/");
            p = p.parent;
            rp.push("..");
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while(p && p.parent && !changed.has(p)){
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */ class PathWin32 extends PathBase {
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){
        super(name, type, root, roots, nocase, children, opts);
        /**
     * Separator for generating path strings.
     */ this.sep = "\\";
        /**
     * Separator for parsing path strings.
     */ this.splitSep = eitherSep;
    }
    /**
     * @internal
     */ newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */ getRootString(path) {
        return external_path_.win32.parse(path).root;
    }
    /**
     * @internal
     */ getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)){
            if (this.sameRoot(rootPath, compare)) {
                return this.roots[rootPath] = root;
            }
        }
        // otherwise, have to create a new one.
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    /**
     * @internal
     */ sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
    }
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */ class PathPosix extends PathBase {
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){
        super(name, type, root, roots, nocase, children, opts);
        /**
     * separator for parsing path strings
     */ this.splitSep = "/";
        /**
     * separator for generating path strings
     */ this.sep = "/";
    }
    /**
     * @internal
     */ getRootString(path) {
        return path.startsWith("/") ? "/" : "";
    }
    /**
     * @internal
     */ getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */ newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */ class PathScurryBase {
    #resolveCache;
    #resolvePosixCache;
    #children;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */ constructor(cwd = process.cwd(), pathImpl, sep, { nocase , childrenCacheSize =16 * 1024 , fs =defaultFS  } = {}){
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
            cwd = (0,external_url_.fileURLToPath)(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */ if (nocase === undefined) {
            throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        /* c8 ignore stop */ this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split){
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill("..").join(joinSep),
                relativePosix: new Array(l).fill("..").join("/"),
                fullpath: abs += (sawFirst ? "" : joinSep) + part
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */ depth(path = this.cwd) {
        if (typeof path === "string") {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */ childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */ resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = "";
        for(let i = paths.length - 1; i >= 0; i--){
            const p = paths[i];
            if (!p || p === ".") continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */ resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = "";
        for(let i = paths.length - 1; i >= 0; i--){
            const p = paths[i];
            if (!p || p === ".") continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */ relative(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */ relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */ basename(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */ dirname(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes  } = opts;
        if (!entry.canReaddir()) {
            return [];
        } else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map((e)=>e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true  } = opts;
        if (!entry.canReaddir()) {
            return [];
        } else if (withFileTypes) {
            return entry.readdirSync();
        } else {
            return entry.readdirSync().map((e)=>e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */ async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */ lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes  } = {
        withFileTypes: false
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes  } = {
        withFileTypes: false
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes  } = {
        withFileTypes: false
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes  } = {
        withFileTypes: false
    }) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true , follow =false , filter , walkFilter  } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb)=>{
            dirs.add(dir);
            dir.readdirCB((er, entries)=>{
                /* c8 ignore start */ if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */ let len = entries.length;
                if (!len) return cb();
                const next = ()=>{
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries){
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r).then((r)=>r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    } else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        } else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej)=>{
            walk(start, (er)=>{
                /* c8 ignore start */ if (er) return rej(er);
                /* c8 ignore stop */ res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true , follow =false , filter , walkFilter  } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([
            entry
        ]);
        for (const dir of dirs){
            const entries = dir.readdirSync();
            for (const e of entries){
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync()))) continue;
                    if (r.isUnknown()) r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */ [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */ [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true , follow =false , filter , walkFilter  } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([
            entry
        ]);
        for (const dir of dirs){
            const entries = dir.readdirSync();
            for (const e of entries){
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync()))) continue;
                    if (r.isUnknown()) r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true , follow =false , filter , walkFilter  } = opts;
        const results = new Minipass({
            objectMode: true
        });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [
            entry
        ];
        let processing = 0;
        const process1 = ()=>{
            let paused = false;
            while(!paused){
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0) results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false)=>{
                    /* c8 ignore start */ if (er) return results.emit("error", er);
                    /* c8 ignore stop */ if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries){
                            if (e.isSymbolicLink()) {
                                promises.push(e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(()=>onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries){
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries){
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once("drain", process1);
                    } else if (!sync) {
                        process1();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process1();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
            entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes =true , follow =false , filter , walkFilter  } = opts;
        const results = new Minipass({
            objectMode: true
        });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [
            entry
        ];
        let processing = 0;
        const process1 = ()=>{
            let paused = false;
            while(!paused){
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0) results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries){
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries){
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync()))) continue;
                        if (r.isUnknown()) r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing) results.once("drain", process1);
        };
        process1();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === "string" ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */ class PathScurryWin32 extends PathScurryBase {
    constructor(cwd = process.cwd(), opts = {}){
        const { nocase =true  } = opts;
        super(cwd, external_path_.win32, "\\", {
            ...opts,
            nocase
        });
        /**
     * separator for generating path strings
     */ this.sep = "\\";
        this.nocase = nocase;
        for(let p = this.cwd; p; p = p.parent){
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */ parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return external_path_.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */ newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {
            fs
        });
    }
    /**
     * Return true if the provided path string is an absolute path
     */ isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */ class PathScurryPosix extends PathScurryBase {
    constructor(cwd = process.cwd(), opts = {}){
        const { nocase =false  } = opts;
        super(cwd, external_path_.posix, "/", {
            ...opts,
            nocase
        });
        /**
     * separator for generating path strings
     */ this.sep = "/";
        this.nocase = nocase;
    }
    /**
     * @internal
     */ parseRootPath(_dir) {
        return "/";
    }
    /**
     * @internal
     */ newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {
            fs
        });
    }
    /**
     * Return true if the provided path string is an absolute path
     */ isAbsolute(p) {
        return p.startsWith("/");
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */ class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}){
        const { nocase =true  } = opts;
        super(cwd, {
            ...opts,
            nocase
        });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */ const Path = process.platform === "win32" ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */ const PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix; //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/pattern.js
// this is just a very light wrapper around 2 arrays with an offset index

const isPatternList = (pl)=>pl.length >= 1;
const isGlobList = (gl)=>gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */ class Pattern {
    #patternList;
    #globList;
    #index;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar;
    constructor(patternList, globList, index, platform){
        this.#followGlobstar = true;
        if (!isPatternList(patternList)) {
            throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
            throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
            throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === "") {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [
                    p0,
                    p1,
                    p2,
                    p3,
                    ""
                ].join("/");
                const g = [
                    g0,
                    g1,
                    g2,
                    g3,
                    ""
                ].join("/");
                this.#patternList = [
                    p,
                    ...prest
                ];
                this.#globList = [
                    g,
                    ...grest
                ];
                this.length = this.#patternList.length;
            } else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === "") {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + "/";
                const g = g1 + "/";
                this.#patternList = [
                    p,
                    ...prest
                ];
                this.#globList = [
                    g,
                    ...grest
                ];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */ pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */ isString() {
        return typeof this.#patternList[this.#index] === "string";
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */ isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */ isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */ globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    /**
     * true if there are more pattern parts after this one
     */ hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */ rest() {
        if (this.#rest !== undefined) return this.#rest;
        if (!this.hasMore()) return this.#rest = null;
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */ isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */ isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */ isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    /**
     * consume the root of the pattern, and return it
     */ root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */ checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */ markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar) return false;
        this.#followGlobstar = false;
        return true;
    }
} //# sourceMappingURL=pattern.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/ignore.js
// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode


const ignore_defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
/**
 * Class used to process ignored patterns
 */ class Ignore {
    constructor(ignored, { nobrace , nocase , noext , noglobstar , platform =ignore_defaultPlatform  }){
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        const mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true
        };
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        for (const ign of ignored){
            const mm = new Minimatch(ign, mmopts);
            for(let i = 0; i < mm.set.length; i++){
                const parsed = mm.set[i];
                const globParts = mm.globParts[i];
                const p = new Pattern(parsed, globParts, 0, platform);
                const m = new Minimatch(p.globString(), mmopts);
                const children = globParts[globParts.length - 1] === "**";
                const absolute = p.isAbsolute();
                if (absolute) this.absolute.push(m);
                else this.relative.push(m);
                if (children) {
                    if (absolute) this.absoluteChildren.push(m);
                    else this.relativeChildren.push(m);
                }
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative){
            if (m.match(relative) || m.match(relatives)) return true;
        }
        for (const m of this.absolute){
            if (m.match(fullpath) || m.match(fullpaths)) return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren){
            if (m.match(relative)) return true;
        }
        for (const m of this.absoluteChildren){
            if (m.match(fullpath)) true;
        }
        return false;
    }
} //# sourceMappingURL=ignore.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/processor.js
// synchronous utility for filtering entries and calculating subwalks

/**
 * A cache of which patterns have been processed for a given Path
 */ class HasWalkedCache {
    constructor(store = new Map()){
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached) cached.add(pattern.globString());
        else this.store.set(fullpath, new Set([
            pattern.globString()
        ]));
    }
}
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */ class MatchRecord {
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [
            ...this.store.entries()
        ].map(([path, n])=>[
                path,
                !!(n & 2),
                !!(n & 1)
            ]);
    }
    constructor(){
        this.store = new Map();
    }
}
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */ class SubWalks {
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find((p)=>p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        } else this.store.set(target, [
            pattern
        ]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */ if (!subs) {
            throw new Error("attempting to walk unknown path");
        }
        /* c8 ignore stop */ return subs;
    }
    entries() {
        return this.keys().map((k)=>[
                k,
                this.store.get(k)
            ]);
    }
    keys() {
        return [
            ...this.store.keys()
        ].filter((t)=>t.canReaddir());
    }
    constructor(){
        this.store = new Map();
    }
}
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */ class Processor {
    constructor(opts, hasWalkedCache){
        this.matches = new MatchRecord();
        this.subwalks = new SubWalks();
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p)=>[
                target,
                p
            ]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet){
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === "/" && this.opts.root !== undefined ? this.opts.root : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                } else {
                    pattern = rest;
                }
            }
            if (t.isENOENT()) continue;
            let p;
            let rest;
            let changed = false;
            while(typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())){
                const c = t.resolve(p);
                // we can be reasonably sure that .. is a readable dir
                if (c.isUnknown() && p !== "..") break;
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern)) continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === "string") {
                // must be final entry
                if (!rest) {
                    const ifDir = p === ".." || p === "" || p === ".";
                    this.matches.add(t.resolve(p), absolute, ifDir);
                } else {
                    this.subwalks.add(t, pattern);
                }
                continue;
            } else if (p === GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || (rp === "" || rp === ".") && !rrest) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === "" || rp === ".");
                } else {
                    if (rp === "..") {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */ const tp = t.parent || t;
                        /* c8 ignore stop */ if (!rrest) this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            } else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries){
            for (const pattern of patterns){
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                } else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                } else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                } else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    } else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === "string" && // dots and empty were handled already
            rp !== ".." && rp !== "" && rp !== ".") {
                this.testString(e, rp, rest.rest(), absolute);
            } else if (rp === "..") {
                /* c8 ignore start */ const ep = e.parent || e;
                /* c8 ignore stop */ this.subwalks.add(ep, rest);
            } else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name)) return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        } else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p)) return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        } else {
            this.subwalks.add(e, rest);
        }
    }
} //# sourceMappingURL=processor.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/walker.js
/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */ 


const makeIgnore = (ignore, opts)=>typeof ignore === "string" ? new Ignore([
        ignore
    ], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */ class GlobUtil {
    #onResume;
    #ignore;
    #sep;
    constructor(patterns, path, opts){
        this.seen = new Set();
        this.paused = false;
        this.aborted = false;
        this.#onResume = [];
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */ this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */ if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener("abort", ()=>{
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */ if (this.signal?.aborted) return;
        /* c8 ignore stop */ this.paused = false;
        let fn = undefined;
        while(!this.paused && (fn = this.#onResume.shift())){
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted) return;
        /* c8 ignore start */ if (!this.paused) {
            fn();
        } else {
            /* c8 ignore stop */ this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir) return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || await e.realpath();
            if (!rpc) return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir) return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc) return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e)) return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        } else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        } else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
            this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p) this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p) this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */ if (this.signal?.aborted) cb();
        /* c8 ignore stop */ this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target)) return cb();
        if (this.signal?.aborted) cb();
        if (this.paused) {
            this.onResume(()=>this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = ()=>{
            if (--tasks === 0) cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()){
            if (this.#ignored(m)) continue;
            tasks++;
            this.match(m, absolute, ifDir).then(()=>next());
        }
        for (const t of processor.subwalkTargets()){
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir()) this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries)=>this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = ()=>{
            if (--tasks === 0) cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()){
            if (this.#ignored(m)) continue;
            tasks++;
            this.match(m, absolute, ifDir).then(()=>next());
        }
        for (const [target, patterns] of processor.subwalks.entries()){
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */ if (this.signal?.aborted) cb();
        /* c8 ignore stop */ this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target)) return cb();
        if (this.signal?.aborted) cb();
        if (this.paused) {
            this.onResume(()=>this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = ()=>{
            if (--tasks === 0) cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()){
            if (this.#ignored(m)) continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()){
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = ()=>{
            if (--tasks === 0) cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()){
            if (this.#ignored(m)) continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()){
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
class GlobWalker extends GlobUtil {
    constructor(patterns, path, opts){
        super(patterns, path, opts);
        this.matches = new Set();
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted) throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej)=>{
            this.walkCB(this.path, this.patterns, ()=>{
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                } else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted) throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, ()=>{
            if (this.signal?.aborted) throw this.signal.reason;
        });
        return this.matches;
    }
}
class GlobStream extends GlobUtil {
    constructor(patterns, path, opts){
        super(patterns, path, opts);
        this.results = new Minipass({
            signal: this.signal,
            objectMode: true
        });
        this.results.on("drain", ()=>this.resume());
        this.results.on("resume", ()=>this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing) this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(()=>{
                this.walkCB(target, this.patterns, ()=>this.results.end());
            });
        } else {
            this.walkCB(target, this.patterns, ()=>this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, ()=>this.results.end());
        return this.results;
    }
} //# sourceMappingURL=walker.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/glob.js





// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const glob_defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
/**
 * An object that can perform glob pattern traversals.
 */ class Glob {
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */ constructor(pattern, opts){
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
            opts.cwd = (0,external_url_.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
            pattern = [
                pattern
            ];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map((p)=>p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError("base matching requires globstar");
            }
            pattern = pattern.map((p)=>p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || glob_defaultPlatform;
        this.opts = {
            ...opts,
            platform: this.platform
        };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined && opts.nocase !== opts.scurry.nocase) {
                throw new Error("nocase option contradicts provided scurry option");
            }
        } else {
            const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p)=>new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m)=>{
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [
            [],
            []
        ]);
        this.patterns = matchSet.map((set, i)=>{
            return new Pattern(set, globParts[i], 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...await new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
                platform: this.platform,
                nocase: this.nocase
            }).walk()
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
                platform: this.platform,
                nocase: this.nocase
            }).walkSync()
        ];
    }
    stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase
        }).stream();
    }
    streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */ iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */ iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
} //# sourceMappingURL=glob.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/has-magic.js

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */ const hasMagic = (pattern, options = {})=>{
    if (!Array.isArray(pattern)) {
        pattern = [
            pattern
        ];
    }
    for (const p of pattern){
        if (new Minimatch(p, options).hasMagic()) return true;
    }
    return false;
}; //# sourceMappingURL=has-magic.js.map

;// CONCATENATED MODULE: ./node_modules/glob/dist/mjs/index.js



function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync = globStreamSync;
const stream = Object.assign(globStream, {
    sync: globStreamSync
});
const iterateSync = globIterateSync;
const iterate = Object.assign(globIterate, {
    sync: globIterateSync
});
const sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
});
/* c8 ignore start */ 


/* c8 ignore stop */ const glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob: Glob,
    hasMagic: hasMagic,
    escape: escape_escape,
    unescape: unescape_unescape
});
glob.glob = glob; //# sourceMappingURL=index.js.map


/***/ })

};
;